__TOC__


'''Предисловие к первому изданию'''

-----

Данная спецификация виртуальной машины Java написана для полного документирования архитектуры виртуальной машины Java. Она важна для разработчиков компиляторов, которые проектируют виртуальную машину Java и для программистов, реализующих совместимую виртуальную машину Java.

Виртуальная машина Java является абстрактной машиной. ''Ссылки на виртуальную машину Java'' в данной спецификации обращены к абстрактной машине, а не к реализации от компании Oracle либо любой другой конкретной реализации. Данная спецификация служит документом для конкретной реализации виртуальной машины Java только как чертёж, служащий документом для постройки дома. Реализация виртуальной машины Java (также известная как интерпретатор времени выполнения) должна воплощать в себе данную спецификацию, но ограничения на реализацию накладываются только там, где это действительно необходимо.  

Виртуальная машина  Java, описанная здесь совместима с Java Platform<sup>TM</sup>,
Standard Edition 7 и поддерживает язык программирования Java, описанный в ''Спецификации языка  Java, Java SE 7 Edition''.

Мы намеревались так написать эту спецификацию, чтобы предоставить полную информацию о виртуальной машине Java и сделать возможным появление других полностью совместимых между собой реализаций. Если вы задумали создать свою собственную реализацию виртуальной машины Java, без колебаний обращайтесь к авторам спецификации за дополнительной информацией, чтобы получить на 100% совместимую реализацию. 

Виртуальная машина, ставшая затем виртуальной машиной Java первоначально была разработана Джеймсом Гослингом  (James Gosling) в 1992 году для поддержки языка программирования Oak. В развитии проекта к его существующему состоянию прямо или косвенно принимали участие множество людей, будучи в самых различных проектах и группах: проект Green компании Sun, проект FirstPerson, Inc., проект LiveOak, группа Java Products Group, группа JavaSoft и в настоящее время Java Platform Group компании Oracle. Авторы благодарны многим разработчикам, писавшим код и оказывавшим техническую поддержку.

Эта книга берет своё начало в качестве внутреннего проекта по документации. Кейти Волрат (Kathy Walrath) выполнила редактирование начального черновика, помогая тем самым миру увидеть первое описание внутренней реализации языка программирования Java. В то же время Марией Кемпион (Mary Campione) описание было переведено в формат HTML  и опубликовано на нашем веб-сайте, прежде чем оно было расширено до размеров книги.

Создание ''Спецификации виртуальной машины Java'' во многом обязано поддержке группы  Java Products Group, руководимой главным менеджером Рутом Хеннигаром (Ruth Hennigar), а также усилиям редакторов Лизи Френдли (Lisa Friendly) и Майка Хендриксона (Mike Hendrickson) и его группы из Addison-Wesley. Безмерно помогли поднять качество издания  множественные замечания и предложения, полученные как от редакторов  рукописи так и читтателей уже опубликованной книги. Мы особенно благодарим Ричарда Така (Richard Tuck) за его тщательное прочтение и правку рукописи. Отдельное спасибо Билу Джою (Bill Joy), чьи комментарии, правки и помощь во многом способствовали целостности и точности данной книги.  

<div align="right">
Тим Лидхольм (Tim Lindholm)

Френк Йеллин (Frank Yellin)
</div>



'''Предисловие ко второму изданию'''
-----

Во второй редакции спецификации виртуальной машины Java добавлены изменения касающиеся выхода платформы Java® 2, версии 1.2. Вторая редакция также включает в себя множественные правки и разъяснения касательно изложения спецификации, оставив при этом логическую часть спецификации без изменения. Мы попытались исправить опечатки а также откорректировать список опечаток (надеемся без привнесения новых опечаток) и добавить больше деталей в описании в случаях неясности или двусмысленности. В частности, мы исправили определённое число несоответствий между ''Спецификацией виртуальной машины Java'' и ''Спецификацией языка Java''.

Мы благодарны многим читателям, которые с усиленным вниманием прочли  первую редакцию данной книги и высветили для нас ряд проблем. Некоторые лица и группы заслуживают отдельной благодарности за то, что обратили наше внимание на проблемные места в спецификации либо непосредственно способствовали написанию нового материала:

Клара Шроер (Carla Schroer) и её команда тестировщиков совместимости в Купертино, Калифорния и Новосибирске, Россия (с особенной благодарностью Леониду Арбузову и Алексею Кайгородову) с особым усердием написали тесты совместимости для каждого тестируемого утверждения в первой редакции. В процессе работы они нашили множество мест, где исходная спецификация была либо не ясна либо неполна. 

Джероин Вермулен (Jeroen Vermeulen), Дженис Шеперд (Janice Shepherd), Роли Перера (Roly Perera), Джо Дарси (Joe Darcy) и Сандра Лузмор (Sandra Loosemore) добавили множество комментариев и ценных замечаний, которые улучшили данное издание.

Мэрилин Рэш (Marilyn Rash) и Хилари Селби Полк (Hilary Selby Polk) из редакции Addison Wesley Longman помогли нам улучшить читаемость и макет страниц в данном издании, в то время как мы были заняты технической частью спецификации. 

Особую благодарность мы направляем Гиладу Брача (Gilad Bracha), выведшему строгость изложения на принципиально новый уровень и добавившему большой объем нового материала, особенно в главах 4 и 5. Его преданность «компьютерной теологии» и несгибаемое чувство долга в отношении устранения несоответствий между ''Спецификацией виртуальной машины Java'' и ''Спецификацией языка Java'' позволили невообразимо улучшить качество данной книги.

<div align="right">
Тим Лидхольм (Tim Lindholm)

Френк Йеллин (Frank Yellin)
</div>


'''Предисловие к изданию Java SE 7'''
-----

Издание Java SE 7 ''Спецификации виртуальной машины Java'' включает в себя все изменения, сделанные со времени выхода второго издания в 1999 году. В дополнение к этому было сделано множество правок и разъяснений, согласовывающих спецификацию со многими известными реализациями виртуальной машины Java, а также с принципами, общими для виртуальной машины Java и языка программирования Java.

Разработка платформы Java SE 5.0 в 2004 году привела к множественным изменениям в языке программирования  Java, но имела относительно не большое влияние на архитектуру виртуальной машины  Java. Изменения были выполнены в формате <font face=Courier>class</font> файла для поддержки нового функционала  в языке программирования  Java, такого как обобщённые типы и методы с переменным числом параметров.

Появление платформы Java SE 6 в 2006 году не повлияло непосредственно на язык программирования Java, но привело к созданию нового подхода в проверке байткода виртуальной машины Java. Ева Роуз (Eva Rose) в своей кандидатской диссертации выполнила радикальный пересмотр верификации байткода JVM в контексте платформы Java Card<sup>TM</sup>. Это, во-первых, привело к реализации Java ME CLDC и в конце концов пересмотру процесса проверки для Java SE, описанного в главе 4.

Шень Лиань (Sheng Liang) выполнила реализацию верификатора для Java ME CLDC. Антеро Тайвалсаари (Antero Taivalsaari) руководил разработкой спецификации Java ME CLDC в целом, а Гилад Брача (Gilad Bracha) был ответственен за документацию по верификатору.  Анализ проверки байткода JVM, выполненный Алессандро Коглио (Alessandro Coglio), был самой трудоёмкой, наиболее соответствующей действительности и счерпывающей тему новой частью, добавленной в спецификацию. Вей Тао (Wei Tao) совместно с Фрэнком Йеллиным (Frank Yellin), Тимом Линдхольмом (Tim Lindholm) и Гиладом Брача написали Пролог верификатор, лёгшим в основу как спецификации Java ME так и Java SE. Затем Вей реализовал спецификацию в реальном коде «для настоящей» HotSpot JVM. Затем Мингайо Янг (Mingyao Yang) улучшил архитектуру и саму спецификацию и реализовал итоговую версию, которая превратилась в реализацию ссылок в Java SE 6. Спецификация во многом была улучшена благодаря усилиям группы JSR 202 Expert Group: Питера Бурки (Peter Burka), Алессандро Коглио (Alessandro Coglio), Сеньхун Джина (Sanghoon Jin), Кристиана Кемпера (Christian Kemper), Лэри Ро (Larry Rau), Эви Роуз (Eva Rose), Марка Штольца (Mark Stolz).

Вышедшая в 2011 году платформа Java SE 7 реализовала, данное в 1997 году в ''Спецификации виртуальной машины Java'', обещание: «В будущем, мы добавим в виртуальную машину Java новые расширения  для того чтобы представить улучшенную поддержку других языков». Гилад Брача в своей работе по динамической замене типов предвидел трудности реализации статической системы типов виртуальной машины Java в динамически типизированных языках. В результате джоном Роузом (John Rose) и экспертной группой JSR 292 Expert Group (Оля Бини (Ola Bini), Реми Форакс (Rémi Forax), Дэн Хейдинга (Dan Heidinga), Фредрик Орштром (Fredrik Öhrström), Джочен Теодору (Jochen Theodorou), а также Чарли Наттер (Charlie Nutter) и Кристиан Тайлингер (Christian Thalinger)) была разработана инструкция ''invokedynamic'' и вся необходимая инфрастуктура.

Множество людей, которых мы не упомянули в данном предисловии, внесли свою лепту в архитектуру и реализацию виртуальной машины Java. Превосходная производительность JVM, которую мы видим сегодня, была бы не достижима без технологического фундамента, заложенного Девидом Унгаром (David Ungar) и его коллегами из проекта Self компании Sun Labs. Эта технология пришла извилистый путь из проекта Self через проект Animorphic Smalltalk VM и затем, в конце концов, стала Oracle HotSpot JVM. Ларс Бак (Lars Bak) и Урс Хёльзль (Urs Hölzle) присутствовали при всех перипетиях технологии и более чем кто-либо другой ответственны за высокую производительность присущую JVM в наши дни. 

Эта спецификация был значительно улучшена благодаря усилиям следующих людей: Мартин Бакхольц (Martin Buchholz), Брайан Гоэц (Brian Goetz), Пол Хоэнси (Paul Hohensee), Девид Холмс (David Holmes), Карен Киннер (Karen Kinnear), Кейт МакГайген (Keith McGuigan), Джефф Найзвонгер (Jeff Nisewanger), Марк Рейнхольд (Mark Reinhold), Наото Сато (Naoto Sato), Билл Паф (Bill Pugh), а также Уди Даниконда (Uday Dhanikonda), Дженет Коэниг (Janet Koenig), Адам Месингер (Adam Messinger), Джон Пэмпач (John Pampuch), Джоржд Сааб (Georges Saab) и Бернард Траверсет (Bernard Traversat). Джон Картни (Jon Courtney) и Роджер Ригз (Roger Riggs) помогли гарантировать, что данная спецификация применима как к Java ME так и к Java SE. Леонид Арбузов, Станислав Авзан, Юрий Гаевский, Илья Мухин, Сергей Резник и Кирилл Широков выполнили потрясающий объем работ в Java Compatibility Kit  (набор тестов по проверки совместимости версий) для того чтобы гарантировать корректность данной спецификации.


<div align="right">
Гилад Брача (Gilad Bracha)

Алекс Бакли (Alex Buckley)

''Java Platform Group, Oracle''
</div>

<br><br><br><br>
== ГЛАВА 1. Введение ==

=== Немного истории ===

Язык программирования Java это многоцелевой, многопоточный объектно-ориентированный язык. Его синтаксис похож на C и C++ но исключает некоторые особенности, которые делают на C и C++ сложным, запутанным и небезопасным. Первоначально платформа Java была разработана для решения проблем построения программного обеспечения для сетевых устройств. Она была спроектирована для архитектур, включающих в себя множество серверов, при этом позволяя безопасно обновлять компоненты ПО. Чтобы удовлетворить этим требованиям, скомпилированный код должен быть выполняемым на любом клиенте, а также гарантировать безопасность своей работы.  
Развитие мировой паутины сделало эти требования более значимыми. Современные веб-браузеры позволяют миллионам людей путешествовать по сети и легко получать доступ  практически к любым данным. В конце концов, была создана медиа среда, в которой то, что видит и слышит пользователь, совершенно не зависит ни от типа компьютера, который он использует, ни от скорости сетевого соединения: быстрого либо медленного.

Однако активные пользователи сети вскоре обнаружили, что формат документов HTML слишком ограничен. HTML расширения, такие как формы, только подчеркнули существующие ограничения; стало ясно, что ни один браузер не в состоянии предоставить все инструменты, которые пользователи желают видеть. Выход из тупика был в расширяемости.
Первый браузер HotJava компании Sun продемонстрировал некоторые интересные свойства языка программирования  и платформы Java, дав возможность внедрять программы внутрь HTML страниц. Программы загружались непосредственно в браузер параллельно с HTML страницами, в которых они появлялись. Прежде чем браузер давал возможность выполнить программу, они проходили тщательную проверку на безопасность. Также как и HTML страницы, скомпилированные программы не зависят от протоколов сети и типов машин, на которых они выполняются. Программы ведут себя одинаково вне зависимости от того, где они были созданы и куда загружены.
 
Веб-браузер, поддерживающий платформу Java, теперь не был ограничен заранее определенным набором возможностей. Посетители веб страниц, имеющих динамическое содержимое, могли быть уверены, что их система надёжно защищена. В тоже время программисты получили возможность, однажды написав программу, запускать её на любом компьютере, поддерживающем платформу Java.

<br><br><br><br>
=== Виртуальная машина Java ===

Виртуальная машина Java является ключевым аспектом платформы Java. Это компонент технологии, который отвечает за независимость от программного обеспечения и операционной системы, небольшой размер скомпилированного кода и возможность защитить пользователей от вредоносных программ.
 
Виртуальная машина Java это абстрактная вычислительная машина. Как и реальная вычислительная машина, она имеет набор инструкций и манипулирует разными участками памяти во время своей работы. Вообще говоря, это достаточно общий подход -  реализовать язык программирования, используя виртуальную машину; наиболее известная среди таких машин – машина P-Code, реализованная в Университете Калифорнии, в Сан Диего.

Первый прототип реализации виртуальной машины Java был сделан компанией Sun Microsystems, Inc. на ручном устройстве, которое напоминало современный персональный цифровой помощник (миникомпьютер с записной книжкой, календарём и местом для хранения информации. В данный момент полностью вытеснены смартфонами - ''прим. перев.''). В настоящее время компания Oracle создала виртуальные машины Java для мобильных устройств, настольных компьютеров и серверных систем, однако сама виртуальная машина не подразумевает привязки к конкретному оборудованию, операционной системе или способу ее реализации. Виртуальная машина Java может быть реализована как компилированием ее инструкций в набор команд конкретного процессора, так и непосредственно в процессоре.

Непосредственно виртуальная машина  Java «не знает» ничего о языке программирования Java, ей лишь известен заданный формат двоичных файлов –  файлов, имеющих расширение <font face=Courier>class</font>. Эти файлы содержат инструкции виртуальной машины (байткод), таблицы символов и другую вспомогательную информацию.
Из соображений безопасности виртуальная машина Java предъявляет строгие синтаксические и структурные требования на код, расположенный в <font face=Courier>class</font> файле. Тем не менее, любой язык, функциональность которого может быть выражена в средствами корректного <font face=Courier>class</font> файла,  может быть интерпретирован для виртуальной машины Java. Привлечённые общедоступностью и платформенной независимостью, разработчики компиляторов других языков могут использовать виртуальную машину как удобную платформу для своих реализаций.

<br><br><br><br>
=== Краткое содержание глав ===

Эта книга структурирована следующим образом:

* Глава 2 содержит обзор архитектуры виртуальной машины Java.
* Глава 3 описывает принципы компиляции кода, написанного на языке программирования Java в набор инструкций виртуальной машины Java.
* Глава 4 содержит описание формата <font face=Courier>class</font> файла – формата, не зависящего от аппаратного обеспечения и операционной системы – который используется для хранения скомпилированных классов и интерфейсов.
* Глава 5 описывает запуск виртуальной машины Java, а также загрузку, компоновку и инициализацию классов и интерфейсов.
* Глава 6 определяет набор инструкций виртуальной машины Java. Инструкции расположены в алфавитном порядке их мнемонических записей.
* Глава 7 содержит таблицу инструкций виртуальной машины Java, расположенных по возрастанию их байт-кодов.  

Глава 2 ''Спецификации виртуальной машины Java (второе издание)'' содержит обзор языка программирования Java; этот обзор выполнен для описания работы виртуальной машины Java и не является частью спецификации. В ''Спецификации виртуальной машины Java (второе издание)'' читатель отсылается к Спецификации языка программирования Java SE 7 Edition за более подробной информацией о языке программирования Java. Такая ссылка имеет вид: (см. JLS §x.y).

Глава 8 ''Спецификации виртуальной машины Java (второе издание)'' посвящена низкоуровневым операциям взаимодействия потоков виртуальной машины Java с основной разделяемой памятью. Эта глава была переделана из главы 17 первой редакции ''Спецификации языка программирования Java''. Глава 17 ''Спецификации языка программирования Java SE 7 Edition'' отражает ''Спецификацию модели памяти и потоков'', составленную экспертной группой JSR-133. За информацией о блокировках и потоках читатель отсылается к соответствующим главам ''Спецификации модели памяти и потоков''.

<br><br><br><br>

=== Принятые обозначения ===

Везде в этой книге мы имеет дело только с классами и интерфейсами из Java SE API. Везде, где мы ссылаемся на класс или интерфейс с помощью идентификатора ''N'', на самом деле мы подразумеваем следующую ссылку <font face=Courier>java.lang.''N''</font>. Для классов не из пакета <font face=Courier>java.lang</font> мы используем полное имя (имя пакета и имя класса). 
Везде, где мы ссылаемся на класс или интерфейс, объявленный в пакете <font face=Courier>java</font> или любом из его подпакетов, мы имеем в виду, что класс или интерфейс загружен загрузчиком классов (см. §5.3.1).

Везде, где мы ссылаемся на подпакет объявленный в пакете <font face=Courier>java</font>, мы имеем в виду, что класс или интерфейс загружен загрузчиком классов.
В спецификации используются следующие  виды шрифтов:

* <font face=Courier>Моноширинный шрифт</font> используется для примеров исходного кода на языке программирования Java, типов данных виртуальной машины Java, исключений и ошибок.
* ''Курси''в используется для обозначения «языка ассемблера» виртуальной машины Java: операторов, операндов и элементов данный в области данный времени выполнения виртуальной машины Java. Курсив также используется для введения новых терминов и для обозначения акцента в предложении.

<br><br><br><br>
== ГЛАВА 2. Структура виртуальной машины Java ==

Этот документ посвящён абстрактной виртуальной машине, он не описывает конкретную реализацию виртуальной машины.
Для корректной реализации виртуальной машины Java, разработчику необходимо только правильно прочесть <font face=Courier>class</font> файл и правильно выполнить операции, определённые там. Детали имплементации не являются частью спецификации виртуальной машины Java, и приведение их неоправданно ограничило бы свободу разработчика. Например, распределение памяти во время работы программы, алгоритм сборщика мусора и внутренняя оптимизация инструкций виртуальной машины Java (например, перевод их в машинный код) оставлены на усмотрение разработчика. 

Все ссылки относительно кодовой таблицы Unicode в этом документе приведены в соответствии со стандартом Unicode версии 6.0.0 доступной по адресу http://www.unicode.org/

<br><br><br><br>
=== Формат <font face=Courier>class</font> файла ===

Скомпилированный для выполнения виртуальной машиной Java код, представляет собой набор данных двоичного формата независимого от операционной системы и аппаратного обеспечения, обычно (но не всегда) хранимый в файле, известном как <font face=Courier>class</font> файл. Формат <font face=Courier>class</font> файла точно определяет представление класса или интерфейса, включая такие особенности как порядок байтов при работе с двоичными данными в платформенно зависимом файле.

В главе 4, «Формат class файла» приведено подробное описание формата.

<br><br><br><br>
=== Типы данных ===

Так же как и язык программирования Java виртуальная машина  Java оперирует двумя разновидностями типов данных: примитивные типы и ссылочные типы. Соответственно существует две разновидности значений, которые могут храниться в переменных, быть переданы как аргументы, возвращены методами и использованными в операторах: примитивные значения и ссылочные значения.

Виртуальная машина Java полагает, что почти все проверки соответствия типов будут выполнены до запуска кода (обычно компилятором) и поэтому такую проверку типов не делает. Нет необходимости помечать значения примитивных типов или как-нибудь иначе наблюдать за ними во время выполнения программы, также нет необходимости отличать примитивные типы от ссылочных типов. Вместо этого,  виртуальная машина Java, содержит наборы инструкций предназначенных для выполнения операций со строго определёнными типами данных. Например, следующие команды ''iadd'', ''ladd'', ''fadd'', и  ''dadd'' представляют собой весь спектр команд для сложения двух числовых значений и получения одного результата, однако каждая предназначена для операндов строго определённого типа: <font face=Courier>int</font>, <font face=Courier>long</font>, <font face=Courier>float</font>, и <font face=Courier>double</font>  соответственно. Более подробно описание поддерживаемых типов изложено в § 2.11.1.

Виртуальная машина Java содержит явную поддержку объектов. Объектом мы называем динамически создаваемый экземпляр класса или массив. Ссылка на объект представлена в виртуальной машине Java типом <font face=Courier>reference</font>. Значения типа <font face=Courier>reference</font> могут быть рассмотрены как указатели на объекты. На один и тот же объкт может существовать множество ссылок. Передача объектов, операции над объектами, проверка объектов происходит всегда посредством типа <font face=Courier>reference</font>.

<br><br><br><br>
=== Примитивные типы и значения ===

Виртуальная машина Java поддерживает следующие примитивные типы: числовые типы, <font face=Courier>boolean</font> тип (см. § 2.3.4) и <font face=Courier>returnAddress</font> тип (см. § 2.3.3).
Числовые типы содержат в себе целые типы (см. § 2.3.1) и типы с плавающей точкой (см. § 2.3.2)
Целые типы:

* <font face=Courier>byte</font>, содержит 8-битовые знаковые целые. Значение по умолчанию - ноль. 
* <font face=Courier>short</font>, содержит 16-битовые знаковые целые. Значение по умолчанию - ноль.
* <font face=Courier>int</font>, содержит 32-битовые знаковые целые. Значение по умолчанию - ноль.
* <font face=Courier>long</font>, содержит 64-битовые знаковые целые. Значение по умолчанию - ноль.
* <font face=Courier>char</font>, содержит 16-битовые беззнаковые целые, представляющие собой кодовые точки таблицы символов Unicode в базовой странице UTF-16. Значение по умолчанию - нулевая кодовая точка ('\u0000')

Типы с плавающей точкой:

* <font face=Courier>float</font>, содержит числа с плавающей точкой одинарной точности. Значение по умолчанию - положительный ноль.
* <font face=Courier>double</font>, содержит числа с плавающей точкой двойной точности. Значение по умолчанию - положительный ноль.

Значение <font face=Courier>boolean</font> типа может быть <font face=Courier>true</font> или <font face=Courier>false</font>, значение по умолчанию <font face=Courier>false</font>.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. В первой редакции спецификации виртуальной машины Java тип данных <font face=Courier>boolean</font> не рассматривался как машинный тип. Однако <font face=Courier>boolean</font>  значения частично поддерживались виртуальной машиной. Во второй редакции эта неясность была устранена, и тип данных <font face=Courier>boolean</font> стал машинным типом.</span>

<span style="font-size:88%">Тип данных <font face=Courier>returnAddress</font> представляет собой указатель на код инструкции виртуальной машины. Из всех примитивных типов только <font face=Courier>returnAddress</font>  не ассоциируется с типом данных из языка Java.</span>
|}
<br>

<br><br><br><br>
==== Целочисленные типы и их значения ====

Существуют следующие диапазоны для целочисленных значений:

* для типа <font face=Courier>byte</font> от -128 до 127 (-2<sup>7</sup> до 2<sup>7</sup> - 1) включительно;
* для типа <font face=Courier>short</font> от -32768 до 32767 (-2<sup>15</sup> до 2<sup>15</sup> - 1) включительно;
* для типа <font face=Courier>int</font> от  -2147483648 до 2147483647 (-2<sup>31</sup> до 2<sup>31</sup> - 1) включительно;
* для типа <font face=Courier>long</font> от  -9223372036854775808 до 9223372036854775807 (-2<sup>63</sup> до 2<sup>63</sup> - 1) включительно;
* для типа <font face=Courier>char</font> от 0 до 65535 включительно;

<br><br><br><br>
==== Типы данных с плавающей точкой, множества значений и значения ====

Типами данных с плавающей точкой являются типы <font face=Courier>float</font> и <font face=Courier>double</font> соответственно 32-х битые значения одинарной точности и 64-х битные значения двойной точности. Формат чисел и операции над ними соответствуют спецификации ''IEEE Standard for Binary Floating-Point Arithmetic'' (ANSI/IEEE Std. 754-1985, New York).

Стандарт IEEE 754 включает в себя не только положительные и отрицательные значения мантиссы, но также и положительные и отрицательные нули, положительные и отрицательные ''бесконечности'', и специальное не числовое значение NaN (Not-a-Number – ''прим. перев.''). NaN используется в качестве результата некоторых неверных операций, таких как деление нуля на нуль.

Каждая реализация виртуальной машины Java должна поддерживать два стандартных набора значений, называемых ''набор значений одинарной точности''  и  ''набор значений двойной точности''. В дополнение к этому виртуальная машина Java может поддерживать ''набор значений одинарной точности с расширенной экспонентой'' и ''набор значений двойной точности с расширенной экспонентой''. При определённых условиях наборы значений с расширенной экспонентой могут быть использованы для типов <font face=Courier>float</font> и <font face=Courier>double</font>.

Конечное не нулевое значение любого из типов данных с плавающей точкой может быть представлено в виде ''s'' ⋅ ''m'' ⋅2<sup>(''e'' – ''N'' + 1)</sup>, где ''s'' равно -1 либо 1, ''m'' – положительное целое меньше чем 2''N'', ''e'' – целое число в пределах ''E<sub>min</sub>'' = -(2<sup>''K''-1</sup>-2) и  ''E<sub>max</sub>'' = 2<sup>''K''-1</sup>-1 включительно, ''N'' и ''K'' – параметры, зависящие от набора значений. Одно и то же числовое значение можно представить несколькими способами. Например, предположим, что ''v'' – значение из набора, представимого в указанной выше форме при определённых  ''s'',  ''m'' и ''e''; тогда, если ''m''  - чётно и ''e'' – меньше чем 2<sup>''K''-1</sup>, то чтобы получить новое представление значения ''v'', можно ''m'' разделить на два, одновременно увеличив ''e'' на единицу. Представление ''s'' ⋅ ''m'' ⋅2<sup>(''e'' – ''N'' + 1)</sup> значения ''v'' называется нормализованным, если ''m''  ≥ 2<sup>''N''-1</sup>; в противном случае говорят, что представление денормализованное. Если значение из множества значений не может быть представлено так, чтобы было справедливо неравенство ''m''  ≥ 2<sup>''N''-1</sup>,  то такое значение называют денормализованным значением, поскольку оно не имеет нормализованного представления. 

В таблице 2.1 приведены ограничения для параметров ''N'' и ''K'' (а также производных параметров ''E<sub>min</sub>'' и ''E<sub>max</sub>'') для двух обязательных и двух не обязательных наборов значений чисел с плавающей точкой.

'''Таблица 2.1 – Параметры для множества чисел с плавающей точкой'''
{| border="1" style="border-collapse:collapse"
!Параметр
!Одинарная точность
!Одинарная точность с расширенной экспонентой
!Двойная точность
!Двойная точность с расширенной экспонентой 
|-
|''N''
|24
|24
|53
|53
|-
|''K''
|8
|≥ 11
|11
|≥ 15
|-
|''E<sub>min</sub>''
| +127
| ≥ + 1023
| + 1023
| ≥ + 16383
|-
|''E<sub>max</sub>''
| -126
| ≤ - 1022
| -1022
| ≤ -16383
|}


Значение константы ''K''  зависит от реализации виртуальной машины там, где наборы значений с расширенной экспонентой вообще поддерживаются (в любом случае ''K'' принадлежит пределам, указанным в таблице); в свою очередь константы ''E<sub>min</sub>'' и ''E<sub>max</sub>'' определяются в зависимости от значения ''K''. 

Каждый из четырёх наборов значений содержит не только конечные ненулевые значения, описанные выше, но также пять дополнительных значений: положительный ноль, отрицательный ноль, положительная бесконечность, отрицательная бесконечность, и не-число (NaN).

Обратите внимание, что ограничения в таблице 2.1 разработаны таким образом, что каждый элемент множества значений одинарной точности также принадлежит множеству значений одинарной точности с расширенной экспонентой, множеству значений с двойной точностью и множеству значений с двойной точностью с расширенной экспонентой. Каждый набор значений с расширенной экспонентой имеет более широкие пределы значений экспоненты по сравнению со стандартным набором, но точность чисел при этом одинаковая.
 
Элементы множества значений чисел с плавающей точкой одинарной точности соответствует значениям, определённым в стандарте IEEE 754, за исключением того, что в этом множестве только одно значение есть не-число NaN (стандарт IEEE 754 предусматривает 2<sup>24</sup>-2 различных не-чисел NaN). Элементы множества значений чисел с плавающей точкой двойной точности соответствует значениям, определённым в стандарте IEEE 754, за исключением того, что в этом множестве только одно значение есть не-число NaN (стандарт IEEE 754 предусматривает 2<sup>53</sup>-2 различных не-чисел NaN). Однако, обратите внимание, что элементы множества значений чисел с плавающей точкой с расширенной экспонентой с одинарной и двойной точностью  ''не соответствуют'' значениям представленным в стандарте IEEE 754 расширенным форматом одинарной точности и расширенным форматом двойной точности соответственно. Данная спецификация не регламентирует внутренне представление чисел с плавающей точкой; единственное место, где должен быть соблюдён формат чисел с плавающей точкой – это формат <font face=Courier>class</font> файла. 

Набор значений одинарной точности, набор значений двойной точности, набор значений одинарной точности с расширенной экспонентой и набор значений двойной точности с расширенной экспонентой не являются типами данных. В реализации виртуальной машины Java всегда допустимо использовать набор значений одинарной точности для представления значения типа <font face=Courier>float</font>; однако, в определённом контексте также допустимо использовать набор значений одинарной точности с расширенной экспонентой.  Аналогично всегда допустимо использовать набор значений двойной точности для  представления значения типа <font face=Courier>double</font>; однако, в определённом контексте также допустимо использовать набор значений двойной точности с расширенной экспонентой.

Все значения (кроме не-чисел NaN) множества чисел с плавающей точкой ''упорядочены''. Если числа упорядочить по возрастанию, то они образуют такую последовательность: отрицательная бесконечность, отрицательные конечные значения, отрицательный ноль, положительный ноль, положительные значения и положительная бесконечность.

Сравнивая положительный и отрицательный ноль, мы получим верное равенство, однако существуют операции, в которых их можно отличить; например, деля <font face=Courier>1.0</font> на <font face=Courier>0.0</font>, мы получим положительную бесконечность, но деля <font face=Courier>1.0</font> на <font face=Courier>-0.0</font> мы получим отрицательную бесконечность. 

Не-числа NaN  ''не упорядочены'', так что сравнение и проверка на равенство вернёт ''ложь'', если хотя бы один из операндов не-число NaN. В частности проверка на равенство значения самому себе вернёт ''ложь'' тогда и только тогда, кода операнд не-число NaN. Проверка на неравенство вернёт ''истину'', когда хотя бы из операндов не-число NaN.

<br><br><br><br>
==== Тип <font face=Courier>returnAddress</font> и его значения ====

Тип <font face=Courier>returnAddress</font> используется виртуальной машиной Java в инструкциях ''jsr'',  ''ret'',  ''jsr_w''. Значения типа <font face=Courier>returnAddress</font> представляют собой указатель на инструкции (адрес инструкции) в виртуальной машине Java. В отличие от примитивных типов тип <font face=Courier>returnAddress</font> не имеет соответствия в языке программирования Java и его значения не могут быть изменены непосредственно в программном коде.

<br><br><br><br>
==== Тип <font face=Courier>boolean</font> ====

Не смотря на то, что виртуальная машина Java поддерживает тип данных <font face=Courier>boolean</font>, поддержка этого типа весьма ограничена. Нет никаких инструкций виртуальной машины Java непосредственно относящихся к работе со значениями типа <font face=Courier>boolean</font>. Вместо этого все выражения, содержащие тип данных <font face=Courier>boolean</font>, сводятся к эквивалентным операциям с типом данных <font face=Courier>int</font>.

Тем не менее, виртуальная машина Java поддерживает хранения массивов с булевским типом данных. Операция ''newarray'' позволяет создавать массивы с булевым типом элементов. Доступ и модификация таких массивов осуществляется инструкциями, предназначенными для работы с типом данных <font face=Courier>byte</font>, а именно: ''baload'' и ''bastore''.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. В реализации виртуальной машины Java компании Oracle, булевы значения массивов кодируются массивом значений с типом <font face=Courier>byte</font>, 8 бит на один элемент массива типа <font face=Courier>boolean</font>.</span>
|}
<br>
В виртуальной машине Java используется значение 1 для кодирования логического <font face=Courier>true</font> и 0 для <font face=Courier>false</font>. Везде, где компилятор преобразовывает булевы типы в тип <font face=Courier>int</font>, он придерживается указанного выше соглашения.

<br><br><br><br>
=== Ссылочные типы и их значения ===

Существуют три разновидности ссылочных (<font face=Courier>reference</font>) типов: тип класса, тип массива и тип интерфейса. Значения этих типов представляют собой ссылки на экземпляр класса, ссылки на массив и ссылки на имплементацию интерфейса соответственно.  

Тип массива представляет собой  ''составной тип''  единичной размерности (длина которого не определена типом). Каждый элемент составного типа сам по себе может также быть массивом. Последовательно рассматривая иерархию составных типов в глубину, (тип, из которого состоит составной тип, из которого состоит составной тип и т.д.) мы придём к типу, который не является массивом; он называется ''элементарным типом'' типа массив. Элементарный тип всегда либо примитивный тип, либо тип класса, либо тип интерфейса.

Тип <font face=Courier>reference</font> может принимать специальное нулевое значение, так называемая ссылка на не существующий объект, которое обозначается как <font face=Courier>null</font>. Значение <font face=Courier>null</font> изначально не принадлежит ни к одному из ссылочных типов и может быть преобразовано к любому.

Спецификация виртуальной машины Java допускает использование произвольной константы для кодирования значения <font face=Courier>null</font>.

<br><br><br><br>
=== Области данных времени выполнения ===

Во время выполнения программы виртуальная машина Java использует разные области для хранения данных. Некоторые из этих областей хранения данных создаются при запуске виртуальной машины Java и освобождаются при завершении работы виртуальной машины. Другие области хранения данных принадлежат потоку. Связанные с потоком области данных создаются при создании потока и освобождаются при завершении работы потока.

<br><br><br><br>
==== Регистр <font face=Courier>pc</font> ====

Виртуальная машина Java может поддерживать множество потоков, выполняющихся одновременно. Каждый поток виртуальной машины Java имеет свой регистр <font face=Courier>pc</font> (program counter (англ.) – программный счётчик. – ''прим. перев.''). В каждый момент времени каждый поток виртуальной машины исполняет код только одного метода, который называется текущим методом для данного потока. Если метод платформенно независимый (т.е. в объявлении метода не использовано ключевое слово <font face=Courier>native</font>) регистр <font face=Courier>pc</font> содержит адрес выполняющейся в данный момент инструкции виртуальной машины Java. Если метод платформенно зависимый (<font face=Courier>native</font> метод) значение регистра <font face=Courier>pc</font> не определено. Разрядность регистра <font face=Courier>pc</font> достаточная, чтобы хранить значения типа <font face=Courier>returnAddress</font>, а также значения платформенно зависимого адреса инструкций.

<br><br><br><br>
==== Стек виртуальной машины Java ====

Каждый поток виртуальной машины имеет свой собственный ''стек виртуальной машины Java'', создаваемый одновременно с потоком. Стек виртуальной машины хранит фреймы. Стек виртуальной машины Java аналогичен стеку в традиционных языках программирования: он хранит локальные переменные и промежуточные результаты и играет свою роль при вызове методов и при возврате управления из методов. Поскольку работать напрямую со стеком виртуальной машины Java запрещено (кроме операций push и pop для фреймов), фреймы могут быть также расположены в куче. Участок памяти для стека виртуальной машины Java не обязательно должен быть непрерывным. 
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. В первой редакции данной спецификации стек виртуальной машины Java назывался просто ''стеком Java''.</span>
|}
<br>
Спецификация позволяет реализовать стек виртуальной машины Java фиксированного размера либо динамического размера: расширяемого и сужаемого по мере работы. Если стек виртуальной машины Java фиксированного размера, то размер стека для каждого потока может быть выбран независимо в момент создания стека.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Реализация виртуальной машины Java может позволить разработчику или пользователю управлять тачальным размером стека виртуальной машины, так же как и в случае динамически изменяемого размера, виртуальная машина позволяет задать минимальное и максимальное значение размера стека. </span>
|}
<br>
В следующих случаях виртуальная машина Java формирует исключение при работе со стеком:

* Если вычисления в потоке требуют памяти более чем позволено размером стека, виртуальная машина Java формирует исключение <font face=Courier>StackOverflowError</font>. 
* Если стек виртуальной машины Java допускает динамическое увеличение размера и попытка такого увеличения была выполнена, однако вследствие нехватки памяти не завершена успешно либо не достаточно памяти при инициализации стека при создании потока, то виртуальная машина Java формирует исключение <font face=Courier>OutOfMemoryError</font>.

<br><br><br><br>
==== Куча ====

Виртуальная машина Java содержит область памяти, называемую ''кучей'', которая находится в пользовании всех потоков виртуальной машины. Куча – это область памяти времени выполнения, содержащая массивы и экземпляры всех классов.

Куча создаётся при запуске виртуальной машины Java. Удаление неиспользуемых объектов в куче производится системой автоматического управления памятью (известной как ''сборщик мусора''); объекты никогда не удаляются явно. Виртуальная машина Java не предполагает какого-либо одного алгоритма для системы автоматического управления памятью; алгоритм может быть произвольно задан разработчиком виртуальной машины в зависимости от системных требований. Куча может быть фиксированного размера, либо динамически расширяться и сужаться при удалении объектов. Участок памяти для кучи виртуальной машины Java не обязательно должен быть непрерывным.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Реализация виртуальной машины Java  позволяет разработчику или пользователю управлять начальным размером кучи, так же как и в случае динамически изменяемого размера, виртуальная машина позволяет задать минимальное и максимальное значение размера кучи.</span>
|}
<br>
В следующих случаях виртуальная машина Java формирует исключение при работе с кучей:

* Если вычисления требуют памяти более, чем может выделить автоматическая система управления памятью, виртуальная машина Java формирует исключение <font face=Courier>OutOfMemoryError</font>.

<br><br><br><br>
==== Область методов ====

Виртуальная машина Java содержит область памяти, называемую ''областью методов'', которая находится в пользовании всех потоков виртуальной машины. Область методов аналогична хранилищу скомпилированного кода в традиционных языках программирования или области памяти «текстовый сегмент» в процессе операционной системы. Область методов хранит принадлежащие классам структуры, такие как хранилище констант (константный пул), данные полей и методов, код методов и конструктор включая специальные методы, а также код инициализации экземпляров и интерфейсов.  

Область методов создаётся при запуске виртуальной машины. Хотя область методов логически принадлежит куче, в простых реализациях виртуальной машины допустимо не сокращать область методов и не использовать для нее сборщик мусора. Эта спецификация виртуальной машины Java не задаёт однозначного расположения или политики управления памятью для скомпилированного кода. Область методов может быть фиксированного размера, либо динамически расширяться и сужаться при необходимости. Участок памяти для области методов виртуальной машины Java не обязательно должен быть непрерывным.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Реализация виртуальной машины Java может позволить разработчику или пользователю управлять начальным размером области методов, так же как и в случае динамически изменяемого размера, виртуальная машина позволяет задать минимальное и максимальное значение размера области методов.</span>
|}
<br>
В следующих случаях виртуальная машина Java формирует исключение при работе с областью методов:

* Если работа программы требуют памяти более, чем может выделить автоматическая система управления памятью, виртуальная машина Java формирует исключение <font face=Courier>OutOfMemoryError</font>.

<br><br><br><br>
==== Хранилище констант времени выполнения (константный пул) ====

Хранилище констант времени выполнения это связанное с классом или интерфейсом представления времени выполнения  таблицы <font face=Courier>constant_pool</font> файла <font face=Courier>class</font>. Представление содержит несколько разновидностей констант, начиная от числовых литералов, известных на этапе компиляции до ссылок в членах-данных класса и методах, разрешить которые необходимо во время выполнения. Хранилище констант времени выполнения выполняет ту же функцию, что и таблица символов в традиционных языках программирования, хотя хранилище и содержит данные в гораздо более широком диапазоне, чем просто символьная таблица.

Каждое хранилище констант времени выполнения расположено в области методов виртуальной машины Java. Хранилище констант времени выполнения класса или интерфейса создаётся, когда класс или интерфейс создаётся виртуальной машиной Java.

В следующих случаях виртуальная машина Java формирует исключение при работе с хранилище констант времени выполнения:

* Если при создании класса или интерфейса хранилище констант времени выполнения требуют памяти более, чем доступно для виртуальной машины Java, виртуальная машина Java формирует исключение <font face=Courier>OutOfMemoryError</font>.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Более подробную информацию по созданию хранилища констант времени выполнения см. в главе 5.</span>
|}
<br>

<br><br><br><br>
==== Стеки Native методов ====

Реализация виртуальной машины Java позволяет использовать традиционные стеки, коротко называемые "С стеками" (от англ. conventional - традиционный - ''прим. перев.'') для поддержки <font face=Courier>native</font> методов (методов, написанных на языках, отличных от Java). Те реализации виртуальной машины Java, которые не могут загружать <font face=Courier>native</font> методы и таким образом не используют традиционные стеки, не нуждаются также и в поддержке стеков  <font face=Courier>native</font> методов.
 
Эта спецификация позволяет стекам <font face=Courier>native</font> методов быть фиксированного размера, либо динамически расширяться и сужаться при необходимости. Если стеки <font face=Courier>native</font> методов фиксированного размера, то их размер задаётся в момент создания стека и не зависит от размеров других стеков.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Реализация виртуальной машины Java  позволяет разработчику или пользователю управлять начальным размером стеков <font face=Courier>native</font> методов в случае их фиксированного размера так же, как и в случае динамически изменяемого размера, виртуальная машина позволяет задать минимальное и максимальное значение размера стеков <font face=Courier>native</font> методов.</span>
|}
<br>
В следующих случаях виртуальная машина Java формирует исключение при работе со стеками <font face=Courier>native</font> методов:

*Если вычисления в потоке требуют памяти более чем позволено размером стека <font face=Courier>native</font> методов, виртуальная машина Java формирует исключение <font face=Courier>StackOverflowError</font>. 
*Если стек виртуальной машины Java допускает динамическое увеличение размера и попытка такого увеличения была выполнена, однако вследствие нехватки памяти не завершена успешно либо не достаточно памяти при инициализации стека native методов при создании потока, то виртуальная машина Java формирует исключение <font face=Courier>OutOfMemoryError</font>.

<br><br><br><br>
=== Фреймы ===

''Фреймы'' используются как хранения данных и промежуточных результатов  так и для организации динамического связывания, возвращения значений из методов, управления исключениями. 

Новый фрейм создаётся, когда происходит вызов метода. Фрейм уничтожается, когда вызов метода завершён вне зависимости от того было или завершение метода успешным или аварийным (метод выбросил не перехваченное исключение). Фреймы хранятся в стеке потока виртуальной машины Java, создающего эти фреймы. Каждый фрейм содержит свой массив локальных переменных (см. §2.5.2), свой стек операндов (см. §2.6.2), ссылку на хранилище констант времени выполнения (см. §2.5.5) текущего класса текущего метода.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Дополнительно во фрейме может храниться информация специфическая для каждой реализации виртуальной машины, например, отладочная информация.</span>
|}
<br>
Размер массива локальных переменных и стека операндов определяется во время компиляции и хранится вместе с кодом метода, связанного с фреймом. Поэтому размер структур данных, хранящихся во фрейме, зависит только от реализации виртуальной машины Java; память для этих структур выделяется одновременно с вызовом метода.

Только один фрейм активен в каждый момент времени для каждого потока - фрейм, исполняемого в данный момент метода. Такой фрейм называется ''текущим фреймом'', а метод - ''текущим методом''. Класс, которому принадлежит текущий метод, называется ''текущим классом''.
 
Операции над локальными переменными и операнды в стеке обычно ссылаются на текущий фрейм. 
Фрейм перестаёт быть текущим, если связанный с ним метод вызывает другой метод или текущий метод завершает своё выполнение. Когда метод вызывается, то создаётся новый фрейм, который становится текущим при передаче управления вызываемому методу. Когда метод завершает своё выполнение, текущий фрейм передаёт результаты выполнения (если таковые имеются) предыдущему фрейму. После этого текущий фрейм уничтожается, а предыдущий фрейм становится текущим. 

Обратите внимание, что фрейм, созданный потоком, виден только потоку-владельцу и для других потоков не доступен.

<br><br><br><br>
==== Локальные переменные ====

Каждый фрейм содержит массив переменных, известных как ''локальные переменные''. Длина массива локальных переменных каждого фрейма определяется на этапе компиляции; массив хранится в двоичном представлении класса или интерфейса совместно с кодом метода, связанного с фреймом. 

Каждая локальная переменная может содержать значения следующих типов: <font face=Courier>boolean</font>, <font face=Courier>byte</font>, <font face=Courier>char</font>, <font face=Courier>short</font>, <font face=Courier>int</font>, <font face=Courier>float</font>, <font face=Courier>reference</font>, или <font face=Courier>returnAddress</font>. Пара локальных переменных может содержать значение типа <font face=Courier>long</font> или <font face=Courier>double</font>.

Доступ к локальным переменным осуществляется по индексу. Индекс первой локальной переменной равен нулю. Целое число является индексом локальной переменной тогда и только тогда, когда это число находится в пределах от нуля до строго меньше размера массива переменных. 

Переменные типа <font face=Courier>long</font> или  <font face=Courier>double</font> хранятся в двух следующих друг за другом локальных переменных. Получить доступ к такому значению, можно используя индекс младшей переменной. Например, значение типа <font face=Courier>double</font> хранящееся в локальной переменной с индексом ''n'', на самом деле занимает локальные переменные с индексами ''n'' и ''n'' +1; однако значение локальной переменной с индексом ''n'' +1 не может быть загружено отдельно. Оно используется только для хранения. Также не может быть использовано отдельно значения локальной переменной с индексом ''n''.

Виртуальная машина Java не требует, чтобы ''n'' было чётным. Говоря переносно, значения переменных с типами <font face=Courier>long</font> и <font face=Courier>double</font> не обязательно должны начинаться в памяти с адресов, кратных 64-м битам. Разработчик самостоятельно выбирает способ размещения таких значений в двух локальных переменных, зарезервированных для этого.
 
Виртуальная машина Java использует локальные переменные для передачи параметров при вызове метода. При вызове метода принадлежащего классу все параметры передаются последовательно, начиная с локальной переменной с индексом ''0''.  При вызове метода экземпляра локальная переменная ''0'' всегда используется для передачи ссылки на объект, чей метод вызывается в данный момент. (<font face=Courier>this</font>  в языке программирования Java). Остальные параметры передаются в локальные переменные, начиная с переменной ''1''.

<br><br><br><br>
==== Стек операндов ====

Каждый фрейм содержит стек операндов, организованный по принципу «последним пришёл, первым ушёл» (анг. LIFO, last-in-first-out – ''прим. перев.'') Максимальная глубина стека операндов определяется во время компиляции; значение глубины хранится совместно с кодом, связанным с фреймом (см. §4.7.3).
Там где это ясно из контекста, мы иногда будем называть стек операндов текущего фрейма просто стеком операндов.

Сразу после создания фрейма стек операндов советующего фрейма пуст. Виртуальная машина Java предоставляет инструкции загрузки констант или значений из локальных переменных или полей в стек операндов. Другие инструкции виртуальной машины Java получают операнды из стека, обрабатывают их, и записывают результат обратно в стек операндов. Стек операндов также используется для подготовки параметров для передачи в методы и получения результатов выполнения метода.

Например, инструкция ''iadd'' складывает два значения типа <font face=Courier>int</font>. Для ее работы необходимо, чтобы два значения типа <font face=Courier>int</font>, записанные предыдущими инструкциями,   были на вершине стека операндов. Два значения типа <font face=Courier>int</font> считываются из стека операндов. Они складываются, и их сумма записывается обратно в стек операндов. Промежуточные вычисления могут храниться в стеке операндов и использоваться в последующих вычислений. 

Каждый элемент стека операндов может хранить все значения из списка поддерживаемых виртуальной машиной Java типов, включая <font face=Courier>long</font> и <font face=Courier>double</font>. 

Все операции со значениями стека операндов нужно проводить в соответствии с их типом. Невозможно, к примеру, поместить два значения типа <font face=Courier>int</font> работать с ними как с типом <font face=Courier>long</font> или поместить два значения типа <font face=Courier>float</font> и сложить их инструкцией ''iadd''. Небольшое количество инструкций виртуальной машины Java (таких как ''dup'' или ''swap'') работают с данными времени выполнения как с «сырыми» значениями без учета их типов; эти инструкции разработаны так, что они не могут повредить или модифицировать значения. Эти ограничения на манипуляции со стеком операндов вызваны проверками в <font face=Courier>class</font> файле.  

В любой момент времени стек операндов имеет определенною глубину, причем значения с типами <font face=Courier>long</font> и <font face=Courier>double</font> занимают две единицы памяти стека, остальные типы занимают по одной единице памяти стека.

<br><br><br><br>
==== Динамическое связывание ====

Чтобы реализовать ''динамическое связывание'' кода метода,  каждый фрейм (см. §2.6)  содержит ссылку на тип текущего метода в хранилище констант времени выполнения (см. §2.5.5). Код в <font face=Courier>class</font> файле метода ссылается на те методы, которые необходимо будет вызвать и те переменные, доступ к которым нужно получить по символьным ссылкам. Динамическое связывание преобразует ссылки на методы в виде символов исходного кода на Java в реальные ссылки, при необходимости загружая классы для тех ссылок, которые еще не определены; переменные исходного кода преобразуются в соответствующие ссылки  в структурах данных, связанных с этими переменными. 

Позднее связывание методов и переменных позволяет писать код более устойчивый к изменениям.

<br><br><br><br>
==== Нормальное завершение вызова метода ====


Вызов метода ''завершается нормально'', если вызов не приводит к возникновению исключения (см. §2.10), причём, неважно будет ли исключение вызвано непосредственно из виртуальной машины Java либо явным вызовом оператора <font face=Courier>throw</font>. Если вызов метода завершается нормально, в вызывающий метод может быть передано значение. Это происходит, когда вызываемый метод выполняет одну из инструкций возврата (см. §2.11.8); какую именно – зависит от типа возвращаемого значения (если вообще таковое имеется).

Текущий фрейм (см. §2.6) в этом случае используется для восстановления вызывающего метода, включая состояние локальных переменных и стека операндов; программный счётчик вызывающего метода соответственно увеличивается, чтобы избежать повторного вызова метода, который только что был вызван. Управление успешно передается в код фрейма вызывающего метода; результат выполнения (если таковой имеется) записывается в стек операндов вызывающего метода.

<br><br><br><br>
==== Аварийное завершение вызова метода ====

Вызов метода ''завершается аварийно'', если выполнение инструкций виртуальной машины Java находящихся в теле метода приводит к тому, что виртуальная машина формирует исключение и это исключение не перехвачено в методе. Выполнение любой инструкции ''athrow'' (см. ''athrow'') также приводит к явному формированию исключения, и если исключение не перехвачено текущим методом, то метод завершается аварийно. Метод, завершившийся аварийно никогда не возвращает значения в вызывающий метод.

<br><br><br><br>
=== Представление объектов ===

Виртуальная машина Java не обязывает разработчика к какой-либо определённой внутренней структуре объектов. 
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. В некоторых реализациях виртуальной машины Java выполненных компанией Oracle, ссылка на класс представляет собой ссылку на ''обработчик'', который сам по себе состоит из пары ссылок: одна указывает на таблицу методов объекта, содержащую также ссылку на объект <font face=Courier>Class</font> представляющий тип объекта, а другая на область данных в куче, содержащую члены-данные объекта. </span>
|}
<br>

<br><br><br><br>
=== Арифметика чисел с плавающей точкой ===

Виртуальная машина Java реализует множество правил арифметики чисел с плавающей точкой, которое является подмножеством правил стандарта ''IEEE Standard for Binary Floating-Point Arithmetic'' (ANSI/IEEE Std. 754-1985, New York)

<br><br><br><br>
==== Арифметика чисел с плавающей точкой виртуальной машины Java и стандарт IEEE 754 ====

Ключевыми отличиями Арифметики чисел с плавающей точкой виртуальной машины Java и стандарта IEEE 754 являются:

* Операции с плавающей точкой виртуальной машины Java не формируют исключений, захватов или других сигналов определённых стандартом IEEE 754 сообщающих об исключительной ситуации: неверная операция, деление на ноль, переполнение, исчезновение значащих разрядов, потеря точности. Виртуальная машина Java не сигнализирует специальным образом о том, что в ходе вычислений получено NaN значение. 
* Виртуальная машина Java не использует механизм сигнализирования при сравнении чисел с плавающей точкой.
* Операции округления в виртуальной машине Java  всегда используют режим округления к ближайшему числу стандарта IEEE 754. Неточные результаты вычислений округляются к ближайшему представимому значению, путём сложения старшего бита остатка с младшим значащим битом неокругленного целого. Это стандартный режим округления IEEE 754. Но инструкции виртуальной машины Java преобразующие типы с плавающей точкой к целочисленным типам всегда округляют в направлении нуля. Виртуальная машина Java не предоставляет никаких средств управления режимом округления чисел с плавающей точкой.
* Виртуальная машина Java не поддерживает ни расширенного формата одинарной точности, ни расширенного формата двойной точности определяемых стандартом IEEE 754 за исключением того,  что насколько это допустимо наборы значений двойной точности и двойной точности с расширенной экспонентой могут рассматриваться как реализация расширенного формата одинарной точности. Элементы множества значений чисел с плавающей точкой с расширенной экспонентой с одинарной и двойной точностью  ''не соответствуют'' значениям, представленным в стандарте IEEE 754 расширенным форматом одинарной точности и расширенным форматом двойной точности соответственно: стандарт IEEE 754 требует не только увеличения пределов значения экспоненты, но увеличения точности (увеличения числа значащих битов мантиссы – ''прим. перев.'')

<br><br><br><br>
==== Режимы работы с плавающей точкой ====

Для  каждого метода каждого класса определён ''режим работы с плавающей точкой'', который может быть ''FP-strict'' или  ''не FP-strict''.  Режим работы с плавающей точкой задается установкой флага <font face=Courier>ACC_STRICT</font> набора <font face=Courier>access_flags</font> структуры <font face=Courier>method_info</font> (см §4.6) определяющей метод. Метод, для которого это флаг установлен, использует режим FP-strict; иначе использует режим не FP-strict.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Обратите внимание, что эта трактовка значений флага <font face=Courier>ACC_STRICT</font> подразумевает, что методы скомпилированные в JDK release 1.1 или ранее фактически не FP-strict. </span>
|}
<br>
Мы ссылаемся на стек операндов, считая, что режим работы с плавающей точкой  уже задан;  стек операндов  содержится во фрейме, созданном при вызове метода, а структура метода (<font face=Courier>method_info</font> – ''прим. перев.'') содержит определение режима. Точно также мы говорим об инструкции виртуальной машины Java, имеющей определённый режим работы с плавающей точкой, поскольку инструкция принадлежит методу, а для метода задан такой режим.

Если числа с плавающей точкой с расширенной экспонентой с одинарной точностью поддерживаются (см. §2.3.2), значения типа <font face=Courier>float</font> в стеке операндов, не являющиеся FP-strict могут превосходить значения с режимом FP-strict, кроме случаев запрещённых правилами преобразования множества значений (см. §2.8.3). Если числа с плавающей точкой с расширенной экспонентой с двойной точностью поддерживаются (см. §2.3.2), значения типа <font face=Courier>double</font> в стеке операндов, не являющиеся FP-strict могут превосходить значения с режимом FP-strict, кроме случаев запрещённых правилами преобразования множества значений.

<br><br><br><br>
==== Правила преобразования множества значений ====

Для реализации виртуальной машины Java, которая поддерживает числа с расширенной экспонентой, допустимо или необходимо, в зависимости от обстоятельств, преобразовывать значения чисел с расширенной экспонентой к значениям чисел со стандартной экспонентой. Такое ''преобразование множества значений'' не является преобразованием типов, но лишь преобразование значений в пределах одного и того же типа.

Когда необходимо выполнить преобразование множеств значений, допустимо выполнять следующие операции над значениями:

* Если значение типа <font face=Courier>float</font> и не принадлежит стандартному набору значений, оно округляется до ближайшего из элементов стандартного набора. 
* Если значение типа <font face=Courier>double</font> и не принадлежит стандартному набору значений, оно округляется до ближайшего из элементов стандартного набора.

В дополнение к выше сказанному при необходимости выполнить преобразование множеств значений, выполняются следующие операции:

* Предположим выполнение инструкции виртуальной машины Java, являющейся не FP-strict, привело к тому, что значения типа <font face=Courier>float</font> помещено в стек операндов, который является FP-strict либо как параметр метода, либо как локальная переменная, поле класса или элементе массива.  Если значение  не принадлежит стандартному набору значений, оно округляется до ближайшего из элементов стандартного набора.
* Предположим выполнение инструкции виртуальной машины Java, являющейся не FP-strict, привело к тому, что значения типа <font face=Courier>double</font> помещено в стек операндов, который является FP-strict либо как параметр метода, либо как локальная переменная, поле класса или элементе массива.  Если значение  не принадлежит стандартному набору значений, оно округляется до ближайшего из элементов стандартного набора.

Не все значения с расширенной экспонентой могут быть точно преобразованы стандартные значения. Если значение, которое нужно преобразовать, слишком велико, чтобы быть представленным точно (его экспонента больше чем может храниться в стандартном наборе), то оно преобразовывается в бесконечность (положительную или отрицательную) соответствующего типа. Если значение, которое нужно преобразовать, слишком мало, чтобы быть представленным точно (его экспонента меньше чем может храниться в стандартном наборе), то оно округляется к ближайшему допустимому денормализованному значению или нулю того же знака.

Правила преобразования множества значений сохраняют бесконечности и не-числа (NaN) и не могут изменить знак преобразуемого значения. Правила преобразования множества значений относятся к значениям, только принадлежащим типам с плавающей точкой.

<br><br><br><br>
=== Специальные методы ===

На уровне виртуальной машины Java, каждый конструктор, написанный на языке программирования Java, представляет собой ''инициализирующий метод экземпляра'', у которого есть специальное имя <font face=Courier><init></font>. Это имя формирует компилятор.  Поскольку имя <font face=Courier><init></font> не является действительным идентификатором, его невозможно непосредственно использовать в языке программирования Java. Инициализирующий метод экземпляра может быть вызван только виртуальной машиной Java с помощью инструкции ''invokespecial'', и этот метод может быть вызван только для уже инициализированного экземпляра класса. Инициализирующий метод экземпляра имеет те же права доступа, что и конструктор, от которого он был произведён.

Класс или интерфейс имеет как минимум один  ''инициализирующий метод класса или экземпляра'' соответственно; инициализация класса или интерфейса происходит путём вызова инициализирующего метода. Такой метод имеет специальное имя <font face=Courier><clinit></font>, не имеет аргументов и является <font face=Courier>void</font> (см. §4.3.3). 
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Если в <font face=Courier>class</font> файле есть несколько методов с именем <font face=Courier><clinit></font>, то действителен только один – другие не имеют смысла. Их нельзя вызвать ни одной из инструкций виртуальной машины Java и сама виртуальная машина Java их никогда не вызывает.</span>
|}
<br>
В <font face=Courier>class</font> файле с версией 51.0 или выше метода должен иметь флаг <font face=Courier>ACC_STATIC</font> с установленным значением, для того чтобы метод был инициализирующим методом класса или интерфейса.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Это требование введено в Java SE 7. В <font face=Courier>class</font> файле, чья версия 50.0 или ниже метод с именем <font face=Courier><clinit></font>, имеющий тип <font face=Courier>void</font> и не имеющий аргументов, рассматривается как инициализирующий метод класса или интерфейса вне зависимости от установленного флага <font face=Courier>ACC_STATIC</font>. </span>
|}
<br>
Имя <font face=Courier><clinit></font> формирует компилятор.  Поскольку имя <font face=Courier><init></font> не является действительным идентификатором, его невозможно непосредственно использовать в языке программирования Java. Инициализирующий метод класса или интерфейса неявным образом вызывается виртуальной машиной Java; его невозможно вызвать непосредственно по инструкции виртуальной машины Java, но он неявно вызывается в процессе инициализации класса.

Метод считается ''сигнатурно полиморфным'', тогда и только тогда, когда выполнены следующие условия:

* Метод объявлен в классе <font face=Courier>java.lang.invoke.MethodHandle</font>.
* Метод имеет только один формальный параметр типа <font face=Courier>Object[]</font>.
* Метод возвращает значения типа <font face=Courier>Object</font>.
* Для метода установлены флаги <font face=Courier>ACC_VARARGS</font> и <font face=Courier>ACC_NATIVE</font>. 

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. В Java SE 7 сигнатурно полиморфными методами являются методы <font face=Courier>invoke</font> и <font face=Courier>invokeExact</font> класса <font face=Courier>java.lang.invoke.MethodHandle</font>. </span>
|}
<br>
Виртуальная машина Java по-особому выполняет сигнатурно полиморфные методы с помощью инструкции ''invokevirtual'' для того чтобы обеспечить вызов ''обработчика методов''. Обработчик методов – это типизированная, непосредственно исполняемая ссылка на связанный метод, конструктор, поле или на подобную низкоуровневую операцию (см. §5.4.3.5); опционально обработчик методов позволяет преобразовывать входные параметры или возвращаемые значения. Эти преобразования достаточно общие и включают такие шаблоны как преобразование типов, вставка, удаление и замещение. Более подробную информацию см. в документации пакета <font face=Courier>java.lang.invoke</font>.

<br><br><br><br>
=== Исключения ===

Исключения в виртуальной машине Java представлены экземплярами класса <font face=Courier>Throwable</font> или одного из его наследников. Выброс исключения в программном коде приводит к немедленной нелокальной передаче управления из точки, в которой исключение было сформировано. 

Большинство исключений синхронные, т.е. выбрасываются сразу после определённой операции в потоке выполнения. В отличие от асинхронных исключений, которые могут возникнуть в любой момент времени в ходе выполнения программы. Виртуальная машина Java выбрасывает исключение в трех случаях:

* Выполнена инструкция ''athrow''.
* В ходе выполнения инструкций виртуальная машина Java обнаружила условия, приводящие к аварийной ситуации. Этот тип исключений не возникает в произвольной точке кода, а формируется сразу после обнаружения аварийной ситуации и имеет строгую привязку к инструкциям, которые либо:
** Определяют исключение в качестве возможного результата выполнения:
*** Когда инструкция представляет собой операцию, нарушающую семантику языка программирования, например выход индекса за границы массива.
*** Когда возникает ошибка при загрузке или связывании частей программы.
** Приводят к нарушению ограничений, накладываемых на ресурсы, например, использование слишком большого количества памяти.
* Возникло асинхронное исключение по следующим причинам:
** Вызван метод <font face=Courier>stop</font> класса <font face=Courier>Thread</font> или <font face=Courier>ThreadGroup</font>.
** Возникла внутренняя ошибка, связанная с реализацией виртуальной машины Java. 

Метод <font face=Courier>stop</font> может быть вызван одним потоком, чтобы остановить другой поток или все потоки в определённой группе потоков. Эти исключения асинхронны, поскольку могут произойти в любой момент выполнения потока или потоков. Внутренняя ошибка Java машины также считается асинхронной (см. §6.3).

Виртуальная машина Java позволяет выполнять небольшое число дополнительных операций, перед тем как асинхронное исключение будет выброшено. Задержка, вызванная выполнением дополнительных операций, оправдана тем, что  оптимизированный код может обнаружить и выбросить эти исключения в точках, где целесообразно обработать их в соответствии с правилами семантики языка программирования Java. 
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Простая реализация виртуальной машины последовательно проверяет условия для всех асинхронных исключений для каждой инструкции передачи управления. Поскольку программа имеет конечный размер, это определяет верхнюю границу интервала времени общей задержки, вызванной проверкой возникновения асинхронных исключений. Поскольку асинхронные исключения не возникают между инструкциями передачи управления, для генераторов кода допустима гибкость в изменении порядка операций между инструкциями передачи управления для улучшения производительности кода. Для более подробного ознакомления с вопросом рекомендуем статью Марка Фили ''Polling Efficiently on Stock Hardware by Marc Feeley,  Proc. 1993 Conference on Functional Programming and Computer Architecture'', Copenhagen, Denmark, pp. 179–187. </span>
|}
<br>
Исключения, выбрасываемые виртуальной машиной Java, сохраняют целостность данных в следующем смысле: когда происходит передача управления вследствие формирования исключения, то результаты выполнения всех инструкций вплоть до точки возникновения исключения доступны виртуальной машине. Инструкции, находящиеся после точки возникновения исключения не выполняются и не влияют на результат вычислений. Если оптимизатор кода неявно вычислил инструкции, которые следуют после точки возникновения исключения, он должен позаботиться о том, чтобы отменить их влияние на текущее состояние программы. 

С каждым методом в виртуальной машине Java может быть связано от нуля и более ''обработчиков исключений''. Обработчик исключения определяет величину смещения в машинном коде, указывая на тот метод, которому принадлежит исключения, описывает тип исключений, которые обработчик может обработать, и определяет положение  первой инструкции кода метода для обработки исключений. Исключение соответствует обработчику исключений, если смещение инструкции, которая вызвала исключение, находится в пределах смещений обработчика исключений и тип исключения является классом или наследником класса исключения, которое может обрабатывать обработчик. Когда выбрасывается исключение, то виртуальная машина Java ищет соответствующий обработчик исключения в текущем методе. Если подходящий обработчик найден, то система переходит к выполнению кода, указанного в обработчике исключений.

Если в текущем методе не найдено подходящего обработчика исключений, выполнение текущего метода завершается аварийно (см. §2.6.5). При аварийном завершении работы метода стек операндов, и локальные переменные теряются, текущий фрейм удаляется из стека фреймов, затем текущим фреймом становится фрейм вызывающего метода. После этого исключение выбрасывается повторно, но уже в контексте фрейма вызывающего метода и так далее, по цепи вызовов методов. Если подходящего обработчика исключений так и не было найдено, прежде чем достигнута вершина цепи вызовов методов, то поток, в котором было выброшено исключение прекращает свою работу.  

Порядок, в котором производится поиск обработчиков исключений, имеет значение. Внутри  <font face=Courier>class</font> файла обработчики исключений для каждого метода хранятся в таблице (см. §4.7.3). Во время работы программы, когда выброшено исключение, виртуальная машина Java производит поиск обработчиков исключений в текущем методе в порядке, в котором они записаны в соответствующей таблице в <font face=Courier>class</font> файле, начиная с начала таблицы.  

Обратите внимание, что виртуальная машина Java не накладывает ограничений на порядок следования обработчиков исключений в таблице. Соответствие порядка следования обработчиков исключений семантике языка Java обеспечивается только компилятором (см. §3.12). В случае, если <font face=Courier>class</font> файл генерируется не компилятором, а другими средствами, процедура поиска гарантирует, что все реализации виртуальной машины будут одинаково обрабатывать таблицу обработчиков исключений.

<br><br><br><br>
=== Обзор инструкций ===

Набор инструкций виртуальной машины Java состоит из ''кода операции'', за которым следует ноль или более ''операндов'', аргументы операции или данные, используемые операцией. Большое количество инструкций вообще не имеют операндов и состоят только из кода операции.

Без учёта исключений внутренний цикл интерпретатора виртуальной машины Java работает следующим образом:

 do {
 автоматически вычислить значение регистра pc  и извлечь код операции по адресу pc;
 if (есть операнды у операции?) извлечь операнды;
 выполнить операцию с извлечённым кодом и операндами;
 } while (есть еще операции?);

Количество и размер операндов определяется кодом операции. Если размер операнда превышает один байт, то он хранится в ''обратном порядке'': сначала старший байт, затем младший. Например, беззнаковый 16-ти битный индекс локальной переменной хранится как два беззнаковых байта, ''байт1'' и ''байт2'', так что значение адреса вычисляется следующим образом: (''байт1'' << 8)| ''байт2''.
 
Коды инструкций (байт-код) выровнены побайтово. Есть два исключения из этого правила: инструкции ''lookupswitch'' и  ''tableswitch'', которые дополнительно требуют 4-х байтового выравнивания своих операндов. 
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%"> Примечание. Решение ограничить размер кода операции одним байтом и отказаться от выравнивания данных скомпилированного кода отражает желание сделать код более компактным, возможно за счёт скорости его работы в командах реального процессора. Размер кода операции в один байт также ограничивает количество операций. Отказ от выравнивания большего, чем один байт, означает, что данные размером больше байта конструируются из байтов во время выполнения программы.</span>
|}
<br>

<br><br><br><br>
==== Типы данных и виртуальная машина Java ====

Большинство инструкций виртуальной машины Java содержат в своём названии описание типа данных, с которым они работают. Например, инструкция ''iload'' загружает содержимое локальной переменной, которая должна быть типа <font face=Courier>int</font> в стек операндов. Инструкция ''fload'' делает то же самое для значения типа <font face=Courier>float</font>. Эти две инструкции делают одно и то же (отличие лишь в типах данных), но имеют разные коды операций.

Для большинства типизированных инструкций, её тип можно узнать по букве в мнемоническом обозначении кода операции: ''i'' для операций  над типом <font face=Courier>int</font>, ''l'' для <font face=Courier>long</font>, ''s'' для  <font face=Courier>short</font>, ''b'' для  <font face=Courier>byte</font>,  ''c'' для  <font face=Courier>char</font>,  ''f'' для  <font face=Courier>float</font>,  ''d'' для  <font face=Courier>double</font>, и  ''a'' для  <font face=Courier>reference</font>. Некоторые инструкции, тип которых определяется однозначно из самой инструкции, не имеют буквы указателя типа в своём мнемоническом обозначении. На пример ''arraylength'' всегда  оперирует с массивами и ничем иным. Некоторые инструкции, такие как ''goto'' – безусловная передача управления – вообще не требуют типизированных операндов.

Существующее в виртуальной машине Java ограничение на размер кода операции в один байт существенно влияет на содержимое набора команд. Если каждая типизированная инструкция будет поддерживать все типы данных времени выполнения виртуальной машины Java, то количество инструкций превысит то, которое можно хранить в одном байте. Вместо этого набор инструкций виртуальной машины Java ограничивает число операций для каждого типа. Другими словами набор инструкций был умышленно сделан не ортогональным по отношению к существующим типам. Существует класс инструкций для перевода одних типов в другие используемый для выполнения операций над неподдерживаемыми типами. 

В таблице 2.2 приведены инструкции и типы данных, которые они поддерживают. Конкретную инструкцию с информацию о типе операнда можно получить, заменяя символ ''T''  в шаблоне мнемонического обозначения операции (см.  колонку операционных кодов)  на тип из колонки типов. Например,  существует инструкция ''iload'' загрузки значений типа <font face=Courier>int</font>, но нет аналогичной инструкции для типа <font face=Courier>byte</font>.

Обратите внимание, что для целочисленных типов <font face=Courier>byte</font>, <font face=Courier>char</font> и <font face=Courier>short</font> большинство инструкций в таблице 2.2 отсутствует. А операций с типом <font face=Courier>boolean</font> вообще нет. Компилятор осуществляет загрузку данных с типами <font face=Courier>byte</font> и <font face=Courier>short</font>, используя инструкции виртуальной машины Java, которые расширяют с учетом знака значения указанных типов к типу <font face=Courier>int</font> во время компиляции или выполнения программы. Загрузка литералов с типами <font face=Courier>boolean</font> и <font face=Courier>char</font> выполняется с использованием инструкций виртуальной машины Java, которые расширяют значения указанных типов (предварительно обнулив знак в значении типа <font face=Courier>int</font>, т.н. нулевое расширение – ''прим. перев.'') к типу <font face=Courier>int</font> во время компиляции или выполнения программы. Точно также загрузка значений из массивов с типами <font face=Courier>boolean</font>, <font face=Courier>byte</font>, <font face=Courier>short</font>, и <font face=Courier>char</font> осуществляется посредством знакового или нулевого расширения указанных типов к <font face=Courier>int</font> и последующей работе этим типом. Поэтому большинство операций над значениями с типами <font face=Courier>boolean</font>,  <font face=Courier>byte</font>, <font face=Courier>char</font> и <font face=Courier>short</font> выполняется через преобразование к типу <font face=Courier>int</font> и дальнейшее выполнение соответствующей операции.

'''Таблица 2.2 Поддержка типов в операциях виртуальной машине Java'''
{| border="1" style="border-collapse:collapse"
! Код операции
! byte
! short
! int
! long
! float
! double
! char
! reference
|-
| ''Tipush''
| ''bipush''
| ''sipush''
| 
| 
| 
| 
| 
| 
|-
| ''Tconst''
| 
| 
| ''iconst''
| ''lconst''
| ''fconst''
| ''dconst''
| 
| ''aconst''
|-
| ''Tload''
| 
| 
| ''iload''
| ''lload''
| ''fload''
| ''dload''
| 
| ''aload''
|-
| ''Tstore''
| 
| 
| ''istore''
| ''lstore''
| ''fstore''
| ''dstore''
| 
| ''astore''
|-
| ''Tinc''
| 
| 
| ''iinc''
| 
| 
| 
| 
| 
|-
| ''Taload''
| ''baload''
| ''saload''
| ''iaload''
| ''laload''
| ''faload''
| ''daload''
| ''caload''
| ''aaload''
|-
| ''Tastore''
| ''bastore''
| ''sastore''
| ''iastore''
| ''lastore''
| ''fastore''
| ''dastore''
| ''castore''
| ''aastore''
|-
| ''Tadd''
| 
| 
| ''iadd''
| ''ladd''
| ''fadd''
| ''dadd''
| 
| 
|-
| ''Tsub''
| 
| 
| ''isub''
| ''lsub''
| ''fsub''
| ''dsub''
| 
| 
|-
| ''Tmul''
| 
| 
| ''imul''
| ''lmul''
| ''fmul''
| ''dmul''
| 
| 
|-
| ''Tdiv''
| 
| 
| ''idiv''
| ''ldiv''
| ''fdiv''
| ''ddiv''
| 
| 
|-
| ''Trem''
| 
| 
| ''irem''
| ''lrem''
| ''frem''
| ''drem''
| 
| 
|-
| ''Tneg''
| 
| 
| ''ineg''
| ''lneg''
| ''fneg''
| ''dneg''
| 
| 
|-
| ''Tshl''
| 
| 
| ''ishl''
| ''lshl''
| 
| 
| 
| 
|-
| ''Tshr''
| 
| 
| ''ishr''
| ''lshr''
| 
| 
| 
| 
|-
| ''Tushr''
| 
| 
| ''iushr''
| ''lushr''
| 
| 
| 
| 
|-
| ''Tand''
| 
| 
| ''iand''
| ''land''
| 
| 
| 
| 
|-
| ''Tor''
| 
| 
| ''ior''
| ''lor''
| 
| 
| 
| 
|-
| ''Txor''
| 
| 
| ''ixor''
| ''lxor''
| 
| 
| 
| 
|-
| ''i2T''
| ''i2b''
| ''i2s''
| 
| ''i2l''
| ''i2f''
| ''i2d''
| 
| 
|-
| ''l2T''
| 
| 
| ''l2i''
| 
| ''l2f''
| ''l2d''
| 
| 
|-
| ''f2T''
| 
| 
| ''f2i''
| ''f2l''
| 
| ''f2d''
| 
| 
|-
| ''d2T''
| 
| 
| ''d2i''
| ''d2l''
| ''d2f''
| 
| 
| 
|-
| ''Tcmp''
| 
| 
| 
| ''lcmp''
| 
| 
| 
| 
|-
| ''Tcmpl''
| 
| 
| 
| 
| ''fcmpl''
| ''dcmpl''
| 
| 
|-
| ''Tcmpg''
| 
| 
| 
| 
| ''fcmpg''
| ''dcmpg''
| 
| 
|-
| ''if_TcmpOP''
| 
| 
| ''if_icmpOP''
| 
| 
| 
| 
| ''if_acmpOP''
|-
| ''Treturn''
| 
| 
| ''ireturn''
| ''lreturn''
| ''freturn''
| ''dreturn''
| 
| ''areturn''
|}


Соответствие между действительными типами виртуальной машины Java и типами, используемыми для вычислений, приведено в таблице 2.3.

Определённые инструкции виртуальной машины Java, такие как ''pop'' и  ''swap'' работают со стеком операндов безотносительно к типам операндов; однако такие инструкции ограничены в применении только значениями определённых категорий вычислимых типов, что так же приведено в таблице 2.3.

'''Таблица 2.3 Реальные типы и типы, используемые для вычислений в виртуальной машине Java'''
{| border="1" style="border-collapse:collapse"
! Реальный тип
! Тип для вычислений
! Категория
|-
| <font face=Courier>boolean</font>
| <font face=Courier>int</font>
| категория 1
|-
| <font face=Courier>byte</font>
| <font face=Courier>int</font>
| категория 1
|-
| <font face=Courier>char</font>
| <font face=Courier>int</font>
| категория 1
|-
| <font face=Courier>short</font>
| <font face=Courier>int</font>
| категория 1
|-
| <font face=Courier>int</font>
| <font face=Courier>int</font>
| категория 1
|-
| <font face=Courier>float</font>
| <font face=Courier>float</font>
| категория 1
|-
| <font face=Courier>reference</font>
| <font face=Courier>reference</font>
| категория 1
|-
| <font face=Courier>returnAddress</font>
| <font face=Courier>returnAddress</font>
| категория 1
|-
| <font face=Courier>long</font>
| <font face=Courier>long</font>
| категория 2
|-
| <font face=Courier>double</font>
| <font face=Courier>double</font>
| категория 2
|}

<br><br><br><br>
==== Инструкции загрузки и считывания ====

Инструкции загрузки и считывания перемещают значения переменных между локальными переменными (см. §2.6.1) стеком операндов (см. §2.6.2) фрейма виртуальной машины Java:

* Загрузить локальную переменную в стек операндов: ''iload'',  ''iload_<n>'',  ''lload'', ''lload_<n>'', ''fload'', ''fload_<n>'', ''dload'', ''dload_<n>'', ''aload, aload_<n>''.
* Считать значение из стека операндов в локальную переменную: ''istore'',  ''istore_<n>'', ''lstore'',  ''lstore_<n>'',  ''fstore'',  ''fstore_<n>'',  ''dstore'',  ''dstore_<n>'',  ''astore'',  ''astore_<n>''.
* Загрузить константу в стек операндов: ''bipush'',  ''sipush'',  ''ldc'',  ''ldc_w'',  ''ldc2_w'', ''aconst_null'', ''iconst_m1'', ''<nowiki>iconst_<i></nowiki>'', ''lconst_<l>'', ''fconst_<f>'', ''dconst_<d>''.
* Получения доступа к новым локальным переменным через расширение количества байт в индексе: ''wide''. 

Инструкции доступа к полям объекта и элементам массива (см. §2.11.5) также перемещают данные в и из стека операндов. 

Для обозначения семейства инструкций, в  мнемонической записи, приведенных выше команд, между угловыми скобками добавлены  спецсимволы; например ''iload_<n>'' означает набор ''iload_0'', ''iload_1'',  ''iload_2'' и ''iload_3''. Такие семейства инструкций (без аргументов) являются частными случаями инструкции ''iload'', у которой только один операнд. Для инструкций, являющихся частным случаем, операнд задан не явно и нет необходимости хранить его где-либо. В остальном смысл инструкций полностью совпадает (например, ''iload_0'' означает то же что и ''iload'' с нулевым операндом). Буква между угловыми скобками определяет тип неявного операнда для семейства инструкций: ''<n>'' - неотрицательное целое, ''<nowiki><i></nowiki>'' для <font face=Courier>int</font>, ''<l>'' для <font face=Courier>long</font>, ''<f>'', a <font face=Courier>float</font> и ''<d>'' для <font face=Courier>double</font>. Инструкции для типа <font face=Courier>int</font> часто используются для работы со значениями типа <font face=Courier>byte</font>, <font face=Courier>char</font> и <font face=Courier>short</font> (см. §2.11.1).

Указанная выше нотация для семейств инструкций используется повсеместно в данной спецификации.

<br><br><br><br>
==== Арифметические инструкции ====

Арифметическая инструкция, вычисляющая некоторый результат, обычно считывает два значения расположенных на вершине стека операндов, и помещает результат снова в стек. Существуют две основные разновидности арифметических инструкций: оперирующие целыми значениями и оперирующие значениями с плавающей точкой. Нет арифметических операций, работающих непосредственно со значениями типа <font face=Courier>byte</font>, <font face=Courier>short</font> и <font face=Courier>char</font> (см. §2.11.1) или типа <font face=Courier>boolean</font>; для работы с данными типами используются инструкции, работающие с типом <font face=Courier>int</font>. 

Целочисленные инструкции и инструкции для работы с числами с плавающей точкой так же отличаются своим поведением при переполнении и делении на ноль. Существуют следующие арифметические инструкции:
* Сложение: ''iadd'', ''ladd'', ''fadd'', ''dadd''.
* Вычитание: ''isub'', ''lsub'', ''fsub'', ''dsub''.
* Умножение: ''imul'', ''lmul'', ''fmul'', ''dmul''.
* Деление: ''idiv'', ''ldiv'', ''fdiv'', ''ddiv''.
* Остаток от деления: ''irem'', ''lrem'', ''frem'', ''drem''.
* Отрицание: ''ineg'', ''lneg'', ''fneg'', ''dneg''.
* Сдвиг: ''ishl'', ''ishr'', ''iushr'', ''lshl'', ''lshr'', ''lushr''.
* Битовое ИЛИ: ''ior'', ''lor''.
* Битовое И: ''iand'', ''land''.
* Битовое исключающее ИЛИ: ''ixor'', ''lxor''.
* Увеличение локальной переменной на единицу: ''iinc''.
* Сравнение: ''dcmpg'', ''dcmpl'', ''fcmpg'', ''fcmpl'', ''lcmp''.

Семантика операторов языка программирования Java над целыми числами и числами с плавающей точкой полностью поддерживается набором инструкций виртуальной машины Java.

Виртуальная машина Java не сообщает о переполнении во время операции над целыми типами данных. Единственные целочисленные операции, которые могут вызвать исключение – это целочисленное деление (''idiv'' и ''ldiv'') и целочисленное вычисление остатка (''irem'' и ''lrem''); они выбрасывают исключение <font face=Courier>ArithmeticException</font> при делении на ноль. 

Работа инструкций виртуальной машины Java, оперирующих с числами с плавающей точкой, соответствует спецификации IEEE 754. В частности, виртуальная машина Java требует согласно IEEE 754 полной поддержки денормализованных чисел с плавающей точкой и постепенной потери значащих разрядов, что позволяет получить желаемые свойства некоторых численных алгоритмов.

Виртуальная машина Java требует, чтобы арифметические операции с плавающей точкой округляли результат согласно точности, заданной для этого результата. Неточные результаты должны быть округлены к представимому значению, ближайшему к точному результату; если существуют два одинаково близких представимых значения, то выбирается то, которое имеет, по крайней мере, один нулевой значащий бит. Это режим округления по умолчанию в стандарте IEEE 754, известный как режим округления к ближайшему. 

Виртуальная машина Java использует режим округления к нулю стандарта IEEE 754 при преобразовании типов с плавающей точкой к целочисленным типам. Происходит отбрасывание дробной части; все значащие биты дробной части операнда теряются. Режим округления к нулю в качестве результата предоставляет значение ближайшее к абсолютно точному, но не большее по модулю, чем абсолютно точное значение. 

Операции над числами с плавающей точкой виртуальной машины Java не вызывают исключений (не путать с исключениями стандарта IEEE 754 для чисел с плавающей точкой). При переполнении возвращается бесконечность с соответствующим знаком; при потере точности возвращается денормализованное значение или знаковый ноль, а при операциях не определенных с математической точки зрения возвращается не-число (NaN). Все числовые операции с не-числами (NaN) в качестве хотя бы одного операнда возвращают не-число.

Сравнение значений с типом <font face=Courier>long</font> (''lcmp'') является знаковым сравнением. Сравнение значений для типов с плавающей точкой (''dcmpg'',  ''dcmpl'',  ''fcmpg'',  ''fcmpl'') выполняются как не сигнализирующие сравнения стандарта IEEE 754.

<br><br><br><br>
==== Инструкции преобразования типов ====

Инструкции преобразования типов позволяют выполнить преобразования между числовыми типами виртуальной машины Java. Они используются для выполнения явного преобразования типов в пользовательском коде и в качестве компенсации отсутствия ортогональности набора инструкций, имеющихся в  виртуальной машине Java.

Виртуальная машина Java непосредственно поддерживает следующий набор расширяющих числовых преобразований:

* <font face=Courier>int</font> в <font face=Courier>long</font>, <font face=Courier>float</font> или <font face=Courier>double</font>
* <font face=Courier>long</font> в <font face=Courier>float</font> или <font face=Courier>double</font>
* <font face=Courier>float</font> в <font face=Courier>double</font>

Инструкции для расширяющих числовых преобразований следующие: ''i2l'', ''i2f'', ''i2d'',  ''l2f'', ''l2d'' и  ''f2d''. Мнемоническое описание кодов операций состоит из аббревиатуры типа и символа 2, который означает предлог «к» (английский предлог to («к») и числительные two («два») имеют схожее произношение – ''прим. перев.''). Расширяющие числовые преобразования не приводят к потере точности на всем диапазоне числовых величин. На самом деле, расширение от <font face=Courier>int</font> к <font face=Courier>long</font> и от <font face=Courier>int</font> к <font face=Courier>double</font> вообще не приводит к потере информации; числовые значения полностью сохраняются. Преобразования расширения от <font face=Courier>float</font> к <font face=Courier>double</font> для режима работы с плавающей точкой FP-strict (см. §2.8.2) также полностью сохраняют числовые величины; однако преобразования для режима работы с плавающей точкой не FP-strict могут приводить к потере информации для любых числовых величин.

Преобразования от <font face=Courier>int</font> или <font face=Courier>long</font> значений к <font face=Courier>float</font>, либо от <font face=Courier>long</font> к <font face=Courier>double</font> могут приводить к потере точности, а именно: потеря младших значащих битов величины; результирующее число с плавающей точкой представляет собой результат округления при использовании режима округления к ближайшему, определённого в IEEE 754. 

Расширяющее числовое преобразования от <font face=Courier>int</font> к <font face=Courier>long</font> представляют собой просто знаковое расширение представленного в дополнительном коде значения <font face=Courier>int</font> к более широкому формату. Расширяющее числовое преобразования от <font face=Courier>char</font> к целым типам представляет собой беззнаковое расширение (нуль-расширение) типа <font face=Courier>char</font> к более широким форматам. 

Несмотря на возможную потерю точности, расширяющие числовые преобразования никогда не приводят к исключениям виртуальной машины Java (не путать с исключениями стандарта IEEE 754 для чисел с плавающей точкой)

Обратите внимание, что не существует расширяющих числовых преобразований от целых типов <font face=Courier>byte</font>, <font face=Courier>char</font> и <font face=Courier>short</font> к типу <font face=Courier>int</font>. Как указано ранее (см. §2.11.1) значения типов  <font face=Courier>byte</font>, <font face=Courier>char</font> и <font face=Courier>short</font> и так хранятся с использованием типа <font face=Courier>int</font>, так что эти преобразования выполняются неявно и так.

Виртуальная машина Java непосредственно поддерживает следующий набор сужающих числовых преобразований:

* <font face=Courier>int</font> в <font face=Courier>byte</font>, <font face=Courier>short</font> или <font face=Courier>char</font>
* <font face=Courier>long</font> в <font face=Courier>int</font>
* <font face=Courier>float</font> в <font face=Courier>int</font> или <font face=Courier>long</font>
* <font face=Courier>double</font> в <font face=Courier>int</font>, <font face=Courier>long</font> или <font face=Courier>float</font>

Инструкции для  сужающих числовых преобразований следующие: ''i2b'', ''i2c'', ''i2s'', ''l2i'',  ''f2i'', ''f2l'', ''d2i'', ''d2l'' и ''d2f''. Сужающие числовые преобразования могут вернуть в качестве результата значение с другим знаком, другим порядком величины или то и другое одновременно; поэтому возможна потеря точности.

Сужающее числовое преобразование <font face=Courier>int</font> или <font face=Courier>long</font> в некоторый целый тип ''T'' производится путём отбрасывания всех кроме ''N'' старших битов, где ''N'' – число битов, используемых в типе ''T''. Это может привести к тому, что результирующее значение может иметь знак отличный от знака исходного значения. 

При сужающем числовом преобразовании чисел с плавающей точкой в некоторый целый тип ''T'', где ''T'' - <font face=Courier>int</font> или <font face=Courier>long</font> выполняется следующее:

* Если значение  с плавающей точкой является не-числом (NaN), то результат преобразования есть 0 с типом <font face=Courier>int</font> или  <font face=Courier>long</font>.
* В противном случае, значение  с плавающей точкой не является бесконечностью, оно округляется к целому числу ''V'', используя режим округления к нулю стандарта IEEE 754. При этом возможны два случая:
** Если ''T''  <font face=Courier>long</font> и данное целое значение ''V'' представимо в типе <font face=Courier>long</font>, то результат преобразования - целое значение ''V'' типа <font face=Courier>long</font>.
** Если ''T''  <font face=Courier>int</font> и данное целое значение ''V'' представимо в типе <font face=Courier>int</font>, то результат преобразования - целое значение ''V'' типа <font face=Courier>int</font>.
* Иначе:
** Значение ''V'' слишком мало (отрицательное число, очень большое по модулю или отрицательная бесконечность); в этом случае результатом сужения типа будет наименьшее допустимое значение типа <font face=Courier>int</font> или  <font face=Courier>long</font>.
** Значение ''V'' слишком велико (положительное число, с большим значением или положительная бесконечность); в этом случае результатом сужения типа будет наибольшее допустимое значение типа <font face=Courier>int</font> или  <font face=Courier>long</font>.

Сужающее числовое преобразование от <font face=Courier>double</font>  к  <font face=Courier>float</font> выполняется согласно правилам стандарта IEEE 754. Результатом является корректно округленное значение; режим округления – округление к ближайшему по стандарту IEEE 754. Если значение слишком мало, чтобы быть представленным в типе <font face=Courier>float</font>, то результатом преобразования будет положительный или отрицательный ноль типа <font face=Courier>float</font>; если значение слишком велико, чтобы быть представленным в типе <font face=Courier>float</font>, то результатом преобразования будет положительная или отрицательная бесконечность. Не-число (NaN) типа <font face=Courier>double</font>  всегда преобразовывается типу не-числу (NaN) типа <font face=Courier>float</font>.

Несмотря на переполнение, потерю значащих разрядов, потерю точности сужающие числовые преобразования никогда не приводят к исключениям виртуальной машины Java (не путать с исключениями стандарта IEEE 754 для чисел с плавающей точкой).

<br><br><br><br>
==== Создание и работа с объектами ====

Не смотря на то, что и классы, и массивы являются объектами, виртуальная машина Java создаёт и работает с классами и объектами по-разному, используя различные наборы инструкций:

* Создание нового экземпляра класса: ''new''.
* Создание нового массива: ''newarray'', ''anewarray'', ''multianewarray''.
* Доступ к полям класса (статические поля (<font face=Courier>static</font>) известные как переменные класса) и полям экземпляра (не статические поля, известные как переменные экземпляра): ''getfield'', ''putfield'', ''getstatic'', ''putstatic''.
* Загрузить компонент массива в стек операндов: ''baload'',  ''caload'',  ''saload'',  ''iaload'', ''laload'', ''faload'', ''daload'', ''aaload''.
* Выгрузить значение из стека операндов в массив: ''bastore'', ''castore'', ''sastore'', ''iastore'', ''lastore'', ''fastore'', ''dastore'', ''aastore''.
* Получить длину массива: ''arraylength''.
* Проверить свойства экземпляра класса или массива: ''instanceof'', ''checkcast''.

<br><br><br><br>
==== Инструкции для работы со стеком операндов ====

Существует набор инструкций для непосредственной работы со стеком операндов: ''pop'', ''pop2'', ''dup'', ''dup2'', ''dup_x1'', ''dup2_x1'', ''dup_x2'', ''dup2_x2'', ''swap''.

<br><br><br><br>
==== Инструкции передачи управления ====

Выполнение инструкций передачи управления (условных или безусловных) приводит к тому, что виртуальная машина Java продолжает выполнение операции отличной от той, которая следует непосредственно после инструкции передачи управления. Доступны следующие операции:

* Условный переход: ''ifeq'',  ''ifne'',  ''iflt'',  ''ifle'',  ''ifgt'',  ''ifge'',  ''ifnull'',  ''ifnonnull'',  ''if_icmpeq'', ''if_icmpne'', ''if_icmplt'', ''if_icmple'', ''if_icmpgt'', ''if_icmpge'', ''if_acmpeq'', ''if_acmpne''. 
* Составные операторы условного перехода: ''tableswitch'', ''lookupswitch''.
* Операторы безусловного перехода: ''goto'', ''goto''_w, ''jsr'', ''jsr''_w, ''ret''.

Виртуальная машина Java имеет различные наборы инструкций условного перехода для работы с типами данных <font face=Courier>int</font> и <font face=Courier>reference</font>. Также виртуальная машина наборы инструкций условного перехода для проверки нулевых ссылок, поэтому нет требований, чтобы <font face=Courier>null</font> значение было строго определённым: его можно выбрать произвольно.

Инструкции условного перехода, использующие для сравнения данные с типами<font face=Courier>boolean</font>, <font face=Courier>byte</font>, <font face=Courier>char</font> и <font face=Courier>short</font> выполняются с помощью инструкций, работающих с типом<font face=Courier>int</font>(см. §2.11.1). Вместо инструкций условного перехода сравнивающих значения с типами данных<font face=Courier>long</font><font face=Courier>float</font> или <font face=Courier>double</font> выполняется следующее: используется команда сравнения двух чисел с типами данных <font face=Courier>long</font>, <font face=Courier>float</font> или <font face=Courier>double</font>; результат сравнения в виде значения с типом <font face=Courier>int</font> помещается в стек операндов.  Затем переход для перехода используется инструкция, работающая с типом <font face=Courier>int</font>. Из-за активного использования сравнений с типом данных <font face=Courier>int</font> виртуальная машина Java имеет расширенной набор инструкций условного перехода, использующих для сравнения данные с типом <font face=Courier>int</font>.

Все инструкций условного перехода, использующих для сравнения данные с типом<font face=Courier>int</font> выполняют знаковое сравнение.

<br><br><br><br>
==== Вызов методов и инструкции возврата ====

Существуют пять инструкций вызова методов:

* ''invokevirtual'' вызывает метод экземпляра с учётом типа объекта (полиморфный вызов – прим. перев.). Это нормальная диспетчеризация методов в языке программирования Java.
* ''invokeinterface'' вызывает метод интерфейса, проводя поиск методов реализованных в экземпляре во время выполнения программы.
* ''invokespecial'' вызывает методы экземпляра, требующие специальной обработки, будь то метод инициализации экземпляра (см. §2.9), приватный метод или метод родительского класса.
* ''invokestatic'' вызывает статические методы класса.
* ''invokedynamic'' вызывает метод, который связан с узловым объектом вызова. Перед первым выполнением метода вызывается инициализирующий метод и в качестве результата узловой объект вызова связывается виртуальной машиной Java  со специфическим лексическим включением инструкции ''invokedynamic''. Поэтому каждое появление инструкции * ''invokedynamic'' имеет уникальное состояние связывания, в отличие от других инструкций вызова методов.

Существуют следующие инструкции возврата из метода, различаемые по возвращаемому значению: ''ireturn'' (используется для возвращения значений с типами   <font face=Courier>boolean</font>,  <font face=Courier>byte</font>,  <font face=Courier>char</font>,  <font face=Courier>short</font> или  <font face=Courier>int</font>),  ''lreturn'',  ''freturn'', ''dreturn'' и  ''areturn''. Инструкция ''return'' используется для возврата из методов, объявленных как <font face=Courier>void</font>, возврата из инициализирующих экземпляр методов или методов инициализации класса или интерфейса.

<br><br><br><br>
==== Формирование исключений ====

Программно вызов исключения можно выполнить с помощью инструкции ''athrow''. Исключения также могут быть вызваны виртуальной машиной Java при соответствующих условиях.

<br><br><br><br>
==== Синхронизация ====

Виртуальная машина Java поддерживает синхронизацию, как целых методов, так и набора инструкций с помощью единой конструкции для синхронизации: ''монитора''.

Синхронизация на уровне методов выполняется неявно как часть вызова методов и возврата из методов (см. §2.11.8). Метод, объявленный как <font face=Courier>synchronized</font>, отличается от других методов тем, что в структуре данных времени выполнения <font face=Courier>method_info</font> (см. §4.6) установлен флаг <font face=Courier>ACC_SYNCHRONIZED</font>, который проверяется инструкцией вызова метода. Если для вызываемого метода флаг <font face=Courier>ACC_SYNCHRONIZED</font> установлен, то при вызове метода, поток сначала входит в монитор, затем собственно исполняет тело метода и выходит из монитора вне зависимости от того завершилось ли выполнение метода нормально  или аварийно. Все время пока поток владеет монитором, никакой другой поток не может захватить этот монитор. Если происходит выброс исключения во время исполнения метода, объявленного как <font face=Courier>synchronized</font>, и синхронизированный метод не перехватывает это исключение,  то поток автоматически выходит из монитора (освобождает монитор) перед тем как не перехваченное исключение будет повторно выброшено вне синхронизированного метода.

Для реализации блоков синхронизации языка программирования Java используется синхронизация набора инструкций. Для поддержки таких языковых конструкций виртуальная машина Java имеет инструкции ''monitorenter'' и  ''monitorexit''. Правильная реализация блоков синхронизации требует совместной работы, как компилятора, так и виртуальной машины Java (см. §3.14). 

''Структурное связывание'' – это такая ситуация, когда при вызове метода каждый выход из монитора соответствует предыдущему входу в тот же монитор. Так как нет никаких гарантий, что любой код, выполняемый виртуальной машиной Java, поддерживает структурное связывание,  то для реализации виртуальной машины Java допустимо, но не обязательно выполнение двух следующих правил, гарантирующих структурное связывание. Обозначим через ''T'' поток, а через M монитор. Тогда:

# Число входов в монитор ''M'' выполненных потоком ''T'' должно равняться числу выходов из монитора ''M'' выполненных потоком ''T'' вне зависимости от того завершился ли вызов метода нормально или аварийно.
# Никогда во время работы с методом число выходов из монитора ''M'' выполненных потоком ''T'' не должно превышать число входов в монитор ''M'' выполненных потоком ''T''.

Обратите внимание, что вход и выход в монитор автоматически выполняется виртуальной машиной Java при вызове синхронизированного метода.

<br><br><br><br>
=== Библиотека классов ===

Виртуальная машина Java, реализованная на конкретной платформе, должна предоставить достаточную поддержку для реализации библиотеки классов. Некоторые классы в этих библиотеках не могут быть реализованы без тесного взаимодействия с виртуальной машиной Java. 

Классы, которые могут потребовать специальной поддержки со стороны виртуальной машины Java, включают в себя  следующие:

* Реализацию рефлексии; классы в пакете <font face=Courier>java.lang.reflect</font> и класс <font face=Courier>Class</font>.
* Загрузку и создание классов и интерфейсов. Простейший пример – класс <font face=Courier>ClassLoader</font>.
* Компоновку и инициализацию классов или интерфейсов. Приведённые выше примеры также подходят и для этой категории.
* Реализацию политик безопасности; классы в пакете <font face=Courier>java.security</font> и другие классы, такие как <font face=Courier>SecurityManager</font>. 
* Реализацию многопоточности; класс <font face=Courier>Thread</font>.
* Реализацию слабых ссылок; классы пакета <font face=Courier>java.lang.ref</font>.

Приведённый выше список является скорее иллюстративным и не претендует на полноту. Исчерпывающий список классов и их функциональности выходит за рамки данной спецификации. Подробная информация предоставлена в спецификации библиотеки классов платформы Java SE.

<br><br><br><br>
=== Открытый дизайн, закрытая реализация ===

На данный момент в этой спецификации мы выполнили лишь общий набросок виртуальной машины Java: формат <font face=Courier>class</font> файла и набор инструкций. Эти компоненты жизненно важны для реализации независимости виртуальной машины Java от аппаратного обеспечения, операционной системы, и конкретной реализации самой виртуальной машины Java. Разработчику следует рассматривать эти компоненты скорее как средства обеспечения безопасного взаимодействия реализаций виртуальных машин Java на разных платформах, чем как заданные раз и навсегда правила.

Важно понимать, где проходит черта между открытым дизайном и закрытой реализацией. Реализация виртуальной машины Java должна быть способной читать <font face=Courier>class</font> файлы и точно реализовывать семантику кода виртуальной машины Java. Один из способов сделать – это взять данный документ и реализовать все описанное здесь от точки до точки. Однако для разработчика также допустимо  изменять и оптимизировать реализацию в рамках ограничений данной спецификации, конечно. До тех пор, пока <font face=Courier>class</font> файл может быть прочтён и семантика его кода соблюдена, разработчик может произвольно реализовывать данную семантику. То, что происходит внутри «чёрного ящика» касается только разработчика, до тех пор, пока тщательно соблюдены все внешние интерфейсы.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Из этого правила есть некоторые исключения: отладчики, модули протоколирования (профайлеры), генераторы кода для динамической компиляции (JIT компиляторы) требуют доступа к элементам виртуальной машины Java, которые находятся обычно внутри «чёрного ящика». Где это целесообразно, компания Oracle сотрудничает со сторонними разработчиками виртуальных машин Java и поставщиками инструментальных библиотек для разработки и распространения описания общих интерфейсов виртуальной машины Java. </span>

|}
<br>
Разработчики могут использовать предоставляемую гибкость, чтобы адаптировать виртуальную машину Java для повышения производительности, уменьшения использования памяти или переносимости. Приоритеты в данной конкретной реализации виртуальной машины зависят от целей, которые ставит перед собой разработчик. Цели могут также включать в себя следующее:

* Перевод кода виртуальной машины Java (во время загрузки или во время работы) в набор инструкций другой виртуальной машины.
* Перевод кода виртуальной машины Java (во время загрузки или во время работы) в набор инструкций центрально процессора, на котором запущена виртуальная машина (иногда называемый динамической (JIT) компиляцией).

Существование точно специфицированной виртуальной машины и формата файла объектов не обязательно приводит к ограничению полёта мысли разработчика. Виртуальная машина Java разработана для поддержки многих реализаций, что даёт новые и интересные решения при полном сохранении совместимости между реализациями.

<br><br><br><br>
== ГЛАВА 3. Компиляция программ в код виртуальной машины Java  ==

Виртуальная машина Java разработана для поддержки языка программирования Java. Библиотека Oracle JDK содержит компилятор, преобразующий исходный код на языке программирования Java в набор инструкций виртуальной машины Java и систему, реализующую непосредственно виртуальную машину Java. Для будущих разработчиков компиляторов полезно знать на примере как компилятор использует виртуальную машину Java так же, как и полезно понимать собственно устройство виртуальной машины. Некоторые из разделов в этой главе не являются обязательными для исполнения.

Обратите внимание, что под термином «компилятор» иногда понимается транслятор из набора инструкций виртуальной машины Java в набор инструкций конкретного центрального процессора. Один из примеров такого транслятора – это динамический генератор кода (JIT компилятор), который генерирует платформенно зависимые инструкции только после загрузки кода виртуальной машины Java. Эта глава не касается генерации платформенно зависимого кода, а посвящена только компиляции исходного кода на языке программирования Java в набор инструкций виртуальной машины Java.

<br><br><br><br>
=== Формат примеров ===

Эта глава в основном состоит из примеров исходного кода комментированными листингами кода виртуальной машины Java, который генерирует компилятор <font face=Courier>javac</font> в составе Oracle JDK версии 1.0.2. Код виртуальной машины Java написан на так называемом «ассемблере виртуальной машины», который был сформирован утилитой <font face=Courier>javap</font> в составе Oracle JDK. Вы можете использовать <font face=Courier>javap</font>, чтобы получить собственные дополнительные примеры к приведённым в этой главе.

Формат примеров должен быть знаком для любого разработчика, имевшего дело с ассемблером. Каждая инструкция имеет формат:

 ''<индекс> <код> [ <операнд1> [ <операнд2>... ]] [<комментарий>]''

Здесь ''<индекс>'' - индекс операции  в массиве байт-кодов соответствующего метода. Также индекс можно рассматривать как байтовое смещение операции относительно начала метода. ''<код>'' - мнемоническое обозначение кода инструкции; ''<операндN>'' - операнды инструкции (могут отсутствовать); ''[<комментарий>]'' -  необязательный комментарий в конце строки:

 ''8  bipush 100          // записать в стек константу 100 с типом int''

Некоторые комментарии генерирует утилитой <font face=Courier>javap</font>; остальные комментарии написаны авторами. ''<индекс>'', предшествующий каждой инструкции может быть использован в инструкциях передачи управления. Например, инструкция ''goto 8'' передает управление инструкции с индексом ''8''.  Обратите внимание, что фактическим операндами инструкций передачи управления являются абсолютные адресные смещения, однако для удобства чтения (мы также используем это в данной главе) утилита <font face=Courier>javap</font> преобразует их в смещения внутри метода.

Операнды, представляющие собой индексы значений в константном пуле, мы снабжаем символом решетки и комментарием, описывающем значение константы, на которую ссылается индекс, например:

 ''10  ldc #1      // Записать в стек константу 100.0 с типом float'' 

или

 ''9  invokevirtual #4   // Метод Example.addTwo(II)I''

В рамках данной главы мы опускаем некоторые детали, такие как размер операндов и другие.

<br><br><br><br>
=== Использование констант, локальных переменных и управляющих структур ===

Код виртуальной машины Java содержит некоторые особенности, продиктованные архитектурой виртуальной машины Java и её типами данных. В первом примере мы обнаружим их в большом количестве и рассмотрим их более подробно.
Метод <font face=Courier>spin</font> выполняет пустой цикл 100 раз:

<syntaxhighlight lang="java">
void spin() {
    int i;
    for (i = 0; i < 100; i++) {
        ; // Тело цикла пустое
    }
}
</syntaxhighlight>

Компилятор преобразует <font face=Courier>spin</font> в следующий байт-код:

 0  ''iconst_0''	// Записать в стек 0 с типом int
 1  ''istore_1''	// Загрузить в локальную переменную с именем 1 (i=0)
 2  ''goto'' 8	// При первом проходе не увеличивать счетчик
 5  ''iinc'' 1 1	// Увеличить локальную переменную с именем 1 на 1 (i++)
 8  ''iload_1''	// Записать локальную переменную с именем 1 в стек (i)
 9  ''bipush'' 100	// Записать в стек константу 100 типа int 
 11 ''if_icmplt'' 5	// Сравнить и повторить цикл если результат меньше (i < 100)
 14 ''return''	// Вернуть пустой тип после завершения

Виртуальная машина Java является стек-ориентированной; большинство операций загружает из стека или записывает в стек виртуальной машины Java, который расположен в текущем фрейме, один или более операндов. Новый фрейм создаётся каждый раз при вызове метода и вместе с ним создаётся новый стек операндов множество локальных переменных, которые использует метод (см. §2.6). В каждый момент работы программы, скорее всего, будет создано много фреймов и соответственно стеков операндов для текущего управляющего потока; количество фреймов соответствует глубине вложенности вызовов методов. Активным является стек операндов только текущего метода.
 
Набор инструкций виртуальной машины Java спроектирован таким образом, что позволяет отличать типы операндов той или иной инструкции по разному байт-коду инструкции. Метод spin работает только с типами значений <font face=Courier>int</font>. Поэтому все инструкции скомпилированного байт-кода (''iconst_0'', ''istore_1'', ''iinc'', ''iload_1'', ''if_icmplt'') также оперируют только с типами данных <font face=Courier>int</font>. 

Две константы <font face=Courier>0</font> и <font face=Courier>100</font> в методе <font face=Courier>spin</font> записаны в стек операндов с использованием двух различных инструкций. <font face=Courier>0</font> записан в стек с помощью инструкции ''iconst_0'', одной из семейства инструкций  ''<nowiki>iconst_<i></nowiki>''. <font face=Courier>100</font> записано с помощью инструкции ''bipush'', которая записывает следующие за ее байт-кодом значение непосредственно в стек. 

Виртуальная машина Java использует преимущество набора команд, неявно заменяя, где это возможно, инструкции с часто используемыми операндами (константы типа <font face=Courier>int</font>   ''-1'',  ''0'',  ''1'',  ''2'',  ''3'',  ''4'' и  ''5'' в случае инструкции  ''<nowiki>iconst_<i></nowiki>'') на их эквивалентные, но более короткие версии. Поскольку для инструкции ''iconst_0'' известно, что она записывает в стек значение <font face=Courier>int</font> 0,  нет необходимости дополнительно хранить операнд, так же как и нет необходимости извлекать и декодировать операнд. Если скомпилировать запись в стек нуля в инструкцию ''bipush 0'', то это будет корректно, но приведёт к увеличению на один байт размера скомпилированного метода <font face=Courier>spin</font>. Это также приведёт к тому, что виртуальная машина потратит время на извлечение и декодирование явно заданного операнда каждый раз при проходе цикла. Использование неявных операндов позволяет сделать код более компактным и эффективным. 

Переменная <font face=Courier>int</font> ''i'' в методе <font face=Courier>spin</font> хранится в локальной переменной виртуальной машины Java с именем ''1''. Поскольку большинство инструкций виртуальной машины Java чаще оперируют со значениями, считанными из стека операндов чем с локальными переменными, то для скомпилированного кода характерно наличие инструкций записывающих данные из локальных переменных в стек и обратно. Для таких операций разработаны специальные инструкции в наборе команд. В методе <font face=Courier>spin</font>, запись и считывание значений локальных переменных происходит с помощью инструкций ''istore_1'' и ''iload_1'', неявно работающих с локальной переменой ''1''. Инструкция ''istore_1'' считывает значение типа <font face=Courier>int</font> из стека операндов и сохраняет в локальной переменной ''1''. Инструкция ''iload_1'' записывает в стек операндов значение локальной переменной ''1''.

Способы использования локальных переменных находятся в пределах ответственности разработчика компилятора. Разработчик должен стремиться использовать инструкции для работы с локальными переменными везде, где это только возможно. В этом случае результирующий код будет работать быстрее, иметь меньший размер и использовать фреймы меньшего размера. 

Виртуальная машина Java имеет набор инструкций для наиболее частых операций с локальными переменными. Инструкция ''iinc'' увеличивает значение локальной переменной на однобайтовое знаковое значение. В методе <font face=Courier>spin</font> инструкция ''iinc'' увеличивает первую локальную переменную (первый операнд инструкции) на ''1'' (второй операнд инструкции). Инструкция ''iinc'' очень удобна для использования в циклических конструкциях.
 
Цикл <font face=Courier>for</font> в методе <font face=Courier>spin</font> реализован в основном следующими инструкциями:

 5  ''iinc'' 1 1	// Увеличить локальную переменную с именем 1 на 1 (i++)
 8  ''iload_1''	// Записать локальную переменную с именем 1 в стек (i)
 9  ''bipush'' 100	// Записать в стек константу 100 типа int
 11 ''if_icmplt'' 5	// Сравнить и повторить цикл если результат меньше (i < 100)

Инструкция ''bipush'' записывает в стек значение ''100'' с типом <font face=Courier>int</font>, затем инструкция ''if_icmplt'' считывает из стека операндов значение 100 и сравнивает его с переменной i. Если результат сравнения «истина» (переменная i  меньше чем 100), происходит передача управления к индексу 5 и начинается следующая итерация цикла <font face=Courier>for</font>. В противном случае управление передаётся инструкции следующей за ''if_icmplt''.

Если бы в примере с методом spin использовался для счётчика тип, отличный от <font face=Courier>int</font>, то скомпилированный код был бы другим и отражал изменения в типе данных счётчика. Например, если бы вместо типа <font face=Courier>int</font> был бы тип <font face=Courier>double</font> как показано ниже:

<syntaxhighlight lang="java">
void dspin() {
double i;
for (i = 0.0; i < 100.0; i++) {
    ; // Цикл пустой
    }
}
</syntaxhighlight>

то в результате компиляции был бы следующий код:

 Метод void dspin()
 0  ''dconst_0''	// Записать в стек 0.0 с типом double
 1  ''dstore_1''	// Загрузить в локальные переменные с именами 1 и 2
 2  ''goto'' 9	// При первом проходе не увеличивать счётчик
 5  ''dload_1''	// Записать в стек локальные переменные 1 и 2
 6  ''dconst_1''	// Записать в стек 1.0 с типом double
 7  ''dadd''		// Сложить; инструкции dinc нет
 8  ''dstore_1''	// Загрузить в локальные переменные с именами 1 и 2
 9  ''dload_1''	// Записать в стек локальные переменные 1 и 2
 10 ''ldc2_w'' #4	// Записать в стек 100.0 с типом double
 13 ''dcmpg''	// Инструкции if_dcmplt нет
 14 ''iflt'' 5	// Сравнить и повторить цикл, если результат «меньше» (i < 100.0)
 17 ''return''	// Вернуть пустой тип после завершения

Инструкции, которые работают с типизированными данными, заменены для типа <font face=Courier>double</font>. (Инструкция ''ldc2_w'' будет описана далее в этой главе.)

Вспомните, что значения типа <font face=Courier>double</font> хранятся в двух локальных переменных, однако доступ к ним осуществляется через младший индекс одной из двух локальных переменных. Аналогично для типа данных <font face=Courier>long</font>. Ещё пример:

<syntaxhighlight lang="java">
double doubleLocals(double d1, double d2) {
return d1 + d2;
} 
</syntaxhighlight>

компилируется в 

 Метод double doubleLocals(double,double)
 0  ''dload_1''	// Первый аргумент в локальных переменных 1 и 2
 1  ''dload_3''	// Второй аргумент в локальных переменных 3 и 4
 2  ''dadd''
 3  ''dreturn''

Обратите внимание, что пара локальных переменных, хранящих значение типа <font face=Courier>double</font> в <font face=Courier>doubleLocals</font> никогда не должны рассматриваться отдельно.

Поскольку код операции в виртуальной машине Java занимает один байт, результирующий код получается очень компактным. Как следствие, это означает, что набор инструкций виртуальной машины Java очень мал. Поэтому виртуальная машина Java не поддерживает одинаковый набор операций для всех типов: набор операций не полностью ортогонален (см. таблицу 2.2). 

Например, сравнение двух значений типа <font face=Courier>int</font> в цикле <font face=Courier>for</font> в примере метода spin может быть реализовано с помощью одной инструкции ''if_icmplt''; тем не менее, не существует одной инструкции в наборе виртуальной машины Java, которая реализовывала условный переход по результату сравнения значений типа <font face=Courier>double</font>. Поэтому в <font face=Courier>dspin</font> использовано сравнение значений <font face=Courier>double</font> (инструкция ''dcmpg'') и условный переход по результату сравнения (инструкция ''iflt'').

Операции с типом  <font face=Courier>int</font> наиболее полно представлены в наборе инструкций виртуальной машины Java. С одной стороны это сделано для более эффективной реализации стека операндов и массивов локальных переменных. С другой стороны то, что тип <font face=Courier>int</font> наиболее части используется в программах, также сыграло свое значение. Поддержка других целочисленных типов реализована в меньшем объеме. Например, для типов <font face=Courier>byte</font>,  <font face=Courier>char</font> и  <font face=Courier>short</font> нет инструкций хранения, загрузки или сложения. Вот пример функции <font face=Courier>spin</font> для типа <font face=Courier>short</font>:

<syntaxhighlight lang="java">
void sspin() {
short i;
for (i = 0; i < 100; i++) {
    ; // Тело цикла пустое
    }
}
</syntaxhighlight>

Этот исходный код должен быть скомпилирован для виртуальной машины Java следующим образом: в качестве основного типа данных выбирается <font face=Courier>int</font>, там, где это необходимо выполняется преобразование между <font face=Courier>short</font> и <font face=Courier>int</font>, гарантирующее, что значения типа <font face=Courier>short</font> будут в соответствующих пределах:

 Метод void sspin()
 0  ''iconst_0''
 1  ''istore_1''
 2  ''goto'' 10
 5  ''iload_1''		// Значение short рассматривается как int
 6  ''iconst_1''
 7  ''iadd''
 8  ''i2s''			// Усечение  int к short
 9  ''istore_1''
 10 ''iload_1''
 11 ''bipush'' 100
 13 ''if_icmplt'' 5
 16 ''return''

То, что непосредственная поддержка типов  <font face=Courier>byte</font>,  <font face=Courier>char</font> и  <font face=Courier>short</font> ограничена в виртуальной машине Java, не является серьёзным недостатком, поскольку значения этих типов все равно преобразуются к типу <font face=Courier>int</font> (<font face=Courier>byte</font> и  <font face=Courier>short</font> расширяются знаково к <font face=Courier>int</font>, для <font face=Courier>char</font> используется беззнаковое расширение). Таким образом, операции над типами <font face=Courier>byte</font>,  <font face=Courier>char</font> и  <font face=Courier>short</font> могут быть выполнены с использованием инструкций для типа <font face=Courier>int</font>. Единственные дополнительные затраты связаны с преобразованием значений типа <font face=Courier>int</font> к нужным пределам.
 
Тип данных <font face=Courier>long</font> и типы с плавающей точкой имеют среднюю поддержку в наборе инструкций виртуальной машины Java; единственное, что отсутствует для них – инструкции условной передачи управления.

<br><br><br><br>
=== Арифметика ===

Виртуальная машина Java обычно выполняет арифметические операции над операндами в стеке. (Исключение составляет инструкция ''iinc'', которая непосредственно увеличивает значение локальной переменной.) Например, метод <font face=Courier>align2grain</font> выравнивает значение типа <font face=Courier>int</font> по степеням двойки:


<syntaxhighlight lang="java">
int align2grain(int i, int grain) {
return ((i + grain-1) & ~(grain-1));
}
</syntaxhighlight>

Операнды арифметических операций считываются из стека операндов, а результат выполнения операции записывается обратно в стек. Таким образом, результаты промежуточных арифметических вычислений могут быть использованы в качестве операндов в последующих вычислениях. Например, вычисление выражения <font face=Courier>~(grain-1)</font> выполняется посредством следующих инструкций:

 5  ''iload_2''	// Записать grain в стек
 6  ''iconst_1''	// Записать константу 1 типа int в стек
 7  ''isub''		// Вычесть; записать результат в стек
 8  ''iconst_m1''	// Записать константу -1 типа int в стек
 9  ''ixor''		// Выполнить XOR; записать результат в стек

Вначале вычисляется значение <font face=Courier>grain-1</font> с использованием локальной переменной ''2'' и константы <font face=Courier>1</font> типа <font face=Courier>int</font>. Эти операнды считываются из стека операндов, и их разность записывается обратно в стек.  Таким образом, значение разности непосредственно доступно в качестве операнда для инструкции ''ixor''. (Напомним что <font face=Courier>~x == -1^x</font>.) Точно также результат выполнения инструкции ''ixor'' становится операндом последующей инструкции ''iand''.

Полностью скомпилированный код метода выглядит так:

 Метод int align2grain(int,int)
 0  ''iload_1''
 1  ''iload_2''
 2  ''iadd''
 3  ''iconst_1''
 4  ''isub''
 5  ''iload_2''
 6  ''iconst_1''
 7  ''isub''
 8  ''iconst_m1''
 9  ''ixor''
 10 ''iand''
 11 ''ireturn''

<br><br><br><br>
=== Доступ к константному пулу времени выполнения ===

Доступ к большинству численных констант, объектов, полей и методов можно получить через константный пул времени выполнения текущего класса. Доступ к объектам будет рассмотрен позже (см. §3.8). Доступ к типам данных <font face=Courier>int</font>,  <font face=Courier>long</font>,  <font face=Courier>float</font> и  <font face=Courier>double</font>  и ссылкам на экземпляр класса <font face=Courier>String</font> можно получить с помощью инструкций ''ldc'',  ''ldc''_w и  ''ldc''2_w.

Инструкции ''ldc'' и ''ldc''_w используются для доступа к значениям (включая экземпляры класса <font face=Courier>String</font>) в константном пуле времени выполнения (кроме значений типа <font face=Courier>double</font> и <font face=Courier>long</font>). Инструкция  ''ldc''_w используется вместо ''ldc'' в случае большого числа элементов в константном пуле, что в свою очередь требует индекса большей размерности для доступа к ним. Инструкция ''ldc''2_w предназначена для доступа к значениям типа <font face=Courier>double</font> и <font face=Courier>long</font>; варианта этой инструкции с однобайтовым индексом не существует.

Целочисленные константы типов <font face=Courier>byte</font>,  <font face=Courier>char</font> и  <font face=Courier>short</font>, равно как и некоторые значения типа <font face=Courier>int</font> могут быть созданы с помощью инструкций ''bipush'',  ''sipush'' и  ''<nowiki>iconst_<i></nowiki>'' (см. §3.2). Некоторые константы с плавающей точкой могут быть также созданы с помощью инструкций ''fconst_<f>'' и ''dconst_<d>''.

Для всех случаев указанных выше компиляция выполняется непосредственно в байт-код без дополнительных преобразований. Например, для следующих констант:

<syntaxhighlight lang="java">
void useManyNumeric() {
int i = 100;
int j = 1000000;
long l1 = 1;
long l2 = 0xffffffff;
double d = 2.2;
... выполнить вычисления...
}
</syntaxhighlight>

Будет скомпилирован байт-код:

 Метод void useManyNumeric()
 0  ''bipush'' 100  // Записать в стек 100 типа int
                // с помощью ''bipush'' (небольшое целое).
 2  ''istore_1''
 3  ''ldc'' #1      // Записать в стек 1000000 типа int;
                // для больших целочисленных значений используется ''ldc''
 5  ''istore_2''
 6  ''lconst_1''    // Для совсем маленьких целых используется ''lconst_1''
 7  ''lstore_3''
 8  ''ldc2_w'' #6   // Записать в стек  0xffffffff  типа long (-1 для типа int);
                // любая константа типа long может быть
                // записана в стек с помощью ''ldc2_w''
 11  ''lstore'' 5
 13  ''ldc2_w'' #8  // Записать в стек  константу 2.200000 типа double;
                // нестандартные double значения
                // записываются в стек с помощью ''ldc2_w''
 16  ''dstore'' 7
 ...выполнить вычисления...

<br><br><br><br>
=== Передача управления ===

Компиляция операторов <font face=Courier>for</font> была показана нами выше (см. §3.2). Большинство конструкций передачи управления языка Java (<font face=Courier>if</font>-<font face=Courier>then</font>-<font face=Courier>else</font>, <font face=Courier>do</font>, <font face=Courier>while</font>, <font face=Courier>break</font> и <font face=Courier>continue</font>) компилируется в байт-код тривиальным образом. Компиляция оператора <font face=Courier>switch</font> описана в отдельном разделе (см. §3.10), компиляция исключений – в разделе §3.12, операторов <font face=Courier>finally</font> – в §3.13.

В качестве дальнейшего примера рассмотрим цикл <font face=Courier>while</font>; его компиляция достаточно тривиальна; однако есть некоторые нюансы при компиляции разных типов данных используемых в операции сравнения в цикле. Как обычно тип <font face=Courier>int</font> наиболее поддерживаемый из всех типов, например: 

<syntaxhighlight lang="java">void whileInt() {
    int i = 0;
    while (i < 100) {
    i++;
    }
}
</syntaxhighlight>

Будет скомпилировано в:

 Метод void whileInt()
 0  	''iconst_0''
 1  	''istore_1''
 2  	''goto'' 8
 5  	''iinc'' 1 1
 8  	''iload_1''
 9  	''bipush'' 100
 11  	''if_icmplt'' 5
 14  	''return''

Обратите внимание, что проверка в цикле <font face=Courier>while</font> (реализованная с помощью инструкции ''if_icmplt'') расположена в конце цикла в скомпилированном байт-коде виртуальной машины Java. (Тоже самое читатель мог видеть в методе <font face=Courier>spin</font> выше.)  Поскольку проверка расположена в конце цикла, необходимо использовать инструкцию ''goto'', чтобы она была выполнена до самой первой итерации цикла. Если первая проверка условия в цикле вернет «ложь» и тело цикла никогда не будет выполнено, то в этом случае инструкция ''goto'' лишь увеличивает размер скомпилированного байт-кода. Тем не менее, <font face=Courier>while</font> обычно проектируют таким образом, чтобы их тело выполнялось и достаточно большое число раз. Располагая проверку в конце цикла, мы тем самым экономим одну инструкцию при каждом выполнении итерации цикла: если бы проверка была в начале цикла, необходимо было бы поместить инструкцию ''goto'' в конце тела цикла и выполнять ее каждый раз по завершению тела, чтобы снова перейти к проверке условия.

Управляющие конструкции для других типов данных компилируются похожим образом, с учётом доступных для данных типов команд. Это приводит к менее эффективному коду, поскольку необходимо использовать большее число инструкций виртуальной машины Java, например:

<syntaxhighlight lang="java">void whileDouble() {
double i = 0.0;
while (i < 100.1) {
    i++;
    }
}
</syntaxhighlight>

компилируется в:

 Метод void whileDouble()
 0  	''dconst_0''
 1  	''dstore_1''
 2  	''goto'' 9
 5  	''dload_1''
 6  	''dconst_1''
 7  	''dadd''
 8  	''dstore_1''
 9  	''dload_1''
 10  	''ldc2_w'' #4       // Записать в стек константу 100.1 типа double
 13  	''dcmpg''           // Для выполнения сравнения и перехода
                        // необходимо использовать...
 14  	''iflt'' 5          // ...две инструкции
 17  	''return''

Каждый тип с плавающей точкой имеет по две инструкции сравнения:  ''fcmpl'' и  ''fcmpg'' для типа <font face=Courier>float</font> а также ''dcmpl'' и ''dcmpg'' для типа <font face=Courier>double</font>. Они отличаются между собой только тем, как реагируют на NaN значения. Поскольку NaN не упорядочено (см. §2.3.2), то все сравнения для чисел с плавающей точкой, когда один из операндов NaN, всегда возвращают «ложь». Компилятор выбирает тот вариант инструкции для соответствующего типа вне зависимости от того вернёт ли сравнение «ложь» из-за сравнения числовых операндов или не чисел NaN. Например:

<syntaxhighlight lang="java">int lessThan100(double d) {
if (d < 100.0) {
    return 1; 
    } else {
    return -1; 
    }
}
</syntaxhighlight>

будет скомпилировано в:

 Метод int lessThan100(double)
 0   ''dload_1''
 1   ''ldc2_w'' #4  // Записать в стек константу 100.0 типа double
 4   ''dcmpg''      // Записать в стек 1 если d не число NaN или d > 100.0;
                // Записать в стек 0 если d == 100.0
 5   ''ifge'' 10    // Выполнить переход в зависимости от значения в стеке: 0 или 1
 8   ''iconst_1''
 9   ''ireturn''
 10  ''iconst_m1''
 11  ''ireturn''

Если d не является NaN и меньше чем 100.0, то инструкция ''dcmpg'' помещает значение -1 типа <font face=Courier>int</font> в стек операндов; в этом случае ''ifge'' не выполняет переход. Если <font face=Courier>d</font> больше чем <font face=Courier>100.0</font> или является NaN, то  инструкция ''dcmpg'' помещает значение 1 типа <font face=Courier>int</font> в стек операндов; в этом случае ''ifge'' выполняет переход. Если <font face=Courier>d</font> равняется <font face=Courier>100.0</font>, то инструкция ''dcmpg'' помещает значение 0 типа <font face=Courier>int</font> в стек операндов; ''ifge'' также выполняет переход.

Инструкция ''dcmpl'' используется при компиляции, если знак в условии цикла поменять на обратный:


<syntaxhighlight lang="java">int greaterThan100(double d) {
if (d > 100.0) {
    return 1; 
    } else {
    return -1; 
    }
}
</syntaxhighlight>

становится: 

 Метод int greaterThan100(double)
 0   ''dload_1''
 1   ''ldc2_w'' #4  // Записать в стек константу 100.0 типа double
 4   ''dcmpl''      // Записать в стек -1 если d не число NaN или d < 100.0;
                // Записать в стек 0 если d == 100.0
 5   ''ifle'' 10    // Выполнить переход в зависимости от значения в стеке: 0 или -1
 8   ''iconst_1''
 9   ''ireturn''
 10  ''iconst_m1''
 11  ''ireturn''

Повторим ещё раз: вне зависимости от того, будет ли значение логического выражения «ложь» в результате сравнения с числом или вследствие того, что один из операндов не число NaN, инструкция ''dcmpl'' запишет в стек значение типа  <font face=Courier>int</font>, которое приведёт к тому, что ''ifle'' выполнит переход. Если бы не было обоих видов инструкции ''dcmp'', в рассмотренных выше примерах необходимо было бы выполнять дополнительные действия для обработки значений NaN.

=== Получение аргументов ===


Если n переменных передаются в метод экземпляра, то они записываются согласно правилу в локальные переменные с номерами от ''1'' до ''n'' того фрейма, который был создан для вызова указанного выше метода. Аргументы поступают в метод в том порядке, в котором они передаются. Например:

c 
int addTwo(int i, int j) {
return i + j;
}  
</syntaxhighlight>

компилируется в:

 Метод int addTwo(int,int)
 0  ''iload_1'' // Записать в стек значение локальной переменной 1 (i)
 1  ''iload_2'' // Записать в стек значение локальной переменной 2 (j)
 2  ''iadd''    // Сложить; записать результат сложения в стек с типом int
 3  ''ireturn'' // вернуть результат с типом int

По соглашению в метод экземпляра также передаётся значение типа <font face=Courier>reference</font> –  ссылка на сам экземпляр – в локальную переменную ''0''. В языке программирования Java эта ссылка доступна через ключевое слово <font face=Courier>this</font>.

Методы, принадлежащие классу (<font face=Courier>static</font>), не принадлежат ни одному  экземпляру, поэтому необходимости в локальной переменной ''0'' нет.

Методы, принадлежащие классу, для хранения входных параметров используют локальные переменные, начиная с ''0''. Если бы метод <font face=Courier>addTwo</font> был бы статическим (принадлежал классу), то его параметры передавались бы похожим образом, но с единственным различием: индекс локальных переменных начинался бы с ''0'',  а не с ''1''. Пример:

<syntaxhighlight lang="java">static int addTwoStatic(int i, int j) {
    return i + j;
}   
</syntaxhighlight>

компилируется в:

 Метод int addTwoStatic(int,int)
 0  ''iload_0''
 1  ''iload_1''
 2  ''iadd''
 3  ''ireturn''

Обратите внимание, индекс начинается с ''0'', а не с ''1''.

<br><br><br><br>
=== Вызов методов ===

Обычный вызов методов осуществляется с помощью диспетчеризации времени выполнения. (Если методы – виртуальные в терминах C++.) Такой вызов осуществляется с помощью инструкции ''invokevirtual'', которая в качестве аргументов принимает индекс в константном пуле времени выполнения, указывающий на внутреннее двоичное имя класса объекта и имя вызываемого метода. Совместно двоичное имя класса и имя метода называется дескриптором метода (см. §4.3.3). Для вызова метода <font face=Courier>addTwo</font> определённого выше в качестве метода экземпляра, нам следует написать:

<syntaxhighlight lang="java">int add12and13() {
    return addTwo(12, 13);
}   
</syntaxhighlight>

Этот код будет скомпилирован в:

 Метод int add12and13()
 0  ''aload_0''                 // Записать в стек локальную переменную 0 (ссылка this)
 1  ''bipush'' 12               // Записать в стек значение 12 типа int
 3  ''bipush'' 13               // Записать в стек значение 13 типа int
 5  ''invokevirtual'' #4        // Метод Example.addtwo(II)I
 8  ''ireturn''                 // Записать в стек значение типа int
                                // – результат выполения addTwo();


Перед вызовом метода необходимо записать в стек значение типа <font face=Courier>reference</font> – ссылку на текущий экземпляр, <font face=Courier>this</font>. Затем в стек записываются аргументы метода – значения <font face=Courier>12</font> и <font face=Courier>13</font> типа  <font face=Courier>int</font>. После того, как будет создан фрейм для метода <font face=Courier>addTwo</font>, аргументы, переданные в метод, будут присвоены в качестве начальных значений локальным переменным. Аргумент типа <font face=Courier>reference</font> и два других аргумента, записанные в стек вызывающим методом, станут значениями локальных переменных с именами ''0'', ''1'' и ''2'' вызываемого метода.

Затем вызывается метод <font face=Courier>addTwo</font>.  Когда метод <font face=Courier>addTwo</font> завершит выполнение, на вершину стека операндов вызывающего метода будет записано значение типа <font face=Courier>int</font> – результат выполнения <font face=Courier>add12and13</font>.

Возврат из метода <font face=Courier>add12and13</font> выполняется посредством инструкции ''ireturn''. Инструкция ''ireturn'' считывает из стека операндов текущего фрейма значение типа <font face=Courier>int</font> – результат выполнения <font face=Courier>addTwo</font> –  и записывает его в стек фрейма вызывающего метода. Затем ''ireturn'' передаёт управление вызывающему методу, при этом фрейм вызывающего метода становится текущим. Набор инструкций виртуальной машины Java содержит различные варианты инструкции возврата в зависимости от типа возвращаемого методом значения – числового типа либо типа <font face=Courier>reference</font>; инструкция ''return'' используется для методов, не возвращающих значений. Один и тот же набор инструкций возврата из методов используется для всех инструкций вызова методов.

Операнд инструкции ''invokevirtual'' (в примере выше это индекс #4 в константном пуле времени выполнения) не является смещением метода в экземпляре класса. Компилятор не имеет информации о внутренней структуре экземпляра класса. Вместо этого он генерирует символьную ссылку на метод экземпляра, которая хранится в константном пуле времени выполнения. Разрешение ссылок константного пула происходит во время выполнения программы: символьные ссылки на экземпляры заменяются указателями на методы. Это  справедливо и для других инструкций виртуальной машины Java, требующих доступа к объектам.

Вызов статической реализации <font face=Courier>addTwoStatic</font> похож на вызов <font face=Courier>addTwo</font>:

<syntaxhighlight lang="java">int add12and13() {
    return addTwoStatic(12, 13);
}
</syntaxhighlight>

хотя для вызова метода используется другая инструкция виртуальной машины Java:

 Метод int add12and13()
 0  ''bipush'' 12
 2  ''bipush'' 13
 4  ''invokestatic'' #3// Метод Example.addTwoStatic(II)I
 7  ''ireturn''

Компиляция вызова статического метода напоминает компиляцию вызова метода экземпляра за исключением того, что параметр <font face=Courier>this</font> не передаётся вызывающим методом в вызываемый. Фактические параметры метода будут записаны в локальные переменные, начиная с переменной с именем ''0'' (см. §3.6). Инструкция ''invokestatic'' всегда используется при вызове методов класса (<font face=Courier>static</font> методов).

Инструкция ''invokespecial'' используется для вызова методов, инициализирующих экземпляр (см. §3.8). Она также используется для вызова методов класса-предка (<font face=Courier>super</font>) и для вызова <font face=Courier>private</font> методов. Рассмотрим классы <font face=Courier>Near</font> и <font face=Courier>Far</font>, объявленные следующим образом:

<syntaxhighlight lang="java">class Near {
  int it;
  public int getItNear() {
     return getIt();
  }
  private int getIt() {
     return it;
  }
}
class Far extends Near {
  int getItFar() {
    return super.getItNear();
  }
}
</syntaxhighlight>

Метод <font face=Courier>Near.getItNear</font>, вызывающий <font face=Courier>private</font> метод компилируется следующим образом:

 Метод int getItNear()
 0  ''aload_0''
 1  ''invokespecial'' #5// Метод Near.getIt()I
 4  ''ireturn''

Метод <font face=Courier>Far.getItFar</font>, вызывающий метод суперкласса, компилируется в:

 Метод int getItFar()
 0  ''aload_0''
 1  ''invokespecial'' #4// Метод Near.getItNear()I
 4  ''ireturn''

Обратите внимание, при использовании инструкции ''invokespecial'' всегда передается параметр <font face=Courier>this</font> в качестве первого аргумента. Как обычно, этот аргумент записывается в локальную переменную ''0''.

Для вызова методов компилятор создаёт дескриптор методов, который содержит описания аргументов и возвращаемого типа. Компилятор не должен выполнять преобразования типов, необходимые для вызова метода; вместо этого он обязан записать значения аргументов в стек в соответствии с их исходными типами. Компилятор также записывает в стек значение <font face=Courier>this</font>  с типом <font face=Courier>reference</font> перед всеми аргументами, как  это описано выше. Компилятор формирует вызов инструкции ''invokevirtual'', которая ссылается на дескриптор, описывающий аргументы и возвращаемые типы. Согласно соглашению о разрешении методов (см. §5.4.3.3), инструкция ''invokevirtual'', которая вызывает метод <font face=Courier>invokeExact</font> либо  <font face=Courier>invoke</font> класса <font face=Courier>java.lang.invoke.MethodHandle</font> всегда выполнит связывание методов, при условии, что дескриптор сформирован корректно, и типы, упомянутые в дескрипторе, могут быть разрешены.

<br><br><br><br>
=== Работа с экземплярами класса ===

Экземпляры классов виртуальной машины Java сознаются с помощью инструкции ''new'' виртуальной машины Java. Напомним, что на уровне виртуальной машины Java конструктор представляет собой метод с именем <font face=Courier><init></font>, присвоенным компилятором. Этот специально созданный метод известен как инициализирующий метод экземпляра (см. §2.9). Для данного класса могут существовать несколько инициализирующих методов экземпляра, соответственно числу конструкторов. Когда экземпляр класса был создан и переменным класса присвоены начальные значения (включая экземпляры их переменные всех предков данного класса), вызывается инициализирующий метод экземпляра. Например,

<syntaxhighlight lang="java">Object create() {
  return new Object();
}   
</syntaxhighlight>

будет скомпилировано в:

 Метод java.lang.Object create()
 0  ''new'' #1		// Класс java.lang.Object
 3  ''dup''
 4  ''invokespecial'' #4	// Метод java.lang.Object.<init>()V
 7  ''areturn''

Ссылка на экземпляр класса (тип данных <font face=Courier>reference</font>) считывается и записывается в стек также как и числовые значения, кроме того для типа <font face=Courier>reference</font> существует свой набор инструкций, например,

<syntaxhighlight lang="java">   
 int i; // Переменная экземпляра
MyObj example() {
  MyObj o = new MyObj();
  return silly(o);
}
MyObj silly(MyObj o) {
  if (o != null) {
  return o;
  } else {
  return o;
  }
}
</syntaxhighlight>

компилируется в

 Метод MyObj example()
 0  ''new'' #2		// Class MyObj
 3  ''dup''
 4  ''invokespecial'' #5	// Метод MyObj.<init>()V
 7  ''astore_1''
 8  ''aload_0''
 9  ''aload_1''
 10  ''invokevirtual'' #4	// Метод Example.silly(LMyObj;)LMyObj;
 13  ''areturn''

 Метод MyObj silly(MyObj)
 0  ''aload_1''
 1  ''ifnull'' 6
 4  ''aload_1''
 5  ''areturn''
 6  ''aload_1''
 7  ''areturn''

Доступ полям экземпляра (переменным экземпляра), осуществляется с помощью инструкций ''getfield'' и ''putfield''. Если <font face=Courier>i</font> – переменная экземпляра типа <font face=Courier>int</font> и методы <font face=Courier>setIt</font> и <font face=Courier>getIt</font> определены как

<syntaxhighlight lang="java">void setIt(int value) {
  i = value;
}
int getIt() {
  return i;
}   
</syntaxhighlight>

то, код будет скомпилирован следующим образом:

 Метод void setIt(int)
 0  ''aload_0''
 1  ''iload_1''
 2  ''putfield'' #4	// Поле Example.i I
 5  ''return''

 Метод int getIt()
 0  ''aload_0''
 1  ''getfield'' #4	// Поле Example.i I
 4  ''ireturn''

Также как и для операндов инструкции вызова методов, для операндов операций ''putfield'' и ''getfield'' справедливо следующее: эти операнды не являются смещениями полей в структуре экземпляра класса, а представляют собой индекс в константном пуле (индекс #4 в примере выше) времени выполнения. Компилятор генерирует символьные ссылки на поля экземпляра; ссылки хранятся в константном пуле времени выполнения. Во время выполнения программы эти ссылки разрешаются для определения поля в объекте.

<br><br><br><br>
=== Массивы ===

Массивы также являются объектами. Массивы создаются и обрабатываются определенным набором инструкций. Инструкция ''newarray'' используется для создания массива из числовых элементов. Исходный код

<syntaxhighlight lang="java">void createBuffer() {
    int buffer[];
    int bufsz = 100;
    int value = 12;
    buffer = new int[bufsz];
    buffer[10] = value;
    value = buffer[11];
}  
</syntaxhighlight>

будет скомпилирован в

 Метод void createBuffer()
 0  ''bipush'' 100              // Записать в стек значение 100 (bufsz) с типом int
 2  ''istore_2''                // Считать из стека bufsz в локальную переменную 2
 3  ''bipush'' 12               // Записать в стек значение 12 с типом int
 5  ''istore_3''                // Считать из стека значение в локальную переменную 3
 6  ''iload_2''                 // Записать в стек значение и локальной переменной 2 (bufsz)...
 7  ''newarray'' int            // ...и создать массив с типами int и длиной bufsz
 9  ''astore_1''                // Считать из стека значение ссылки и записать в локальную переменную 1
 10  ''aload_1''                // Записать в стек ссылку на массив из локальной переменной 1
 11  ''bipush'' 10              // Записать в стек значение 10 типа int
 13  ''iload_3''                // Записать в стек значение локальной переменной 3 типа int
 14  ''iastore''                // Загрузить значения типа int из стека в массив buffer[10]
 15  ''aload_1''                // Загрузить ссылку из локальной  переменной 1 в стек
 16  ''bipush'' 11              // Записать в стек значение 11 типа int
 18  ''iaload''                 // Записывать в стек значение из массива buffer[11]...
 19  ''istore_3''               // ... и считать из стека значение в локальную переменную 3
 20  ''return''

Инструкция ''anewarray'' используется для создания одномерного массива ссылок на объекты, например:

<syntaxhighlight lang="java">void createThreadArray() {
    Thread threads[];
    int count = 10;
    threads = new Thread[count];
    threads[0] = new Thread();
}
</syntaxhighlight>

становится:

 Метод void createThreadArray()
 0  ''bipush'' 10         // Записать в стек значение 10 с типом int
 2  ''istore_2''          // Считать из стека значение в локальную переменную 2, инициализировав тем самым переменную count
 3  ''iload_2''           // Записать в стек значение и локальной переменной 2 (count)
 4  ''anewarray'' class #1// Создать массив ссылок на объекты класса Thread
 7  ''astore_1''          // Считать из стека значение ссылки на массив и записать в локальную переменную 1
 8  ''aload_1''           // Загрузить ссылку из локальной  переменной 1 в стек
 9  ''iconst_0''          // Записать в стек значение 0 с типом int
 10  ''new'' #1           // Создать экземпляр класса Thread
 13  ''dup''              // Сделать дубликат ссылки на вершине стека...
 14  ''invokespecial'' #5 // ...для передачи его в инициализирующий метод экземпляра Method java.lang.Thread.<init>()V 
 17  ''aastore''          // Сохранить ссылку из стека в массиве в ячейке с индексом 0
 18  ''return''

Инструкция ''anewarray'' может быть использована также для создания первого измерения многомерного массива. Аналогично инструкция ''multianewarray'' может быть использована для создания массива с несколькими измерениями сразу. Например, трёхмерный массив:

<syntaxhighlight lang="java">int[][][] create3DArray() {
    int grid[][][];
    grid = new int[10][5][];
    return grid;
}
</syntaxhighlight>

компилируется в

 Метод int create3DArray()[][][]
 0  ''bipush'' 10               // Записать в стек 10 (первое измерение)
 2  ''iconst_5''                // Записать в стек 5 (второе измерение)
 3  ''multianewarray'' #1 dim #2// Class [[[I, трёхмерный целочисленный массив
                            // Необходимо создать только первые два измерения, хранящие ссылки на другие массивы. 
                            // Величина третьего измерения не задана 
 7  ''astore_1''                // Считать из стека значение ссылки на массив и записать в локальную переменную 1
 8  ''aload_1''                 // затем загрузить ссылку из локальной  переменной 1 в стек
 9  ''areturn''

Первый операнд инструкции ''multianewarray'' представляет собой индекс в константном пуле на код типа создаваемого массива. Второй аргумент – количество размерностей, которые фактически необходимо создать.  Инструкция ''multianewarray'', как показывает приведённый выше пример компиляции метода <font face=Courier>create3DArray</font>, может быть использована для создания массивов всех типов. Обратите внимание, что многомерный массив также как и одномерный представляет собой объект; ссылка на него загружается в локальную переменную и возвращается из метода инструкциями ''aload_1'' и ''areturn'' соответственно. Информацию об именах классов массивов см. в §4.4.1.

Все массивы имеют поле, содержащее их длину, доступ к которому, осуществляется с помощью инструкции ''arraylength''.

<br><br><br><br>
=== Компилирование операторов <font face=Courier>switch</font> ===

При компилировании операторов <font face=Courier>switch</font> используются инструкции ''tableswitch''  ''lookupswitch''. Инструкция ''tableswitch'' используется, когда константы оператора <font face=Courier>switch</font> могут быть легко представлены в виде набора последовательных значений, которые будут преобразованы в индекс в  таблице смещений. Ключевое слово <font face=Courier>default</font> используется, если значение проверяемого выражения не совпадает ни с одной константой оператора  <font face=Courier>switch</font>. Например,

<syntaxhighlight lang="java">int chooseNear(int i) {
switch (i) {
    case 0: return 0;
    case 1: return 1;
    case 2: return 2;
    default: return -1;
    }
}   
</syntaxhighlight>

будет скомпилировано в: 

 Метод int chooseNear(int)
 0  ''iload_1''                // Записать в стек локальную
                           // переменную 1 (аргумент i)
 1  ''tableswitch'' 0 to 2:    // Допустимые пределы индексов от 0 до 2
 0: 28                     // Если i равно 0, продолжить
                           // выполнение со смещения 28
 1: 30                     // Если i равно 1, продолжить с 30
 2: 32                     // Если i равно 2, продолжить с 32
 default:34                // Иначе, продолжить с 34
 28  ''iconst_0''              // i равно 0; записать в стек константу 0 типа int...
 29  ''ireturn''               // ... и вернуть ее
 30  ''iconst_1''              // i равно 1; записать 1...
 31  ''ireturn''               // ...и вернуть ее
 32  ''iconst_2''              // i равно 2; записать 2...
 33  ''ireturn''               // ...и вернуть ее
 34  ''iconst_m1''             // иначе записать константу -1...
 35  ''ireturn''               // ...и вернуть ее

Инструкции виртуальной машины Java ''tableswitch'' и ''lookupswitch'' работают только со значениями типа <font face=Courier>int</font>. Поскольку операции над типами <font face=Courier>byte</font>,  <font face=Courier>char</font> и  <font face=Courier>short</font> преобразуются к операциям с типом <font face=Courier>int</font>, операторы <font face=Courier>switch</font> с выражениями указанных типов компилируются успешно и используют значения типа <font face=Courier>int</font>. Если бы метод <font face=Courier>chooseNear</font> был написан с использованием типа <font face=Courier>short</font>, то инструкции виртуальной машины Java были бы те же что и для метода с типом <font face=Courier>int</font>. Другие численные типы для использования в операторе <font face=Courier>switch</font> должны быть преобразованы посредством сужения к типу <font face=Courier>int</font>. 

Если значения констант оператора <font face=Courier>switch</font> идут не последовательно, то создание таблицы смещений для инструкции  ''tableswitch'' становится не эффективным из-за дополнительного расхода памяти. Вместо этого должна быть использована инструкция ''lookupswitch''. Инструкция ''lookupswitch'' связывает значение целочисленного ключа (значения меток  <font face=Courier>case</font>) со смещением начала исполнимого кода. Когда исполняется инструкция ''lookupswitch'', значение выражения оператора <font face=Courier>switch</font> сравнивается с ключами в таблице. Если значения ключа и выражения совпадают, выполнения кода продолжается со смещения, связанного с данным ключом. Если выражение не совпадает ни с одним из ключей, то выполнения кода продолжается со смещения <font face=Courier>default</font>. Например, следующий код

<syntaxhighlight lang="java">int chooseFar(int i) {
    switch (i) {
    case -100: return -1;
    case 0: return 0;
    case 100: return 1;
    default: return -1;
    }
}
</syntaxhighlight>

напоминает метод <font face=Courier>chooseNear</font> за исключением того, что будет использована инструкция ''lookupswitch'':

 Метод int chooseFar(int)
 0  ''iload_1''
 1  ''lookupswitch'' 3:
 -100: 36
 0: 38
 100: 40
 default: 42
 36  ''iconst_m1''
 37  ''ireturn''
 38  ''iconst_0''
 39  ''ireturn''
 40  ''iconst_1''
 41  ''ireturn''
 42  ''iconst_m1''
 43  ''ireturn''

Согласно спецификации виртуальной машины Java элементы таблицы смещений инструкции ''lookupswitch'' должны быть отсортированы по ключу, так, чтобы скорость поиска была выше скорости при линейном просмотре таблицы. Даже в этом случае инструкция ''lookupswitch'' выполняет поиск ключа вместо проверки границ принадлежности выражения и использования значения выражения для непосредственного вычисления индекса смещения, как это сделано в инструкции ''tableswitch''. Поэтому инструкция ''tableswitch'' более эффективна, чем ''lookupswitch'', в случае если выбор между ними допустим.

<br><br><br><br>
=== Операции со стеком операндов ===

Виртуальная машина Java имеет большой набор инструкций, работающих со значениями стека операндов как с не типизированными значениями. Эти инструкции полезны, поскольку виртуальная машина Java корректно и безопасно манипулирует не типизированными значениями в стеке операндов. Например,

<syntaxhighlight lang="java">public long nextIndex() { 
    return index++;
    }

private long index = 0;
</syntaxhighlight>

будет скомпилировано в

 Метод long nextIndex()
 0  ''aload_0''    // Записать в стек ссылку this
 1  ''dup''        // Сделать дубликат ссылки на вершине стека
 2  ''getfield'' #4// Использован один дубликат ссылки this
               // для получения значения поля с типом long,
               // Значение поля размещено над исходной ссылкой this
 5  ''dup2_x1''    // Значение long на вершине стека операндов
               // дублируется и вставляется под ссылкой this
 6  ''lconst_1''   // Записать в стек константу 1 типа long
 7  ''ladd''       // Значение индекса на вершине стека увеличить на единицу...
 8  ''putfield'' #4// ...и результат записать обратно в поле объекта
 11 ''lreturn''    // Исходное значение индекса, оставленное на вершине
               // стека операндов, возвращается из метода

Обратите внимание, что виртуальная машина Java никогда не позволяет изменять или повредить отдельные значения в стеке операндов.

<br><br><br><br>
=== Генерация и обработка исключений ===

Исключения генерируются в программе с помощью ключевого слова <font face=Courier>throw</font>. Его компиляция проста:

<syntaxhighlight lang="java">void cantBeZero(int i) throws TestExc {
    if (i == 0) {
        throw new TestExc();
    }
}   
</syntaxhighlight>

будет скомпилировано в:

 Метод void cantBeZero(int)
 0  ''iload_1''             // Записать в стек локальную переменную 1 (i)
 1  ''ifne'' 12             // Если i==0, создать экземпляр и выбросить исключение
 4  ''new'' #1              // Создать экземпляр класса TestExc
 7  ''dup''                 // Одна ссылка будет передана конструктору
 8  ''invokespecial'' #7    // Метод TestExc.<init>()V
 11 ''athrow''              // Другая ссылка выброшена в качестве исключения
 12 ''return''              // Если выброшено исключение TestExc, то сюда мы не заходим

Компиляция конструкции <font face=Courier>try</font>-<font face=Courier>catch</font> также проста. Например,

<syntaxhighlight lang="java">void catchOne() {
try {
    tryItOut();
    } catch (TestExc e) {
    handleExc(e);
    }
}   
</syntaxhighlight>

будет скомпилировано в:

 Метод void catchOne()
 0  ''aload_0''             // Начало try блока
 1  ''invokevirtual'' #6    // Метод Example.tryItOut()V
 4  ''return''              // Конец try блока; нормальный выход из метода
 5  ''astore_1''            // Сохранить выбрасываемое исключение в локальной переменной 1
 6  ''aload_0''             // Записать в стек ссылку this
 7  ''aload_1''             // Записать в стек выбрасываемое исключение
 8  ''invokevirtual'' #5    // Вызвать метод-обработчик:
                        // Example.handleExc(LTestExc;)V
 11  ''return''             // Возврат после обработки исключения TestExc
 Таблица исключений:
 От    К     Смещение    Тип
 0     4     5           Класс TestExc

При более внимательном рассмотрении мы можем заметить, что <font face=Courier>try</font> блок компилируется так, как если бы оператора <font face=Courier>try</font> не было вообще:

 Метод void catchOne()
 0  ''aload_0''             // Начало try блока
 1  ''invokevirtual'' #6    // Метод Example.tryItOut()V
 4  ''return''              // Конец try блока; нормальный выход из метода

Если в ходе выполнения <font face=Courier>try</font> блока исключение не было выброшено вообще, то код выполняется, как будто  <font face=Courier>try</font> отсутствует: вызывается метод <font face=Courier>tryItOut</font> и происходит возврат из метода <font face=Courier>catchOne</font>.

Следующий  <font face=Courier>try</font> блок – это реализация виртуальной машиной Java единственного оператора <font face=Courier>catch</font>:

 5  ''astore_1''        // Сохранить выбрасываемое исключение в локальной переменной 1
 6  ''aload_0''         // Записать в стек ссылку this
 7  ''aload_1''         // Записать в стек ссылку на выбрасываемое исключение
 8  ''invokevirtual'' #5// Вызвать метод-обработчик:Example.handleExc(LTestExc;)V
 11  ''return''         // Возврат после обработки исключения TestExc
 Таблица исключений:
 От    До     Смещение    Тип
 0     4      5           Класс TestExc


Вызов метода <font face=Courier>handleExc</font> – обработчика в операторе <font face=Courier>catch</font> – также компилируется как обычный вызов метода. Однако наличие оператора <font face=Courier>catch</font> вынуждает компилятор генерировать таблицу исключений (см. §2.10,  §4.7.3). Таблица исключений для метода <font face=Courier>catchOne</font> имеет одну строку (для экземпляра класса <font face=Courier>TestExc</font>) соответственно одному оператору <font face=Courier>catch</font> в методе <font face=Courier>catchOne</font>. Если будет выброшено исключение – экземпляр класса <font face=Courier>TestExc</font> – во время выполнения инструкций между индексами ''0'' и ''4'' в методе <font face=Courier>catchOne</font>, управление будет передано коду, сгенерированному виртуальной машиной Java, начиная с индекса ''5''; этот код реализует обработку оператора  <font face=Courier>catch</font>. Если будет выброшено исключение, не являющееся экземпляром класса <font face=Courier>TestExc</font>, оператор <font face=Courier>catch</font> метода <font face=Courier>catchOne</font> не обработает его. Вместо этого исключение будет выброшено повторно для метода, вызвавшего <font face=Courier>catchOne</font>.

Блок <font face=Courier>try</font> может иметь несколько блоков <font face=Courier>catch</font>:

<syntaxhighlight lang="java">void catchTwo() {
    try {
        tryItOut();
    } catch (TestExc1 e) {
        handleExc(e);
    } catch (TestExc2 e) {
    handleExc(e);
    }
}   
</syntaxhighlight>

Для компилирования несколько блоков <font face=Courier>catch</font> в блоке  <font face=Courier>try</font> необходимо добавить по одной строке в таблицу исключений для каждого блока <font face=Courier>catch</font>, а также добавить код вызова обработчика исключения, который выполнить виртуальная машина Java. Пример:

 Метод void catchTwo()
 0  ''aload_0''             // Начало блока try
 1  ''invokevirtual'' #5    // Метод Example.tryItOut()V
 4  ''return''              // Конец try блока; нормальный выход из метода
 5  ''astore_1''            // Начало обработчика TestExc1;
                        // Сохранить выбрасываемое исключение
                        // в локальной переменной 1
 6  ''aload_0''             // Записать в стек ссылку this
 7  ''aload_1''             // Записать в стек ссылку на выбрасываемое исключение
 8  ''invokevirtual'' #7    // Вызвать метод-обработчик:
                        // Example.handleExc(LTestExc1;)V
 11  ''return''             // Возврат после обработки исключения TestExc1
 12  ''astore_1''           // Начало обработчика TestExc2;
                        // Сохранить выбрасываемое исключение
                        // в локальной переменной 1
 13  ''aload_0''            // Записать в стек ссылку this
 14  ''aload_1''            // Записать в стек ссылку на выбрасываемое исключение
 15  ''invokevirtual'' #7   // Вызвать метод-обработчик:
                        // Example.handleExc(LTestExc2;)V
 18  ''return''             // Возврат после обработки исключения TestExc2
 Таблица исключений:
 От     До     Смещение     Тип
 0      4      5            Class TestExc1
 0      4      12           Class TestExc2

Если во время выполнения блока <font face=Courier>try</font> (между индексами ''0'' и ''4'') будет выброшено исключение соответствующее одному или нескольким блокам <font face=Courier>catch</font> (исключение является прямым либо не прямым наследником одного из базовых классов <font face=Courier>TestExc1</font> или <font face=Courier>TestExc2</font>), то будет выбран первый (самый внутренний) блок <font face=Courier>catch</font> для обработки. Управление передаётся соответствующему обработчику блока <font face=Courier>catch</font>. Если выброшенное исключение не соответствует ни одному из блоков <font face=Courier>catch</font> метода <font face=Courier>catchTwo</font>, виртуальная машина Java повторно выбрасывает исключение в вызывающем методе; обработка блоков <font face=Courier>catch</font> метода <font face=Courier>catchTwo</font> больше не производится.

Вложенные блоки <font face=Courier>try</font>-<font face=Courier>catch</font> компилируются похожим на рассмотренную выше компиляцию нескольких блоков <font face=Courier>catch</font> образом:

<syntaxhighlight lang="java">void nestedCatch() {
try 	{
    try {
        tryItOut();
    } catch (TestExc1 e) {
        handleExc1(e);
    }
} catch (TestExc2 e) {
        handleExc2(e);
  }
}  
</syntaxhighlight>

компилируется в:

 Метод void nestedCatch()
 0  ''aload_0''             // Начало блока try
 1  ''invokevirtual'' #8    // Метод Example.tryItOut()V
 4  ''return''              // Конец try блока; нормальный выход из метода
 5  ''astore_1''            // Начало обработчика TestExc1;
                        // Сохранить выбрасываемое исключение
                        // в локальной переменной 1
 6  ''aload_0''             // Записать в стек ссылку this
 7  ''aload_1''             // Записать в стек ссылку на выбрасываемое исключение
 8  ''invokevirtual'' #7    // Вызвать метод-обработчик:
                        // Example.handleExc1(LTestExc1;)V
 11  ''return''             // Возврат после обработки исключения TestExc1
 12  ''astore_1''           // Начало обработчика TestExc2;
                        // Сохранить выбрасываемое исключение
                        // в локальной переменной 1
 13  ''aload_0''            // Записать в стек ссылку this
 14  ''aload_1''            // Записать в стек ссылку на выбрасываемое исключение
 15  ''invokevirtual'' #6   // Вызвать метод-обработчик:
                        // Example.handleExc2(LTestExc2;)V
 18  ''return''             // Возврат после обработки исключения TestExc2
 Таблица исключений:
 От     До     Смещение     Тип
 0      4      5            Class TestExc1
 0      12     12           Class TestExc2


Вложенность <font face=Courier>catch</font> блоков отражена только в таблице исключений. Виртуальная машина Java не регламентирует расположение согласно вложенности или любое другое упорядочение элементов таблицы исключений (см. §2.10). Однако, поскольку блоки <font face=Courier>try</font>-<font face=Courier>catch</font> структурированы, компилятор всегда может упорядочить элементы так, что для любого выбрасываемого исключения и любого значения программного счетчика в этом методе, первый обработчик, тип исключения которого совпадает с выброшенным исключением, соответствует наиболее подходящему блоку <font face=Courier>catch</font>.

Например, если вызов <font face=Courier>tryItOut</font> (индекс операции ''1'') генерирует исключение – экземпляр класса <font face=Courier>TestExc1</font> – то оно будет обработано блоком <font face=Courier>catch</font>, вызывающим <font face=Courier>handleExc1</font>. Это случится, даже если генерирование исключения произойдёт в пределах внешнего блока <font face=Courier>catch</font> (обрабатывающего <font face=Courier>TestExc2</font>) и даже если этот внешний блок <font face=Courier>catch</font> будет способен обработать исключение.

Один нюанс: обратите внимание, что левая граница предела блока <font face=Courier>catch</font> включает в себя начальное значение, а правая – не включает конечное (см. §4.7.3). Поэтому элемент таблицы исключений соответствующий <font face=Courier>TestExc1</font> не включает в себя инструкцию ''<font face=Courier>return</font>'', имеющую смещение ''4''. Тем не менее, элемент таблицы исключений соответствующий <font face=Courier>TestExc2</font> включает в себя инструкцию ''return'', имеющую смещение ''11''. Инструкции возврата для вложенных <font face=Courier>catch</font> блоков включаются в пределы объемлющих их блоков.

<br><br><br><br>

=== Компиляция инструкции <font face=Courier>finally</font> ===

(В этом разделе предполагается, что компилятор генерирует <font face=Courier>class</font>-файлы версии 50.0 или ниже так, что может быть использована инструкция ''jsr''. См. также §4.10.2.5.)

Компиляция структуры <font face=Courier>try</font>-<font face=Courier>finally</font> напоминает компиляцию <font face=Courier>try</font>-<font face=Courier>catch</font>. Блок <font face=Courier>finally</font> должен быть выполнен перед передачей управления из блока <font face=Courier>try</font>, вне зависимости от того, было ли выполнение блока <font face=Courier>try</font> успешным или аварийным, вследствие выброшенного исключения. Например, 

<syntaxhighlight lang="java">void tryFinally() {
    try {
    tryItOut();
    } finally {
    wrapItUp();
    }
} 
</syntaxhighlight>

будет скомпилировано в:

 Метод void tryFinally()
 0  ''aload_0''             // Начало блока try
 1  ''invokevirtual'' #6    // Метод Example.tryItOut()V
 4  ''jsr'' 14              // Вызов блока finally
 7  ''return''              // Конец блока try
 8  ''astore_1''            // Начало обработчика для произвольного исключения
 9  ''jsr'' 14              // Вызов блока finally
 12 ''aload_1''             // Записать в стек ссылку на исключение
 13 ''athrow''              // ...и повторно выбросить исключение в вызывающем методе
 14 ''astore_2''            // Начало блока finally
 15 ''aload_0''             // Записать в стек ссылку this
 16 ''invokevirtual'' #5    // Метод Example.wrapItUp()V
 19 ''ret'' 2               // Возврат из блока finally
 Таблица исключений:
 От     До     Смещение     Тип
 0      4      8            Произвольный

Существуют четыре способа передачи управления из блока <font face=Courier>try</font>: после достижения конца блока, при выполнении инструкций <font face=Courier>break</font> или <font face=Courier>continue</font> внутри блока и при выбросе исключения. Если метод <font face=Courier>tryItOut</font> не выбросит исключение, управление будет передано блоку <font face=Courier>finally</font> посредством инструкции  ''jsr''. Инструкция ''jsr'' ''14'', расположенная по индексу ''4'' выполняет «вызов подпрограммы» - обработчика блока <font face=Courier>finally</font> с индексом ''14'' (такими образом <font face=Courier>finally</font> представляет собой внутреннюю подпрограмму). Когда выполнение блока <font face=Courier>finally</font> будет завершено, инструкция ''ret''  ''2'' передаст управление инструкции, следующей за ''jsr''. 

Более детально, вызов подпрограммы работает следующим образом: инструкция ''jsr'' перед переходом записывает в стек операндов адрес следующей инструкции (''return'', имеющей индекс ''7''). Инструкция ''astore_2'' – начало подпрограммы – сохраняет адрес из стека в локальную переменную ''2''.  Начинает выполняться код блока <font face=Courier>finally</font> (в данном случае инструкции ''aload_0'' и ''invokevirtual''). Предполагая, что выполнение кода будет завершено успешно, инструкция ''ret'' получает адрес возврата из локальной переменной ''2'' и передаёт управление по этому адресу. Затем выполняется инструкция ''return'' и метод <font face=Courier>tryFinally</font> успешно завершается.

Блок <font face=Courier>try</font> совместно с блоком <font face=Courier>finally</font> компилируется в обработчик исключений специального вида – такой, что любое исключение, выброшенное в блоке <font face=Courier>try</font>, будет перехвачено; и будет вызван блок <font face=Courier>finally</font>. Если <font face=Courier>tryItOut</font> выбрасывает исключение, будет выполнен поиск соответствующего обработчика в таблице исключений метода <font face=Courier>tryFinally</font>. Будет найден обработчик специального вида, и выполнение инструкций продолжится с индекса ''8''. Инструкция ''astore_1'' с индексом ''8'' считывает из стека значение – ссылку на сгенерированное исключение – в локальную переменную ''1''. Следующая инструкция ''jsr'' выполняет переход к началу подпрограммы – блоку <font face=Courier>finally</font>. Предполагая, что выполнение блоку <font face=Courier>finally</font> завершится успешно, инструкция ''aload_1'' с индексом ''12'' записывает в стек операндов ссылку на выброшенное исключение, а затем инструкция ''athrow'' повторно выбрасывает исключение.

Компиляция блока <font face=Courier>try</font> совместно с блоками <font face=Courier>catch</font> и <font face=Courier>finally</font> более сложна:

<syntaxhighlight lang="java">void tryCatchFinally() {
try {
        tryItOut();
    } catch (TestExc e) {
    handleExc(e);
    } finally {
         wrapItUp();
    }
}   
</syntaxhighlight>

будет скомпилировано в

 Метод void tryCatchFinally()
 0  ''aload_0''             // Начало блока try
 1  ''invokevirtual'' #4    // Метод Example.tryItOut()V
 4  ''goto'' 16             // Переход к блоку finally
 7  ''astore_3''            // Начало обработчика TestExc;
                        // Считать из стека ссылку на выброшенное исключение
                        // и сохранить в локальной переменной 3
 8  ''aload_0''             // Записать в стек ссылку this
 9  ''aload_3''             // Записать в стек ссылку на выброшенное исключение
 10 ''invokevirtual'' #6    // Вызвать метод-обработчик:
                        // Example.handleExc(LTestExc;)V
 13 ''goto'' 16             // В этой инструкции ''goto'' нет необходимости,
                        // но она добавлена компилятором javac в JDK версии 1.0.2.
 16 ''jsr'' 26              // Переход к блоку finally
 19 ''return''              // Возврат после обработки исключения TestExc
 20 ''astore_1''            // Начало обработчика исключений
                        // отличных от TestExc, или исключений
                        // выброшенных во время работы TestExc
 21 ''jsr'' 26              // Переход к блоку finally
 24 ''aload_1''             // Записать в стек ссылку на исключение...
 25 ''athrow''              // ...и повторно выбросить исключение в вызывающем методе
 26 ''astore_2''            // Начало блока finally
 27 ''aload_0''             // Записать в стек ссылку this
 28 ''invokevirtual'' #5    // Метод Example.wrapItUp()V
 31 ''ret'' 2               // Возврат из блока finally
 Таблица исключений:
 От     До     Смещение     Тип
 0      4      7            Class TestExc
 0      16     20           any

Если выполнение блока <font face=Courier>try</font> завершается успешно, инструкция ''<font face=Courier>goto</font>'' с индексом ''4'' выполнит переход к инструкции с индексом ''16'', вызывающей блок <font face=Courier>finally</font>. Блок <font face=Courier>finally</font> начинается с индекса ''26'', успешно выполняется и возвращает управление инструкции ''return'' с индексом ''19''. Затем выполнение <font face=Courier>tryCatchFinally</font> успешно завершается.

Если метод <font face=Courier>tryItOut</font> выбрасывает экземпляр исключения <font face=Courier>TestExc</font>, то будет выбран первый (ближайший) обработчик исключений из таблиц исключений. Код обработчика исключений, начинающийся с индекса ''7'', передаёт ссылку на выброшенное исключение методу <font face=Courier>handleExc</font> и после его выполнения вызывает блок <font face=Courier>finally</font> с индексом ''26'' также как и в случае успешного завершения блока <font face=Courier>try</font>. Если исключение не было выброшено в ходе выполнения <font face=Courier>handleExc</font>, то выполнение <font face=Courier>tryCatchFinally</font> завершится успешно.

Если метод <font face=Courier>tryItOut</font> генерирует исключение, которое не является экземпляром <font face=Courier>TestExc</font> либо обработчик <font face=Courier>handleExc</font> сам по себе выбрасывает исключение, в таком случае обработка исключения происходит в соответствии со второй строкой таблицы исключений: интервал индексов инструкций для этой строки изменяется от ''0'' до ''16''.  Обработчик исключения  <font face=Courier>handleExc</font> начинает работу с инструкции с индексом ''20'', где ссылка на созданное исключение считывается из стека и сохраняется в локальную переменную ''1''. Затем происходит вызов блока <font face=Courier>finally</font> (вызов как подпрограммы), который начинается с индекса ''26''. Если происходи возврат из блока <font face=Courier>finaly</font>, то ссылка на исключение считывается из локальной переменной ''1'' и происходит повторное генерирование исключения с помощью инструкции ''athrow''. Если во время выполнения блока  <font face=Courier>finally</font> будет сгенерировано новое исключение, блок <font face=Courier>finally</font> завершится аварийно, что в свою очередь приведет к аварийному завершению <font face=Courier>tryCatchFinally</font> и выбросу исключения в вызвавшем <font face=Courier>tryCatchFinally</font> методе.

<br><br><br><br>
=== Компиляция инструкций синхронизации ===

Синхронизация в виртуальной машине Java осуществляется посредством явного или неявного захвата и освобождения монитора. Явный захват монитора подразумевает использование инструкций ''monitorenter'' и ''monitorexit'', неявный – вызов метода и возврат из метода.

Для кода, написанного на языке программирования Java, наиболее общим способом синхронизации является использование <font face=Courier>synchronized</font> методов. Метод является синхронизированным не только, если он использует инструкции ''monitorenter'' и ''monitorexit''. В константном пуле времени выполнения для синхронизированного метода установлен флаг <font face=Courier>ACC_SYNCHRONIZED</font>, который проверяется инструкцией вызова метода (см. §2.11.10).

Инструкции ''monitorenter'' и  ''monitorexit'' используются для компиляции синхронизационных блоков. Например,

<syntaxhighlight lang="java">void onlyMe(Foo f) {
    synchronized(f) {
    doSomething();
    }
}  
</syntaxhighlight>

компилируется в:

 Метод void onlyMe(Foo)
 0  ''aload_1''             // Записать в стек ссылку f
 1  ''dup''                 // Сделать копию ссылки в стеке
 2  ''astore_2''            // Записать из стека значение ссылки
                    // в локальную переменную 2
 3  ''monitorenter''        // Захватить монитор, связанный с f
 4  ''aload_0''             // Удерживая монитор, записать в стек ссылку this и...
 5  ''invokevirtual'' #5    // ...вызвать Example.doSomething()V
 8  ''aload_2''             // Записать в стек локальную переменную 2 (f)
 9  ''monitorexit''         // Освободить монитор, связанный с f
 10 ''goto'' 18             // Успешно завершить метод
 13 ''astore_3''            // В случае любого исключения, перейти сюда
 14 ''aload_2''             // Записать в стек локальную переменную 2 (f)
 15 ''monitorexit''         // Не смотря на исключение освободить монитор!
 16 ''aload_3''             // Записать в стек ссылку на исключение
                        // из локальной переменной  3...
 17 ''athrow''              // ...повторно выбросить исключение в вызывающем методе
 18 ''return''              // Выход из метода
 Таблица исключений:
 От     До     Смещение     Тип
 4      10     13           any
 13     16     13           any

Компилятор гарантирует, что вне зависимости от того, как завершиться метод, каждой выполненной инструкции ''monitorenter'' будет соответствовать одно и только одна выполненная инструкция ''monitorexit''. Это справедливо как для нормального (см. §2.6.4) так и аварийного завершения метода (см. §2.6.5). Чтобы обеспечить соответствие числа инструкций ''monitorenter'' и  ''monitorexit'' при аварийном завершении метода, компилятор генерирует обработчик исключения (§2.10), который перехватит любое исключение и выполнит инструкцию.

<br><br><br><br>
=== Аннотации ===

Представление аннотаций в  <font face=Courier>class</font>-файле, относящихся к типам данных, полям и методам описано в разделах  §4.7.16 и  §4.7.17. Аннотации, относящиеся к пакетам, требуют выполнения дополнительных правил. Эти правила описаны в данном разделе.

Когда компилятор встречает аннотацию, относящуюся к объявлению пакета, он создает  <font face=Courier>class</font>-файл, содержащий интерфейс, внутреннее имя которого (см. §4.2.1) <font face=Courier>package-name.package-info</font>. Интерфейс имеет уровень доступа по умолчанию («<font face=Courier>package</font>-<font face=Courier>private</font>») и не имеет предков-интерфейсов. В структуре  <font face=Courier>ClassFile</font> установлены флаги <font face=Courier>ACC_INTERFACE</font> и  <font face=Courier>ACC_ABSTRACT</font>. Если для созданного <font face=Courier>class</font>-файла номер версии меньше чем 50.0, то флаг <font face=Courier>ACC_SYNTHETIC</font> сброшен; если номер версии больше либо равен, то флаг <font face=Courier>ACC_SYNTHETIC</font> установлен. В созданном интерфейсе нет статических членов данных, кроме тех, которые создаются согласно ''Спецификации языка программирования Java 7'' (см. §9.2 спецификации).

Аннотации, относящиеся к пакетам, хранятся в атрибутах <font face=Courier>RuntimeVisibleAnnotations</font> (§4.7.16) и  <font face=Courier>RuntimeInvisibleAnnotations</font> (§4.7.17) структуры <font face=Courier>ClassFile</font> интерфейса.

<br><br><br><br>
== ГЛАВА 4. Формат <font face=Courier>class</font>-файла ==

В этой главе описан формат <font face=Courier>class</font> файла виртуальной машины Java. Каждый <font face=Courier>class</font>-файл состоит из определения единственного класс или интерфейса. Хотя класс или интерфейс не должен обязательно храниться во внешнем файле (например, класс может генерироваться непосредственно загрузчиком классов), тем не менее, любое корректное представление класса или интерфейса мы будем называть <font face=Courier>class</font>-файлом.

Class-файл представляет собой последовательность байт, состоящих из восьми бит. Все 16-ти, 32-х и 64-х битовые значения формируются из последовательностей двух, четырёх и восьми байт соответственно.  Элементы, состоящие из нескольких байт, всегда хранятся в порядке от старшего байта к младшему. Данный формат поддерживается виртуальной машиной Java интерфейсами <font face=Courier>java.io.DataInput</font> и <font face=Courier>java.io.DataOutput</font>, а также такими классами как <font face=Courier>java.io.DataInputStream</font> и <font face=Courier>java.io.DataOutputStream</font>.

В данной главе определен свой собственный набор типов, представляющих данные <font face=Courier>class</font>-файла. Типы <font face=Courier>u1</font>,  <font face=Courier>u2</font> и  <font face=Courier>u4</font> представляют беззнаковые значения размером один, два и четыре байта соответственно. В платформе Java эти типы могут быть считаны такими методами как <font face=Courier>readUnsignedByte</font>,  <font face=Courier>readUnsignedShort</font> и <font face=Courier>readInt</font> интерфейса <font face=Courier>java.io.DataInput</font>.

Также в данной главе используется C-подобная нотация для записи псевдоструктур, с помощью которых определен формат <font face=Courier>class</font>-файла. Для изменения путаницы с полями классов и экземпляров классов, содержимое псевдоструктур мы будем называть ''элементами''. Корректные элементы хранятся в <font face=Courier>class</font>-файле последовательно без выравнивания по байтам.

Во многих структурах <font face=Courier>class</font>-файла используются ''таблицы'', состоящие из переменного числа элементов. И хотя мы используем C-подобный синтаксис для обращения к элементам таблицы, это не значит, что индекс элемента может быть непосредственно преобразован в смещение элемента в памяти, поскольку каждый элемент может иметь различную размерность.

Там, где мы обращаемся со структурой <font face=Courier>class</font>-файла как с массивом, это значит, что она состоит из элементов одинаковой размерности, расположенных непрерывно и по индексу элемента можно вычислить его смещение в памяти.

Замечание. Мы используем данный шрифт для кода на Prolog, а <font face=Courier>этот шрифт</font> для инструкций виртуальной машины Java и структур <font face=Courier>class</font>-файла. Комментарии, добавленные с целью разъяснения отдельных моментов, представлены по тексту описания структур <font face=Courier>class</font>-файлов. Комментарии могут содержать примеры, а также обоснования тех или иных архитектурных решений.

<br><br><br><br>
=== Структура <font face=Courier>ClassFile</font> ===

<font face=Courier>Class</font>-файл состоит из одной структуры <font face=Courier>ClassFile</font>:

 ClassFile {
 u4             зарезервировано;
 u2             младшая_часть_номера_версии;
 u2             старшая_часть_номера_версии;
 u2             количество_константных_пулов;
 cp_info        константный_пул[количество_константных_пулов-1];
 u2             флаги_доступа;
 u2             текущий_класс;
 u2             предок;
 u2             количество_интерфейсов;
 u2             интерфейсы[количество_интерфейсов];
 u2             количество_полей;
 field_info     поля[количество_полей];
 u2             количество_методов;
 method_info    методы[количество_методов];
 u2             количество_атрибутов;
 attribute_info атрибут[количество_атрибутов];
 }

Описание элементов структуры <font face=Courier>ClassFile</font>:

<font face=Courier>зарезервировано</font>
:: Представляет собой номер, определяющий формат <font face=Courier>class</font>-файла. Он имеет значение 0xCAFEBABE.

<font face=Courier>младшая_часть_номера_версии, старшая_часть_номера_версии</font>
:: Значения <font face=Courier>младшая_часть_номера_версии</font> и <font face=Courier>старшая_часть_номера_версии</font> определяют совместно версию <font face=Courier>class</font>-файла. Если <font face=Courier>class</font>-файл имеет старшую часть номера версии равную M и младшую часть номера версии равную m, то общую версию <font face=Courier>class</font>-файла мы будем обозначать как M.m. Поэтому версии формата <font face=Courier>class</font>-файла могут быть упорядочены лексикографически, например: 1.5 < 2.0 < 2.1.

:: Реализация виртуальной машины Java может поддерживать формат <font face=Courier>class</font>-файла версии v тогда и только тогда, когда v находится в пределах Mi.0  ≤ v  ≤ Mj.m.

:: Значения пределов зависят от номера выпуска виртуальной машины Java.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Реализация виртуальной машины Java компании Oracle в JDK release 1.0.2 поддерживает формат <font face=Courier>class</font>-файла в пределах от 45.0 до 45.3 включительно. Выпуски JDK release 1.0.X поддерживают формат <font face=Courier>class</font>-файла в пределах от 45.0 до 45.65535 включительно. Для k  ≥ 2, выпуски платформы Java поддерживают формат <font face=Courier>class</font>-файла в пределах от 45.0 до 44+k.0 включительно.</span>
|}
<br>
<font face=Courier>количество_константных_пулов</font>
:: Значение элемента <font face=Courier>количество константных пулов</font> равно на единицу больше количества элементов <font face=Courier>константный_пул</font> в таблице. Индекс в таблице константных пулов считается действительным, если он больше нуля и меньше значения величины количество_константных_пулов, с учетом исключения для типов <font face=Courier>long</font> и <font face=Courier>double</font>, описанного в §4.4.5.

<font face=Courier>константный_пул[]</font>
:: Таблица <font face=Courier>константных_пулов</font> это таблица структур (см. §4.4) представляющих различные строковые константы, имена классов и интерфейсов, имена полей и другие константы, на которые есть ссылки в структуре <font face=Courier>ClassFile</font> и ее подструктурах. Формат каждой следующей структуры константный_пул отделяется от предыдущей «маркерным» байтом. 

:: Таблица константных пулов индексируется от 1 до значения <font face=Courier>количество_константных_пулов</font>-1.
<font face=Courier>флаги_доступа</font>
:: Значение элемента <font face=Courier>флаги_доступа</font> представляет собой маску флагов, определяющих уровень доступа к данному классу или интерфейсу, а также его свойства. Расшифровка установленного значения флагов приведена в таблице 4.1.

:: '''Таблица 4.1 Доступ к классу и модификаторы свойств.'''
{| border="1" style="border-collapse:collapse; margin-left: 46px;"
! Имя флага
! Значение
! Пояснение
|-
| <font face=Courier>ACC_PUBLIC</font>
| <font face=Courier>0x0001</font>
| Объявлен как <font face=Courier>public</font>; доступен из других пакетов.
|-
| <font face=Courier>ACC_FINAL</font>
| <font face=Courier>0x0010</font>
| Объявлен как <font face=Courier>final</font>; наследование от класса запрещено.
|-
| <font face=Courier>ACC_SUPER</font>
| <font face=Courier>0x0020</font>
| При исполнении инструкции <font face=Courier>invokespecial</font> обрабатывать методы класса предка особым способом.
|-
| <font face=Courier>ACC_INTERFACE</font>
| <font face=Courier>0x0200</font>
| <font face=Courier>Class</font>-файл определяет интерфейс, а не класс.
|-
| <font face=Courier>ACC_ABSTRACT</font>
| <font face=Courier>0x0400</font>
| Объявлен как <font face=Courier>abstract</font>; создание экземпляров запрещено.
|-
| <font face=Courier>ACC_SYNTHETIC</font>
| <font face=Courier>0x1000</font>
| Служебный класс. Отсутствует в исходном коде.
|-
| <font face=Courier>ACC_ANNOTATION</font>
| <font face=Courier>0x2000</font>
| Объявлен как аннотация
|-
| <font face=Courier>ACC_ENUM</font>
| <font face=Courier>0x4000</font>
| Объявлен как перечисление (тип <font face=Courier>enum</font>)
|}

:: Класс может быть помечен флагом <font face=Courier>ACC_SYNTHETIC</font>, что означает, что класс сгенерирован компилятором и отсутствует в исходном коде.

:: Флаг <font face=Courier>ACC_ENUM</font> означает, что класс или его предок, объявлены как перечисления.

:: Если установлен флаг <font face=Courier>ACC_INTERFACE</font>, то это означает что задано определение интерфейса. Если флаг <font face=Courier>ACC_INTERFACE</font> сброшен, то в <font face=Courier>class</font>-файле задан класс, а не интерфейс.

:: Если для данного <font face=Courier>class</font>-файла  установлен флаг <font face=Courier>ACC_INTERFACE</font>, то флаг <font face=Courier>ACC_ABSTRACT</font> должен быть также установлен (см. JLS §9.1.1.1).  При этом такой класс не должен иметь установленных флагов: <font face=Courier>ACC_FINAL</font>, <font face=Courier>ACC_SUPER</font> и <font face=Courier>ACC_ENUM</font>.

:: Если задана аннотация, то флаг <font face=Courier>ACC_ANNOTATION</font> должен быть установлен. Если флаг <font face=Courier>ACC_ANNOTATION</font> установлен, то флаг <font face=Courier>ACC_INTERFACE</font> должен также быть установлен. Если флаг <font face=Courier>ACC_INTERFACE</font> для данного <font face=Courier>class</font>-файла сброшен, то допустимо устанавливать любые флаги из таблицы 4.1 за исключением флага <font face=Courier>ACC_ANNOTATION</font>. Однако обратите внимание, что одновременно флаги <font face=Courier>ACC_FINAL</font> и <font face=Courier>ACC_ABSTRACT</font> не могут быть установлены (см. JLS §8.1.1.2)

:: Флаг <font face=Courier>ACC_SUPER</font> указывает, какая из двух альтернативных семантик будет подразумеваться в инструкции ''invokespecial'', если она будет использована в данном <font face=Courier>class</font>-файле. Этот флаг устанавливается компилятором, преобразующим исходный код в байт-код виртуальной машины Java.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Флаг <font face=Courier>ACC_SUPER</font> существует для обратной совместимости с кодом, скомпилированным более старыми компиляторами языка программирования Java. В выпуске JDK release  компании Oracle до версии 1.0.2 компилятор генерировал набор флагов доступа структуры <font face=Courier>ClassFile</font>, без флага <font face=Courier>ACC_SUPER</font>: на его месте могло быть произвольное значение. Установленное значение этого флага виртуальная машина Java, реализованная компанией Oracle, игнорировала, впрочем, как и сброшенное.</span>
|}
<br>
Все биты элемента <font face=Courier>access_flags</font>, не обозначенные в таблице 4.1 зарезервированы для будущего использования. Им должны быть присвоены нулевые значения в <font face=Courier>class</font>-файле, к тому же виртуальная машина Java должна их игнорировать.


<font face=Courier>текущий_класс</font>
:: Значение элемента <font face=Courier>текущий_класс</font> должно быть действительным индексом в таблице <font face=Courier>константных_пулов[]</font>.  Элемент константный_пул  по указанному индексу должен быть структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1), представляющей собой описание класса или интерфейса, определённого данным <font face=Courier>class</font>-файлом.

<font face=Courier>предок</font>
::Для класс, значение элемента предок  должно быть либо нулем, либо действительным индексом в таблице константных_пулов[]. Если значение элемента предок не нулевое, то элемент константный_пул  по указанному индексу должен быть структурой CONSTANT_Class_info (см. §4.4.1), представляющей собой описание непосредственного предка класса, определенного в данном <font face=Courier>class</font>-файле. Ни непосредственный предок, ни предок произвольной глубины не должны иметь установленным флаг <font face=Courier>ACC_FINAL</font> элемента <font face=Courier>access_flags</font> структуры <font face=Courier>ClassFile</font>.

::Если значение элемента предок есть ноль, то <font face=Courier>class</font>-файл должен описывать класс <font face=Courier>Object</font> – единственный класс или интерфейс без непосредственных предков.

::Для интерфейсов значение элемента предок должно всегда быть действительным индексов в таблице <font face=Courier>константных_пулов[]</font>. Элемент <font face=Courier>константный_пул</font>  по указанному индексу должен быть структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1), представляющей собой описание класса <font face=Courier>Object</font>.

<font face=Courier>количество_интерфейсов</font>
:: Значение <font face=Courier>количество_интерфейсов</font> говорит о количестве непосредственных интерфейсов предков данного класса или интерфейса.

<font face=Courier>интерфейсы[]</font>
:: Каждый элемент в массиве <font face=Courier>интерфейсы[]</font> представляет собой действительный индекс в таблице <font face=Courier>константных_пулов[]</font>. Каждый элемент константный_пул соответствующий индексу, взятому из таблицы <font face=Courier>интерфейсы[i]</font>, где 0  ≤  ''i'' <  <font face=Courier>interfaces_count</font>, должен быть структурой <font face=Courier>CONSTANT_Class_info</font> (§4.4.1) представляющей собой интерфейс – прямой предок данного класса или интерфейса. Индексы интерфейсов в массиве <font face=Courier>интерфейсы[]</font> должны соответствовать порядку интерфейсов в исходном коде, если читать слева направо.

<font face=Courier>количество_полей</font>
:: Элемент <font face=Courier>количество_полей</font> определяет число элементов <font face=Courier>field_info</font> в <font face=Courier>таблице поля[]</font>. Структура <font face=Courier>field_info</font> (см. §4.5)  описывает все поля, объявленные в данном классе или интерфейсе: как принадлежащие экземпляру, так и принадлежащие классу.

<font face=Courier>поля[]</font>
:: Каждое значение в таблице <font face=Courier>поля[]</font> должно быть структурой <font face=Courier>field_info</font> (см. §4.5) дающей полное описание поля в классе или интерфейсе. Таблица <font face=Courier>поля[]</font> включает в себя только те поля, которые объявлены в данном классе или интерфейсе. Она не содержит полей, унаследованных от класса-предка или интерфейса предка.

<font face=Courier>количество_методов</font>
:: Содержит число элементов <font face=Courier>method_info</font> в таблице <font face=Courier>методы[]</font>.

<font face=Courier>методы[]</font>
:: Каждый элемент в таблице <font face=Courier>методы[]</font> должен представлять собой структуру <font face=Courier>method_info</font> (§4.6), дающую полное описание метода в классе или интерфейсе. Если флаги <font face=Courier>ACC_NATIVE</font> и  <font face=Courier>ACC_ABSTRACT</font> сброшены в элементе <font face=Courier>access_flags</font>, то структура <font face=Courier>method_info</font> содержит байт-код виртуальной машины <font face=Courier>Java</font>, реализующий метод.

:: Структура <font face=Courier>method_info</font> содержит все методы, объявленные в классе или интерфейсе, включая методы экземпляра, методы класса (статические), инициализирующие методы экземпляра (см. §2.9), а также инициализирующие методы класса или интерфейса (см. §2.9). Таблица <font face=Courier>методы[]</font> не содержит элементы соответствующие унаследованным методам из классов предков или интерфейсов предков.

<font face=Courier>количество_атрибутов</font>
:: Значение соответствует числу элементов в массиве <font face=Courier>атрибуты[]</font>.

<font face=Courier>атрибуты[]</font>
:: Каждый элемент таблицы <font face=Courier>атрибуты[]</font> должен представлять собой структуру <font face=Courier>attribute_info</font> (см. §4.7).

:: Согласно данной спецификации допустимыми атрибутами в таблице <font face=Courier>атрибуты[]</font> структуры <font face=Courier>ClassFile</font> являются: <font face=Courier>InnerClasses</font> (см. §4.7.6),  <font face=Courier>EnclosingMethod</font> (см. §4.7.7),  <font face=Courier>Synthetic</font> (см. §4.7.8), <font face=Courier>Signature</font> (см. §4.7.9),  <font face=Courier>SourceFile</font> (см. §4.7.10),  <font face=Courier>SourceDebugExtension</font> (см. §4.7.<font face=Courier>11</font>),  <font face=Courier>Deprecated</font> (см. §4.7.15),  <font face=Courier>RuntimeVisibleAnnotations</font> (см. §4.7.16), <font face=Courier>RuntimeInvisibleAnnotations</font> (см. §4.7.17) и <font face=Courier>BootstrapMethods</font> (см. §4.7.21).

:: Если реализация виртуальной машины Java определила версию <font face=Courier>class</font>-файла как 49.0 или выше, то следующие атрибуты таблицы атрибуты[]  структуры <font face=Courier>ClassFile</font> должны быть корректно распознаны и прочитаны: <font face=Courier>Signature</font> (см.§4.7.9),  <font face=Courier>RuntimeVisibleAnnotations</font> (см. §4.7.16), и <font face=Courier>RuntimeInvisibleAnnotations</font> (см. §4.7.17).

:: Если реализация виртуальной машины Java определила версию <font face=Courier>class</font>-файла как 51.0 или выше, то  атрибут <font face=Courier>BootstrapMethods</font> (§4.7.21) таблицы <font face=Courier>атрибуты[]</font>  структуры <font face=Courier>ClassFile</font> должен быть корректно распознан и прочитан.

:: Реализация виртуальной машины Java должна игнорировать без сообщений об ошибках все атрибуты таблицы <font face=Courier>атрибуты[]</font>  структуры <font face=Courier>ClassFile</font>, которые она не может распознать. Атрибуты не определённые данной спецификацией не должны влиять на семантику <font face=Courier>class</font>-файла, они могут содержать лишь описательную информацию (см. §4.7.1).

<br><br><br><br>

=== Внутренняя форма имён ===

==== Имена двоичных классов и интерфейсов ====

Имена классов и интерфейсов, находящиеся в структурах <font face=Courier>class</font>-файла, представлены всегда в полной форме в качестве ''двоичных имен'' (см. JLS §13.1). Имена хранятся в структурах <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7) и поэтому там, где это не оговорено особо, для формирования имен могут быть использованы все символы таблицы Unicode. На имена классов и интерфейсов допустимо ссылаться из тех структур <font face=Courier>CONSTANT_NameAndType_info</font> (см. §4.4.6), которые содержать имена в качестве части своего дескриптора (см. §4.3), а также из всех структур <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1).

По историческим причинам синтаксис двоичных имён в структурах <font face=Courier>class</font>-файла отличается от синтаксиса, документированного в JLS §13.1. Символ ASCII  ('.'), используемый в качестве разделителя в двоичном имени в спецификации JLS §13.1, заменён символом ASCII ('/') в двоичном имени в  структурах <font face=Courier>class</font>-файла. Имена идентификаторов хранятся в сокращённой форме, без имени указания имён пакетов и классов.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Например, стандартное двоичное имя класса <font face=Courier>Thread</font> это <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>Thread</font>. Во внутренней форме, в дескрипторах <font face=Courier>class</font>-файла ссылка на имя класса <font face=Courier>Thread</font> реализована как структура <font face=Courier>CONSTANT_Utf8_info</font>, содержащая строку "<font face=Courier>java</font>/<font face=Courier>lang</font>/<font face=Courier>Thread</font>".</span>
|}

<br><br><br><br>
==== Сокращенная форма имен ====

Имена методов, полей и локальных переменных хранятся в ''сокращённой форме'' (без указания имён пакетов). Имена в сокращённой форме не должны содержать следующие ASCII символы таблицы Unicode: '.', ';', '[' или '/'.
Имена методов в дополнение ограничены еще и тем, что не могут содержать (за исключением имен методов <font face=Courier><init></font> и  <font face=Courier><clinit></font>, см. §2.9) ASCII символы таблицы Unicode '<' либо '>'.

Обратите внимание, что имя поля или метода интерфейса может быть <font face=Courier><init></font> либо  <font face=Courier><clinit></font>, однако вызывать метод <font face=Courier><clinit></font> посредством инструкций запрещено. Метод <font face=Courier><init></font> может вызывать только инструкция ''invokespecial''.

<br><br><br><br>

=== Дескрипторы и сигнатуры ===

''Дескриптор'' – это строка, описывающая тип поля или метода. Дескрипторы в <font face=Courier>class</font>-файле хранятся в виде модифицированных строк UTF-8 (см. §4.4.7) и поэтому могут быть представлены там, где это не оговорено особо, символами Unicode.

''Сигнатура'' – это строка, содержащая общую информацию о типе поля или метода, а также информацию о классе.

<br><br><br><br>
==== Грамматика обозначений дескрипторов и сигнатур ====

Дескрипторы и сигнатуры определяются с помощью грамматики. Грамматика представляет собой набор порождающих правил, которые описывают, как из последовательности символов может быть получено синтаксически правильный дескриптор для различных типов. Терминальные символы грамматики, показаны <font face=Courier>моноширинным</font> шрифтом. Нетерминальные символы показаны ''курсивом''. Определение нетерминального символа вводится с помощью имени нетерминального символа и следующего за ним двоеточия. Одна альтернатив для правых частей определения располагаются правее нетерминального символа на отдельных строках. Например, в порождающем правиле 

 ''FieldType'':
    ''BaseType''
    ''ObjectType''
    ''ArrayType''

утверждается, что значение ''FieldType'' может быть представлено ''BaseType'', ''ObjectType'' или ''ArrayType''.

Если после нетерминального символа с правой стороны без пробелов стоит символ звёздочки (*), то это значит, что нетерминальный символ может быть повторен с различными значениями ноль и более раз (без пробелов между повторениями). Аналогично, если после нетерминального символа с правой стороны без пробелов стоит символ плюса (+), то это значит, что нетерминальный символ должен присутствовать один или более раз (без пробелов между повторениями). В порождающем правиле 

 ''MethodDescriptor'':
    <font face=Courier>(</font>''ParameterDescriptor''*<font face=Courier>)</font>''ReturnDescriptor''

утверждается, что значение ''MethodDescriptor'' представляет собой открывающуюся круглую скобку, за которой следует ноль или более значений ''ParameterDescriptor'', за которыми следует закрывающаяся круглая скобка, а затем значение ''ReturnDescriptor''.

<br><br><br><br>
==== Дескрипторы поля ====

Дескриптор поля описывает типы классов, экземпляров или локальных переменных. Он представляет собой последовательность символов, удовлетворяющую правилам грамматики:

 ''FieldDescriptor'':
     ''FieldType''	    
  
 ''ComponentType'':
    ''FieldType''	
 
 ''FieldType'':
     ''BaseType''
     ''ObjectType''
     ''ArrayType ''
  
  ''BaseType'':
    <font face=Courier>B</font>
    <font face=Courier>C</font>
    <font face=Courier>D</font>
    <font face=Courier>F</font>
    <font face=Courier>I</font>
    <font face=Courier>J</font>
    <font face=Courier>S</font>
    <font face=Courier>Z</font>
  
  ''ObjectType'':
    <font face=Courier>L</font>''Classname'';
  
  ''ArrayType'':
    <font face=Courier>[</font>''ComponentType''

Символы ''BaseType''   <font face=Courier>L</font> и ; правила ''ObjectType'', а также символ <font face=Courier>[</font> правила ''ArrayType'' являются ASCII символами. ''Classname'' представляет собой имя двоичного класса или интерфейса во внутренней форме (см. §4.2.1). Дескриптор типа, соответствующий массиву, действителен только, если число размерностей массива меньше или равно 255. В таблице 4.2 представлено описание символов типов полей.

'''Таблица 4.2. -  Описание символов типов полей'''
{| border="1" style="border-collapse:collapse"
! Символ базового типа
! Полное название типа
! Описание
|-
| <font face=Courier>B</font>
| <font face=Courier>byte</font>
| Знаковый байт
|-
| <font face=Courier>C</font>
| <font face=Courier>char</font>
| Символ Unicode в кодировке UTF-16
|-
| <font face=Courier>D</font>
| <font face=Courier>double</font>
| значение с плавающей точкой двойной точности
|-
| <font face=Courier>F</font>
| <font face=Courier>float</font>
| значение с плавающей точкой одинарной точности
|-
| <font face=Courier>I</font>
| <font face=Courier>int</font>
| Целое значение
|-
| <font face=Courier>J</font>
| <font face=Courier>long</font>
| Длинное целое
|-
| <font face=Courier>L</font>Classname;
| <font face=Courier>reference</font>
| Экземпляр класса ''Classname''
|-
| <font face=Courier>S</font>
| <font face=Courier>short</font>
| Короткое целое
|-
| <font face=Courier>Z</font>
| <font face=Courier>Boolean</font>
| <font face=Courier>true</font> или <font face=Courier>false</font>
|-
| <font face=Courier>[</font>
| <font face=Courier>reference</font>
| Одно измерение массива
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Например, дескриптор переменной экземпляра типа <font face=Courier>int</font> это просто <font face=Courier>I</font>.</span>
<span style="font-size:88%">Дескриптор переменной экземпляра типа <font face=Courier>Object</font> это <font face=Courier>Ljava</font>/<font face=Courier>lang</font>/<font face=Courier>Object</font>; Обратите внимание, что используется внутренняя форма двоичного имени класса <font face=Courier>Object</font>.</span>

<span style="font-size:88%">Дескриптор переменной экземпляра, являющейся многомерным массивом элементов <font face=Courier>double</font><span>
<syntaxhighlight lang="java">double d[][][];</syntaxhighlight>

<span style="font-size:88%">это</span>

 [[[D
|}

<br><br><br><br>

==== Дескрипторы методов ====

''Дескриптор метода ''описывает входные параметры метода, а также возвращаемое значение:

 ''MethodDescriptor'':
    <font face=Courier>(</font>''ParameterDescriptor''*<font face=Courier>)</font>''ReturnDescriptor''

''Дескриптор параметров'' описывает входные параметры, передаваемые методу:

 ''ParameterDescriptor'':
   ''FieldType''

''Дескриптор возвращаемого значения'' описывается следующими правилами грамматики:

 ''ReturnDescriptor'':
   ''FieldType''
   ''VoidDescriptor''
 
 ''VoidDescriptor'':
    	    <font face=Courier>V</font>

Символ <font face=Courier>V</font> означает, что метод не возвращает значения (его тип <font face=Courier>void</font>).

Дескриптор метода класса или интерфейса действителен только, если общее число входных параметров метода (с учётом неявного параметра <font face=Courier>this</font>) меньше либо равно 255. При этом каждое вхождение параметра увеличивает счётчик параметров на единицу, если тип параметра не равен <font face=Courier>long</font> или <font face=Courier>double</font>. В случае если тип параметра равен <font face=Courier>long</font> или <font face=Courier>double</font>, счётчик увеличивается на две единицы.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Например, дескриптор метода</span>

<syntaxhighlight lang="java">Object mymethod(int i, double d, Thread t)</syntaxhighlight>

<span style="font-size:88%">есть</span>

 (IDLjava/lang/Thread;)Ljava/lang/Object;

<span style="font-size:88%">Обратите внимание, что в дескрипторе метода используется внутренняя форма двоичных имен классов <font face=Courier>Thread</font>  и <font face=Courier>Object</font>.</span>

<span style="font-size:88%">Дескриптор метода <font face=Courier>mymethod</font> одинаков, вне зависимости от того принадлежит ли метод классу или экземпляру. И хотя методу экземпляра в дополнение к явным параметрам передаётся неявный параметр <font face=Courier>this</font> – ссылка на текущий экземпляр – этот факт не влияет на дескриптор метода. Ссылка <font face=Courier>this</font> передается неявно при выполнении инструкции, которая вызывает метод экземпляра. Эта инструкция принадлежит набору инструкции виртуальной машины Java. Ссылка <font face=Courier>this</font> не передаётся методу класса.</span>
|}
<br>

<br><br><br><br>

==== Сигнатуры ====

Сигнатуры используются для кодирования типов языка программирования Java, которые не принадлежат системе типов виртуальной машины Java, таких как обобщённые ссылочные типы (<font face=Courier>generic</font>) и обобщённые объявления методов,  а также параметризированные типы. За более подробной информацией читатель отсылается к ''Спецификации языка программирования Java SE 7 Edition''.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Данная информация необходима для поддержки методов рефлексии, отладки и также необходима при работе компилятора.</span>
|}
<br>
Далее терминальный символ ''Identifier'' используется для обозначения имени типа, поля, локальной переменной, параметра, метода или имени переменной типа. Имя генерируется компилятором Java. Такое имя не должно содержать символы «.», «;», «[», «/», «<», «>», или «:», но может содержать символы, запрещённые к использованию в идентификаторах языка программирования Java.

Сигнатура класса, заданная правилом ''ClassSignature'', используется для определения информации о типе объявления класса. Она описывает все формальные параметры, которые класс должен иметь, а также содержит список из класса-предка и интерфейсов - предков (также возможно параметризованных), если таковые имеются.

 ''ClassSignature'':
    ''FormalTypeParameters<sub>opt</sub> SuperclassSignature SuperinterfaceSignature''*

Правило ''FormalTypeParameter'' (тип формального параметра) задаётся именем параметра, за которым за которым следует класс или интерфейс. Если класс или интерфейс не задан, он считается равным <font face=Courier>Object</font>.

 ''FormalTypeParameters'':
    <font face=Courier><</font>''FormalTypeParameter''<font face=Courier>+</font> <font face=Courier>></font>
 
 ''FormalTypeParameter'':
    ''Identifier ClassBound InterfaceBound''*
 
 ''ClassBound'':
     : ''FieldTypeSignature<sub>opt</sub>''
 
 ''InterfaceBound'':
     : ''FieldTypeSignature''
 
 ''SuperclassSignature'':
    ''ClassTypeSignature''
 
 ''SuperinterfaceSignature'':
     ''ClassTypeSignature''


Сигнатура типа поля, определённая правилом ''FieldTypeSignature'', задает тип поля (возможно параметризированный), параметра или локальной переменной.

 ''FieldTypeSignature'':
     ''ClassTypeSignature'' 
     ''ArrayTypeSignature''
     ''TypeVariableSignature''

	Сигнатура типа класса даёт полную информацию о типе класса или интерфейса. Сигнатура типа класса должна быть задана таким образом, чтобы однозначно соответствовать бинарному имени класса, после удаления из сигнатуры всех типов аргументов и замене каждого символа «.» в сигнатуре на символ «$». 

 ''ClassTypeSignature'':
    <font face=Courier>L</font>''PackageSpecifieropt SimpleClassTypeSignature ClassTypeSignatureSuffix''*;
 
 ''PackageSpecifier'':
    ''Identifier / PackageSpecifier''*
 
 ''SimpleClassTypeSignature'':
    ''Identifier TypeArguments<sub>opt</sub>''
 
 ''ClassTypeSignatureSuffix'':
     . ''SimpleClassTypeSignature''
 
 ''TypeVariableSignature'':
    <font face=Courier>T</font>''Identifier'' ;
 
 ''TypeArguments'':
    <font face=Courier><</font>''TypeArgument''<font face=Courier>+</font> <font face=Courier>></font>
 
 ''TypeArgument'':
    ''WildcardIndicator<sub>opt</sub> FieldTypeSignature''
    *
 
 ''WildcardIndicator'':
    +
    -
 
 ''ArrayTypeSignature'':
    <font face=Courier>[</font>''TypeSignature''
 
 ''TypeSignature'':
    ''FieldTypeSignature''
    ''BaseType''

Сигнатура метода, определённая правилом ''MethodTypeSignature'', задает (возможно, параметризированные) типы формальных аргументов метода, тип исключения (также возможно параметризированный) во фразе <font face=Courier>throws</font>, а также тип возвращаемого значения.

 ''MethodTypeSignature'':
    ''FormalTypeParameters<sub>opt</sub>'' <font face=Courier>(</font>''TypeSignature''*<font face=Courier>)</font> ''ReturnType ThrowsSignature''*
 
 ''ReturnType'':
    ''TypeSignature''
  ''VoidDescriptor''
 
 ''ThrowsSignature'':
    <font face=Courier>^</font> ''ClassTypeSignature''
    <font face=Courier>^</font> ''TypeVariableSignature''


Если фраза <font face=Courier>throws</font> метода или конструктора отсутствует, то ''ThowsSignature'' может быть опущено из ''MethodTypeSignature''.
Компилятор Java должен генерировать сигнатуры соответствующие обобщённым типам классов, интерфейсов, конструкторов и методов.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Сигнатура и дескриптор (см. §4.3.3) данного метода или конструктора могут не соответствовать друг другу точно. В частности, число элементов ''TypeSignature'', которые описывают формальные аргументы в ''MethodTypeSignature'', может быть меньшим, чем число элементов ''ParameterDescriptor'' в ''MethodDescriptor''.</span>

<span style="font-size:88%">Реализация виртуальной машины компании Oracle не проверяет при загрузке и компоновке корректность сигнатур, описанных в данном разделе. Вместо этого проверка откладывается до тех пор, пока сигнатуры не будут использованы методами рефлексии, определёнными в классе <font face=Courier>Class</font> или в <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>reflect</font>. Будущие версии реализации виртуальной машины Java возможно будут проводить все или некоторые проверки корректности сигнатур во время загрузки или компоновки.</span>
|}
<br>

<br><br><br><br>
=== Константный пул ===

Инструкции виртуальной машины Java не ссылаются на непосредственное положение в памяти классов, интерфейсов, экземпляров классов и массивов. Вместо этого инструкции используют символьные ссылки из таблицы <font face=Courier>constant_pool</font>.

Все элементы таблицы <font face=Courier>constant_pool</font> имеют следующий общий формат:

 cp_info {
    u1 tag;
    u1 info[];
    }

Каждый элемент в таблице <font face=Courier>constant_pool</font> должен начинаться с однобайтного тега, определяющего разновидности элемента <font face=Courier>cp_info</font>. Содержание массива <font face=Courier>info</font> меняется в зависимости от значения байта <font face=Courier>tag</font>. Теги и их значения приведены в таблице 4.3. За каждым тегом следует два или более байта, содержащих значение конкретной константы. Формат константы также меняется в зависимости от тега.

'''Таблица 4.3 Теги константного пула'''
{| border="1" style="border-collapse:collapse"
! Constant Type
! Value
|-
| <font face=Courier>CONSTANT_Class</font>
| 7
|-
| <font face=Courier>CONSTANT_Fieldref</font>
| 9
|-
| <font face=Courier>CONSTANT_Methodref</font>
| 10
|-
| <font face=Courier>CONSTANT_InterfaceMethodref</font>
| 11
|-
| <font face=Courier>CONSTANT_String</font>
| 8
|-
| <font face=Courier>CONSTANT_Integer</font>
| 3
|-
| <font face=Courier>CONSTANT_Float</font>
| 4
|-
| <font face=Courier>CONSTANT_Long</font>
| 5
|-
| <font face=Courier>CONSTANT_Double</font>
| 6
|-
| <font face=Courier>CONSTANT_NameAndType</font>
| 12
|-
| <font face=Courier>CONSTANT_Utf8</font>
| 1
|-
| <font face=Courier>CONSTANT_MethodHandle</font>
| 15
|-
| <font face=Courier>CONSTANT_MethodType</font>
| 16
|-
| <font face=Courier>CONSTANT_InvokeDynamic</font>
| 18
|}

<br><br><br><br>
==== Структура <font face=Courier>CONSTANT_Class_info</font> ====

Структура <font face=Courier>CONSTANT_Class_info</font> используется для описания класса или интерфейса.

 CONSTANT_Class_info {
    u1 tag;
    u2 name_index;
    }

Элементы структуры <font face=Courier>CONSTANT_Class_info</font> следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> имеет значение <font face=Courier>CONSTANT_Class</font> (7).

<font face=Courier>name_index</font>
:: Элемент <font face=Courier>name_index</font> должен быть действительным индексом элемента таблицы <font face=Courier>constant_pool</font>. Содержимое этого элемента должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей корректное двоичное имя класса или интерфейса во внутренней форме (см. §4.2.1).

	Поскольку массивы являются объектами, инструкции ''anewarray'' и ''multianewarray'' посредством структуры <font face=Courier>CONSTANT_Class_info</font> ссылаются на «классы» в таблице <font face=Courier>constant_pool</font>. Для таких массивов-классов имя класса – это дескриптор типа массива.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Например, имя класса, представляющего двумерный массив целочисленных значений</span>

<syntaxhighlight lang="java">int[][]
</syntaxhighlight>

<span style="font-size:88%">есть</span>

 [[I

<span style="font-size:88%">Имя класса, представляющего массив потоков (класс <font face=Courier>Thread</font>)</span>

<syntaxhighlight lang="java">Thread[]
</syntaxhighlight> 

<span style="font-size:88%">есть</span>

 [Ljava/lang/Thread;

|}

Дескриптор массива действителен, только если представляет массив, содержащий 255 или менее измерений.

<br><br><br><br>

==== Структуры <font face=Courier>CONSTANT_Fieldref_info</font>, <font face=Courier>CONSTANT_Methodref_info</font> и <font face=Courier>CONSTANT_InterfaceMethodref_info</font> ====

Поля классов, методы экземпляров и методы интерфейсов описываются похожими структурами:

 CONSTANT_Fieldref_info {
    u1 tag;
    u2 class_index;
    u2 name_and_type_index;
    }
 
 CONSTANT_Methodref_info {
    u1 tag;
    u2 class_index;
    u2 name_and_type_index;
    }
 
 CONSTANT_InterfaceMethodref_info {
     u1 tag;
     u2 class_index;
     u2 name_and_type_index;
     }

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_Fieldref_info</font> имеет значение <font face=Courier>CONSTANT_Fieldref(9)</font>.

:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_Methodref_info</font> имеет значение <font face=Courier>CONSTANT_Methodref(10)</font>.

:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_InterfaceMethodref_info</font> имеет значение <font face=Courier>CONSTANT_InterfaceMethodref(11)</font>.

<font face=Courier>class_index</font>
:: Элемент <font face=Courier>class_index</font> должен быть действительным индексом элемента таблицы <font face=Courier>constant_pool</font>. Содержимое этого элемента должно быть структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1), представляющей корректное двоичное имя класса или интерфейса, которому принадлежит поле или метод.

:: Элемент <font face=Courier>class_index</font> в структуре <font face=Courier>CONSTANT_Methodref_info</font> должен указывать на класс, не на интерфейс.

:: Элемент <font face=Courier>class_index</font> в структуре <font face=Courier>CONSTANT_InterfaceMethodref_info</font> должен указывать на интерфейс.

:: Элемент <font face=Courier>class_index</font> в структуре <font face=Courier>CONSTANT_Fieldref_info</font> может указывать как на класс, так и на интерфейс.

<font face=Courier>name_and_type_index</font>
:: Элемент <font face=Courier>name_and_type_index</font> должен быть действительным индексом элемента таблицы <font face=Courier>constant_pool</font>. Содержимое этого элемента должно быть структурой <font face=Courier>CONSTANT_NameAndType_info</font> (см. §4.4.6). Струкутруа содержит имя и дескриптор поля или метода.

:: Для структуры <font face=Courier>CONSTANT_Fieldref_info</font> упомянутый ранее дескриптор должен быть дескриптором поля (см. §4.3.2). Для двух остальных случае – дескриптором метода (см. §4.3.3).

:: Если имя метода в структуре <font face=Courier>CONSTANT_Methodref_info</font> начинается с «<» («\u003c»), то это должно быть специальное имя <font face=Courier><init></font>, принадлежащее инициализирующему методу экземпляра (см. §2.9). Тип возвращаемого значения такого метода должен быть пустым (<font face=Courier>void</font>).

<br><br><br><br>
==== Структура <font face=Courier>CONSTANT_String_info</font> ====

Структура <font face=Courier>CONSTANT_String_info</font> используется для описания объектов типа <font face=Courier>String</font>:

 CONSTANT_String_info {
    u1 tag;
    u2 string_index;
    }

Элементы структуры <font face=Courier>CONSTANT_String_info</font> следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_String_info</font> имеет значение <font face=Courier>CONSTANT_String(8)</font>.

<font face=Courier>string_index</font>
:: Значение элемента <font face=Courier>string_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Элемент таблицы <font face=Courier>constant_pool</font> с упомянутым индексом должен быть структурой <font face=Courier>CONSTANT_Utf8_info</font>(см. §4.4.7), представляющей последовательность символов Unicode, которыми инициализируется объект <font face=Courier>String</font>.

<br><br><br><br>
==== Структуры <font face=Courier>CONSTANT_Integer_info</font> и <font face=Courier>CONSTANT_Float_info</font> ====

Структуры <font face=Courier>CONSTANT_Integer_info</font> и <font face=Courier>CONSTANT_Float_info</font> представляют собой 4-х байтные числовые (<font face=Courier>int</font> и <font face=Courier>float</font>) константы:

 CONSTANT_Integer_info {
    u1 tag;
    u4 bytes;
    }
 
 CONSTANT_Float_info {
    u1 tag;
    u4 bytes;
    }

Элементы этих структур следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_Integer_info</font> имеет значение <font face=Courier>CONSTANT_Integer</font>(3).

:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_Float_info</font> имеет значение <font face=Courier>CONSTANT_Float</font>(4).

<font face=Courier>bytes</font>
:: Элемент <font face=Courier>bytes</font> структуры <font face=Courier>CONSTANT_Integer_info</font> представляет собой значение константы с типом <font face=Courier>int</font>. Байты значения хранятся в порядке от старшего к младшему.

:: Элемент <font face=Courier>bytes</font> структуры <font face=Courier>CONSTANT_Float_info</font> представляет собой значение константы типа <font face=Courier>float</font> одинарной точности в формате <font face=Courier>IEEE</font> 754 (см. §2.3.2). Байты значения хранятся в порядке от старшего к младшему.

:: Значение, задаваемое константой <font face=Courier>CONSTANT_Float_info</font>, определяется следующим образом. Байты значения сначала рассматриваются как набор битов величины с типом <font face=Courier>int</font>. Затем:

* Если ''набор битов'' равен <font face=Courier>0x7f800000</font>, то значение типа <font face=Courier>float</font> равно положительной бесконечности.
* Если ''набор битов'' равен <font face=Courier>0xff800000</font>, то значение типа <font face=Courier>float</font> равно отрицательной бесконечности.
* Если ''набор битов'' лежит в пределах от <font face=Courier>0x7f800001</font> до <font face=Courier>0x7fffffff</font> или от <font face=Courier>0xff800001</font> до <font face=Courier>0xffffffff</font>, то значение типа <font face=Courier>float</font> равно не числу NaN.
* Во всех остальных случаях из набора бит вычисляются три величины <font face=Courier>s</font>,  <font face=Courier>e</font> и <font face=Courier>m</font>:

<syntaxhighlight lang="java">int s = ((bits>> 31) == 0) ? 1 : -1;
int e = ((bits>> 23) & 0xff);
int m = (e == 0) ?
(bits& 0x7fffff) << 1 :
(bits& 0x7fffff) | 0x800000; 
</syntaxhighlight>

Тогда значение типа <font face=Courier>float</font> равно математическому выражению <font face=Courier>s·m·2<sup>e-150</sup></font>.

<br><br><br><br>

==== Структуры <font face=Courier>CONSTANT_Long_info</font> и <font face=Courier>CONSTANT_Double_info</font> ====

Структуры <font face=Courier>CONSTANT_Long_info</font> и <font face=Courier>CONSTANT_Double_info</font> представляют 8-байтовые числовые (<font face=Courier>long</font> и <font face=Courier>double</font>) константы:

 CONSTANT_Long_info {
    u1 tag;
    u4 high_bytes;
    u4 low_bytes;
    }
 
 CONSTANT_Double_info {
    u1 tag;
    u4 high_bytes;
    u4 low_bytes;
    }

Все 8-байтовые константы хранятся в двух элементах таблицы <font face=Courier>constant_pool</font> в <font face=Courier>class</font>-файле. Если структура <font face=Courier>CONSTANT_Long_info</font> или <font face=Courier>CONSTANT_Double_info</font> является элементом таблицы <font face=Courier>constant_pool</font> с индексом ''n'', то следующий элемент константного пула расположен по индексу ''n''+2. Индекс ''n''+1 таблицы <font face=Courier>constant_pool</font> является действительным, но не используется для ссылок на него.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Оглядываясь назад, можно сделать вывод, что данное решение было не совсем удачным.</span>
|}
<br>
Элементы этих структур следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_Long_info</font> имеет значение <font face=Courier>CONSTANT_Long</font>(5).

:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_Double_info</font> имеет значение <font face=Courier>CONSTANT_Double</font>(6).

<font face=Courier>high_bytes</font>, <font face=Courier>low_bytes</font>
::Беззнаковые элементы <font face=Courier>high_bytes</font> и <font face=Courier>low_bytes</font> структуры <font face=Courier>CONSTANT_Long_info</font> вместе представляют значение константы с типом <font face=Courier>long</font>

<syntaxhighlight lang="java">((long) high_bytes << 32) + low_bytes   
</syntaxhighlight>

:: где байты каждого из элементов <font face=Courier>high_bytes</font> и <font face=Courier>low_bytes</font> хранятся в порядке от старшего к младшему.

:: Беззнаковые элементы <font face=Courier>high_bytes</font> и <font face=Courier>low_bytes</font> структуры <font face=Courier>CONSTANT_Double_info</font> вместе представляют значение константы с типом <font face=Courier>double</font> двойной точности в формате <font face=Courier>IEEE</font> 754 (см. §2.3.2). Байты значения хранятся в порядке от старшего к младшему.

:: Значение, задаваемое константой <font face=Courier>CONSTANT_Double_info</font>, определяется следующим образом. Байты значения сначала рассматриваются как ''набор битов'' величины с типом <font face=Courier>long</font>, который равен:

<syntaxhighlight lang="java">((long) high_bytes << 32) + low_bytes  
</syntaxhighlight>

:: Затем:

* Если набор битов равен <font face=Courier>0x7ff0000000000000L</font>, то значение типа <font face=Courier>double</font> равно положительной бесконечности.
* Если набор битов равен <font face=Courier>0xfff0000000000000</font>, то значение типа <font face=Courier>double</font> равно отрицательной бесконечности.
* Если набор битов лежит в пределах от <font face=Courier>0x7ff0000000000001L</font> до <font face=Courier>0x7fffffffffffffffL</font> или от <font face=Courier>0xfff0000000000001L</font> до <font face=Courier>0xffffffffffffffffL</font>, то значение типа <font face=Courier>double</font> равно не числу NaN.
* Во всех остальных случаях из ''набора бит'' вычисляются три величины <font face=Courier>s</font>,  <font face=Courier>e</font> и <font face=Courier>m</font>:

<syntaxhighlight lang="java">int s = ((bits>> 63) == 0) ? 1 : -1;
int e = (int)((bits>> 52) & 0x7ffL);
long m = (e == 0) ?
(bits& 0xfffffffffffffL) << 1 :
(bits& 0xfffffffffffffL) | 0x10000000000000L;   
</syntaxhighlight>

Тогда значение типа <font face=Courier>double</font> равно математическому выражению <font face=Courier>s·m·2<sup>e-1075</sup></font>.

<br><br><br><br>
==== Структура <font face=Courier>CONSTANT_NameAndType_info</font> ====

Структура <font face=Courier>CONSTANT_NameAndType_info</font> используется для представления имени поля или метода без указания того, к какому классу принадлежит поле или метод:

 CONSTANT_NameAndType_info {
    u1 tag;
    u2 name_index;
    u2 descriptor_index;
    }

Элементы структуры <font face=Courier>CONSTANT_NameAndType_info</font> следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_NameAndType_info</font> имеет значение <font face=Courier>CONSTANT_NameAndType</font>(12).

<font face=Courier>name_index</font>
:: Элемент <font face=Courier>name_index</font> должен быть действительным индексом элемента таблицы <font face=Courier>constant_pool</font>. Содержимое этого элемента должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей имя инициализирующего метода <font face=Courier><init></font> (см. §2.9) либо имя обычного метода или поля в сокращенной форме (см. §4.2.2).

<font face=Courier>descriptor_index</font>
:: Значение элемента <font face=Courier>descriptor_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Элемент <font face=Courier>constant_pool</font> с указанным индексом представляет собой структуру <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7) – действительный дескриптор поля (см. §4.3.2) или метода (см. §4.3.3).

<br><br><br><br>
==== Структура <font face=Courier>CONSTANT_Utf8_info</font> ====

Структура <font face=Courier>CONSTANT_Utf8_info</font> используется для представления строковых значений:

 CONSTANT_Utf8_info {
    u1 tag;
    u2 length;
    u1 bytes[length];
    }

Элементы структуры <font face=Courier>CONSTANT_NameAndType_info</font> следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_Utf8_info</font> имеет значение <font face=Courier>CONSTANT_Utf8</font> (1).

<font face=Courier>length</font>
:: Значение элемента <font face=Courier>length</font> содержит число байт в массиве <font face=Courier>bytes</font> (обратите внимание, что это не длина результирующей строки). Строки в структуре <font face=Courier>CONSTANT_Utf8_info</font> не являются нуль-терминированными.

<font face=Courier>bytes[]</font>
:: Массив <font face=Courier>bytes[]</font> содержит собственно байты, из которых состоит строка. Ни один из байтов не должен принимать значение <font face=Courier>(byte)0</font> и лежать в диапазоне <font face=Courier>(byte)0xf0</font> - <font face=Courier>(byte)0xff</font>

Содержимое строки хранится в модифицированном формате UTF-8. Модифицированный формат UTF-8 позволяет хранить не нулевые ASCII символы, используя при этом только один байт. Все символы Unicode представимы в модифицированном формате UTF-8.

* Символы в интервале от «<font face=Courier>\u0001</font>» до «<font face=Courier>\u007</font>» хранятся в одном байте:

{|border="1" style="border-collapse:collapse; margin-left: 23px;" width="85%"
| ''0''
| ''биты 6-0''
|}

: 7 бит представляют собой значение символа.

* Нулевой символ («<font face=Courier>\u0000</font>») и символы в интервале от «<font face=Courier>\u0080</font>» до «<font face=Courier>\u07FF</font>» хранятся в двух байтах <font face=Courier>x</font> и <font face=Courier>y</font>:

{| border="1" style="border-collapse:collapse; margin-left: 23px;" width="85%"
| y:
| 1
| 1
| 1
| биты 10-6 
|-
| y:
| 1
| 0
| colspan="5"| биты 5-0 
|}

: Байты соответствуют символу, чей код равен:

<syntaxhighlight lang="java">((x & 0x1f) << 6) + (y & 0x3f)   
</syntaxhighlight>

* Символы в интервале от «<font face=Courier>\u0800</font>» до «<font face=Courier>\uFFFF</font>» хранятся в трех байтах <font face=Courier>x</font>, <font face=Courier>y</font> и <font face=Courier>z</font>:

{| border="1" style="border-collapse:collapse; margin-left: 23px;" width="85%"
| y:
| 1
| 1
| 1
| 0
| биты 15-12
|-
| y:
| 1
| 0
|colspan="5" | биты 11-6 
|-
| z:
| 1
| 0
|colspan="5" |биты 5-0
|}

: Байты соответствуют символу, чей код равен:

<syntaxhighlight lang="java">((x & 0xf) << 12) + ((y & 0x3f) << 6) + (z & 0x3f)   
</syntaxhighlight>

* Символы с кодом выше U+FFFF (так называемые дополнительные символы) представлены двумя псевдо-символами из их представления в UTF-16. Каждый псевдо-символ состоит из трех байт, что означает, что каждый дополнительный символ занимает шесть байт <font face=Courier>u</font>, <font face=Courier>v</font>, <font face=Courier>w</font>, <font face=Courier>x</font>, <font face=Courier>y</font> и <font face=Courier>z</font>:

{| border="1" style="border-collapse:collapse; margin-left: 23px;" width="85%"
| u:
| 1
| 1
| 1
| 0
| 1
| 1
| 0
| 1
|-
| v:
| 1
| 0
| 1
| 0
| colspan="6" |(биты 20-16)-1 
|-
| w:
| 1
| 0
|colspan="6"| биты 15-10 
|-
| x:
| 1
| 1
| 1
| 0
| 1
| 1
| 0
| 1
|-
| y:
| 1
| 0
| 1
| 1
|colspan="5"|биты 9-6 
|-
| z:
| 1
| 0
| colspan="6"|биты 5-0 
|}

: Байты соответствуют символу, чей код равен:

<syntaxhighlight lang="java">0x10000 + ((v & 0x0f) << 16) + ((w & 0x3f) << 10) +
((y & 0x0f) << 6) + (z & 0x3f)   
</syntaxhighlight>

: Байты хранятся в <font face=Courier>class</font>-файле в порядке от старшего к младшему.

Существует два отличия между данным форматом и «стандартным» форматом UTF-8. Во-первых, нулевой символ <font face=Courier>(char)0</font> кодируется с помощью двух байт, а не одного, так что строки в модифицированном UTF-8 формате не имеют внедрённых нулей. Во-вторых, из стандартного UTF-8  используются только символы, кодируемые одним, двумя или тремя байтами. Виртуальная машина Java не использует четырёх байтный формат стандартного UTF-8. Вместо него используется собственный формат из шести байтов.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Более подробную информацию по формату UTF-8 смотрите в разделе 3.9 стандарта ''Unicode Encoding Forms of The Unicode Standard, Version 6.0.0''.</span>
|}

<br><br><br><br>

==== Структура <font face=Courier>CONSTANT_MethodHandle_info</font> ====

Структура <font face=Courier>CONSTANT_MethodHandle_info</font> используется для представления обработчика метода:

 CONSTANT_MethodHandle_info {
    u1 tag;
    u1 reference_kind;
    u2 reference_index;
    }

Элементы структуры <font face=Courier>CONSTANT_MethodHandle_info</font> следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_MethodHandle_info</font> имеет значение <font face=Courier>CONSTANT_MethodHandle</font>(15).

<font face=Courier>reference_kind</font>
:: Значение элемента <font face=Courier>reference_kind</font> должно быть в пределах от 1 до 9. Элемент определяет ''разновидность'' обработчика метода, которая характеризирует исполняемый байт-код (см. §5.4.3.5). 

<font face=Courier>reference_index</font>
:: Значение элемента <font face=Courier>reference_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>.

:: Если значение элемента <font face=Courier>reference_kind</font> равно 1 (<font face=Courier>REF_getField</font>), 2 (<font face=Courier>REF_getStatic</font>), 3 (<font face=Courier>REF_putField</font>) или 4 (<font face=Courier>REF_putStatic</font>), то значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Fieldref_info</font> (см. §4.4.2), представляющей поле, для которого создаётся обработчик метода.

:: Если значение элемента <font face=Courier>reference_kind</font> равно 5 (<font face=Courier>REF_invokeVirtual</font>), 6 (<font face=Courier>REF_invokeStatic</font>), 7 (<font face=Courier>REF_invokeSpecial</font>) или 8 (<font face=Courier>REF_newInvokeSpecial</font>), то значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Methodref_info</font> (см. §4.4.2), представляющей метод класса (см. §2.9) или конструктор, для которого создается обработчик метода.

:: Если значение элемента <font face=Courier>reference_kind</font> равно 9 (<font face=Courier>REF_invokeInterface</font>), то значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_InterfaceMethodref_info</font> (см. §4.4.2), представляющей метод интерфейса,  для которого создается обработчик метода.

:: Если значение элемента <font face=Courier>reference_kind</font> равно 5 (<font face=Courier>REF_invokeVirtual</font>), 6 (<font face=Courier>REF_invokeStatic</font>), 7 (<font face=Courier>REF_invokeSpecial</font>) или 9 (<font face=Courier>REF_invokeInterface</font>), то имя метода в структуре <font face=Courier>CONSTANT_Methodref_info</font> не должно быть <font face=Courier><init></font> или <font face=Courier><clinit></font>.

:: Если значение элемента <font face=Courier>reference_kind</font> равно 8 (<font face=Courier>REF_newInvokeSpecial</font>), то имя метода в структуре <font face=Courier>CONSTANT_Methodref_info</font>  должно быть <font face=Courier><init></font>.

<br><br><br><br>
==== Структура <font face=Courier>CONSTANT_MethodType_info</font> ====

Структура <font face=Courier>CONSTANT_MethodType_inf</font> используется для представления типа метода:

 CONSTANT_MethodType_info {
    u1 tag;
    u2 descriptor_index;
    }

Элементы структуры <font face=Courier>CONSTANT_MethodType_info</font> следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_MethodType_info</font> имеет значение <font face=Courier>CONSTANT_MethodType</font> (16).

<font face=Courier>descriptor_index</font>
:: Значение элемента <font face=Courier>descriptor_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей дескриптор метода (см. §4.3.3).

<br><br><br><br>
==== Структура <font face=Courier>CONSTANT_InvokeDynamic_info</font> ====

Структура <font face=Courier>CONSTANT_InvokeDynamic_info</font> используется инструкцией ''invokedynamic'' для определения загрузочного метода, динамически вызываемого имени, аргументов и возвращаемого типа вызова, а также опционально набора дополнительных констант, называемых ''статическими аргументами'' загрузочного метода.

 CONSTANT_InvokeDynamic_info {
    u1 tag;
    u2 bootstrap_method_attr_index;
    u2 name_and_type_index;
    }

Элементы структуры <font face=Courier>CONSTANT_InvokeDynamic_info</font> o следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> структуры <font face=Courier>CONSTANT_InvokeDynamic_info</font> имеет значение <font face=Courier>CONSTANT_InvokeDynamic</font> (18).

<font face=Courier>bootstrap_method_attr_index</font>
:: Значение элемента <font face=Courier>bootstrap_method_attr_index</font> должно быть действительным индексом в массиве <font face=Courier>bootstrap_methods</font>, который находится в таблице загрузочных методов (см. §4.7.21) <font face=Courier>class</font>-файла.

<font face=Courier>name_and_type_index</font>
:: Значение элемента <font face=Courier>name_and_type_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_NameAndType_info</font> (см. §4.4.6), представляющей имя метода и дескриптор метода (см. §4.3.3).

<br><br><br><br>
=== Поля ===

Каждое поле в классе описывается структурой <font face=Courier>field_info</font>. Никакие два поля в одном <font face=Courier>class</font>-файле не могут иметь одинаковые имя и дескриптор (см. §4.3.2). Структура имеет следующий формат:

 field_info {
    u2 			access_flags;
    u2 			name_index;
    u2 			descriptor_index;
    u2 			attributes_count;
    attribute_info 	attributes[attributes_count];
 }

Элементы структуры <font face=Courier>field_info</font> следующие:

<font face=Courier>access_flags</font>
:: Значение <font face=Courier>access_flags</font> является набором флагов, определяющих доступ и свойства данного поля. Описание каждого из флагов приведено в таблице 4.19.

:: '''Таблица 4.19 Флаги доступа и свойств поля'''

{| border="1" style="border-collapse:collapse; margin-left: 46px;"
! Имя флага
! Значение
! Описание
|-
| <font face=Courier>ACC_PUBLIC</font>
| <font face=Courier>0x0001</font>
| Поле объявлено <font face=Courier>public</font>; доступно вне пакета.
|-
| <font face=Courier>ACC_PRIVATE</font>
| <font face=Courier>0x0002</font>
| Поле объявлено <font face=Courier>private</font>; доступно только в классе.
|-
| <font face=Courier>ACC_PROTECTED</font>
| <font face=Courier>0x0004</font>
| Поле объявлено <font face=Courier>protected</font>; доступно для классов предков.
|-
| <font face=Courier>ACC_STATIC</font>
| <font face=Courier>0x0008</font>
| Поле объявлено <font face=Courier>static</font>.
|-
| <font face=Courier>ACC_FINAL</font>
| <font face=Courier>0x0010</font>
| Поле объявлено <font face=Courier>final</font>; присваивание после создания объекта запрещено (см. JLS §17.5).
|-
| <font face=Courier>ACC_VOLATILE</font>
| <font face=Courier>0x0040</font>
| Поле объявлено <font face=Courier>volatile</font>; не кэшируется.
|-
| <font face=Courier>ACC_TRANSIENT</font>
| <font face=Courier>0x0080</font>
| Поле объявлено <font face=Courier>transient</font>; игнорируется при сериализации объекта менеджером объектов.
|-
| <font face=Courier>ACC_SYNTHETIC</font>
| <font face=Courier>0x1000</font>
| Поле объявлено вспомогательным; отсутствует в исходно коде.
|-
| <font face=Courier>ACC_ENUM</font>
| <font face=Courier>0x4000</font>
| Поле объявлено элементом перечисления (<font face=Courier>enum</font>).
|}


:: Если поле помечено флагом <font face=Courier>ACC_SYNTHETIC</font>, то это означает, что это поле сгенерировал компилятор и в исходном коде оно отсутствует.

:: Флаг <font face=Courier>ACC_ENUM</font>, что поле содержит элемент перечислимого типа. Для поля класса может быть установлен любой из флагов таблицы 4.19. Однако, только один из флагов <font face=Courier>ACC_PRIVATE</font>,  <font face=Courier>ACC_PROTECTED</font> или <font face=Courier>ACC_PUBLIC</font> для конкретного поля может быть в установленном состоянии (см. JLS §8.3.1) а также не могут быть одновременно установлены флаги <font face=Courier>ACC_FINAL</font> и <font face=Courier>ACC_VOLATILE</font> (см. §8.3.1.4).

:: Все поля интерфейса должны иметь установленными флаги <font face=Courier>ACC_PUBLIC</font>,  <font face=Courier>ACC_STATIC</font> и <font face=Courier>ACC_FINAL</font>; допустимо устанавливать флаг  <font face=Courier>ACC_SYNTHETIC</font>, остальные флаги из таблицы 4.19 должны быть сброшены (см. JLS §9.3).

:: Биты элемента <font face=Courier>access_flags</font> не описанные в таблице 4.19 зарезервированы для будущего использования. Им должно быть присвоено нулевое значение в <font face=Courier>class</font>-файле, а реализация виртуальной машины Java должна их игнорировать.

<font face=Courier>name_index</font>
:: Значение элемента <font face=Courier>name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей действительное имя в упрощённой форме (см. §4.2.2).

<font face=Courier>descriptor_index</font>
:: Значение элемента <font face=Courier>descriptor_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей действительный дескриптор поля (см. §4.3.2).

<font face=Courier>attributes_count</font>
:: Значение элемента <font face=Courier>attributes_count</font> указывает на количество дополнительных атрибутов (см. §4.7) данного поля.

<font face=Courier>attributes[]</font>
:: Каждое значение таблицы <font face=Courier>attributes</font> должно быть структурой атрибутов (см. §4.7). Поле может иметь любое число атрибутов связанных с ним. Допустимы следующие атрибуты таблицы <font face=Courier>attributes</font> структуры <font face=Courier>field_info</font>, определяемые данной спецификацией: <font face=Courier>ConstantValue</font> (см. §4.7.2),  <font face=Courier>Synthetic</font> (см. §4.7.8),  <font face=Courier>Signature</font> (см. §4.7.9), <font face=Courier>Deprecated</font> (см. §4.7.15),  <font face=Courier>RuntimeVisibleAnnotations</font> (см. §4.7.16) и <font face=Courier>RuntimeInvisibleAnnotations</font> (см. §4.7.17).

:: Реализация виртуальной машины Java должна распознавать и правильно обрабатывать атрибут <font face=Courier>ConstantValue</font> (см. §4.7.2) из таблицы <font face=Courier>attributes</font> структуры <font face=Courier>field_info</font>. Если реализация виртуальной машины Java распознает <font face=Courier>class</font>-файл версии 49.0 и выше, она также должна распознавать и корректно обрабатывать атрибуты <font face=Courier>Signature</font> (см. §4.7.9),  <font face=Courier>RuntimeVisibleAnnotations</font> (см. §4.7.16) и  <font face=Courier>RuntimeInvisibleAnnotations</font> (см. §4.7.17) из таблицы <font face=Courier>attributes</font> структуры <font face=Courier>field_info</font>.

:: Виртуальная машина Java должна игнорировать без сообщений об ошибках все атрибуты таблицы <font face=Courier>attributes</font> структуры <font face=Courier>field_info</font>, которые она не может распознать. Атрибутам, не определённым в данной спецификации запрещено влиять на семантику <font face=Courier>class</font>-файла, но разрешается предоставлять дополнительную описательную информацию (см. §4.7.1).

<br><br><br><br>

=== Методы ===

Каждый метод, включая методы инициализации класса или экземпляра (см. §2.9), методы инициализации интерфейса (см. §2.9), описываются структурой <font face=Courier>method_info</font>. Никакие два метода в одном <font face=Courier>class</font>-файле не должны иметь одинаковое имя и дескриптор (см. §4.3.3).

Структура имеет следующий формат:

 method_info {
    u2 		access_flags;
    u2 		name_index;
    u2 		descriptor_index;
    u2 		attributes_count;
    attribute_info 	attributes[attributes_count];
    }

Элементы структуры <font face=Courier>method_info</font> следующие:

<font face=Courier>access_flags</font>
:: Значение элемента <font face=Courier>access_flags</font> представляет собой набор флагов для кодирования прав доступа к методу и его свойств. Описание каждого из флагов приведено в таблице 4.20.

:: '''Таблица 4.20 Флаги доступа и свойств метода'''

{| border="1" style="border-collapse:collapse; margin-left: 46px;"
! Имя флага
! Значение
! Описание
|-
| <font face=Courier>ACC_PUBLIC</font>
| <font face=Courier>0x0001</font>
| Метод объявлен <font face=Courier>public</font>; доступен вне пакета.
|-
| <font face=Courier>ACC_PRIVATE</font>
| <font face=Courier>0x0002</font>
| Метод объявлен <font face=Courier>private</font>; доступен только в классе.
|-
| <font face=Courier>ACC_PROTECTED</font>
| <font face=Courier>0x0004</font>
| Метод объявлен <font face=Courier>protected</font>; доступен для классов предков.
|-
| <font face=Courier>ACC_STATIC</font>
| <font face=Courier>0x0008</font>
| Метод объявлен <font face=Courier>static</font>.
|-
| <font face=Courier>ACC_FINAL</font>
| <font face=Courier>0x0010</font>
| Метод объявлен <font face=Courier>final</font>; не замещается в классах предках (см. §5.4.5).
|-
| <font face=Courier>ACC_SYNCHRONIZED</font>
| <font face=Courier>0x0020</font>
| Метод объявлен <font face=Courier>synchronized</font>; при вызове метода захватывается монитор.
|-
| <font face=Courier>ACC_BRIDGE</font>
| <font face=Courier>0x0040</font>
| Мостовой метод, генерируется компилятором.
|-
| <font face=Courier>ACC_VARARGS</font>
| <font face=Courier>0x0080</font>
| Метод с переменным числом параметров.
|-
| <font face=Courier>ACC_NATIVE</font>
| <font face=Courier>0x0100</font>
| Метод объявлен <font face=Courier>native</font>; реализован на языке отличном от Java.
|-
| <font face=Courier>ACC_ABSTRACT</font>
| <font face=Courier>0x0400</font>
| Метод объявлен <font face=Courier>abstract</font>; реализация отсутствует.
|-
| <font face=Courier>ACC_STRICT</font>
| <font face=Courier>0x0800</font>
| Метод объявлен <font face=Courier>strictfp</font>; используется режим работы с плавающей точкой <font face=Courier>FP</font>-<font face=Courier>strict</font>.
|-
| <font face=Courier>ACC_SYNTHETIC</font>
| <font face=Courier>0x1000</font>
| Метод объявлен вспомогательным; отсутствует в исходном коде.
|}


:: Флаг <font face=Courier>ACC_VARARGS</font> говорит о том, что данный метод использует переменное число параметров на уровне исходного кода. Метод, имеющий переменное число входных параметров, должен быть скомпилированным с установленным флагом <font face=Courier>ACC_VARARGS</font>. Все остальные методы должны быть скомпилированы со сброшенным флагом <font face=Courier>ACC_VARARGS</font>.

:: Флаг <font face=Courier>ACC_BRIDGE</font> указывает на то, что метод мостовой и сгенерирован компилятором.

:: Метод может быть помечен флагом <font face=Courier>ACC_SYNTHETIC</font> для указания того, что он сгенерирован компилятором и отсутствует в исходном коде, за исключением некоторых методов, указанных в §4.7.8.

:: Методу класса могут быть установлены любые флаги из таблицы 4.20. Однако конкретный метод класса должен иметь установленным только один из флагов <font face=Courier>ACC_PRIVATE</font>, <font face=Courier>ACC_PROTECTED</font> и  <font face=Courier>ACC_PUBLIC</font> (см. JLS §8.4.3). Если для метода установлен флаг <font face=Courier>ACC_ABSTRACT</font>, то ни один из флагов <font face=Courier>ACC_FINAL</font>, <font face=Courier>ACC_NATIVE</font>,  <font face=Courier>ACC_PRIVATE</font>,  <font face=Courier>ACC_STATIC</font>,  <font face=Courier>ACC_STRICT</font> либо  <font face=Courier>ACC_SYNCHRONIZED</font> не должен быть установлен (см. JLS §8.4.3.1, JLS §8.4.3.3, JLS §8.4.3.4).

:: Все методы интерфейса должны иметь установленными флаги <font face=Courier>ACC_ABSTRACT</font> и  <font face=Courier>ACC_PUBLIC</font>. Также у метода интерфейса могут быть установлены флаги <font face=Courier>ACC_VARARGS</font>, <font face=Courier>ACC_BRIDGE</font> и <font face=Courier>ACC_SYNTHETIC</font>. Все остальные флаги таблицы 4.20 должны быть сброшены (см. JLS §9.4).

:: Методы инициализации классов и интерфейсов (см. §2.9) вызываются виртуальной машиной Java неявно. Значения элемента <font face=Courier>access_flags</font> для них игнорируется за исключением флага <font face=Courier>ACC_STRICT</font>.

:: Биты элемента <font face=Courier>access_flags</font> не описанные в таблице 4.20 зарезервированы для будущего использования. Им должно быть присвоено нулевое значение в <font face=Courier>class</font>-файле, а реализация виртуальной машины Java должна их игнорировать.

<font face=Courier>name_index</font>
:: Значение элемента <font face=Courier>name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей либо одно из специальных имен (§2.9)  (<font face=Courier><init></font> или <font face=Courier><clinit></font>) либо действительное имя метода в упрощенной форме (см. §4.2.2).

<font face=Courier>descriptor_index</font>
:: Значение элемента <font face=Courier>descriptor_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей действительный дескриптор метода (см. §4.3.2).
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. В последующих редакциях данной спецификации, возможно, будет добавлено требование того, чтобы  последний параметр в дескрипторе метода был массивом, если флаг <font face=Courier>ACC_VARARGS</font> в элементе <font face=Courier>access_flags</font> установлен.</span>
|}
<br>
<font face=Courier>attributes_count</font>
:: Значение элемента <font face=Courier>attributes_count</font> указывает на количество дополнительных атрибутов (см. §4.7) данного поля.

<font face=Courier>attributes[]</font>
:: Каждое значение таблицы <font face=Courier>attributes</font> должно быть структурой атрибутов (см. §4.7). Метод может иметь любое число атрибутов связанных с ним. Допустимы следующие атрибуты таблицы <font face=Courier>attributes</font> структуры <font face=Courier>method_info</font>, определяемые данной спецификацией: <font face=Courier>Code</font> (см. §4.7.3),  <font face=Courier>Exceptions</font>  (см. §4.7.5),  <font face=Courier>Synthetic</font> (см. §4.7.8),  <font face=Courier>Signature</font> (см. §4.7.9),  <font face=Courier>Deprecated</font> (см. §4.7.15), <font face=Courier>RuntimeVisibleAnnotations</font> (см. §4.7.16),  <font face=Courier>RuntimeInvisibleAnnotations</font> (см. §4.7.17),  <font face=Courier>RuntimeVisibleParameterAnnotations</font> (см. §4.7.18), <font face=Courier>RuntimeInvisibleParameterAnnotations</font> (см. §4.7.19) и <font face=Courier>AnnotationDefault</font> (см. §4.7.20).

:: Реализация виртуальной машины Java должна распознавать и правильно обрабатывать атрибут <font face=Courier>Code</font> (см. §4.7.3) и <font face=Courier>Exceptions</font>  (см. §4.7.5) из таблицы <font face=Courier>attributes</font> структуры <font face=Courier>method_info</font>. Если реализация виртуальной машины Java распознает <font face=Courier>class</font>-файл версии 49.0 и выше, она также должна распознавать и корректно обрабатывать атрибуты <font face=Courier>Signature</font> (см. §4.7.9), <font face=Courier>RuntimeVisibleAnnotations</font> (см. §4.7.16),  <font face=Courier>RuntimeInvisibleAnnotations</font> (см. §4.7.17),  <font face=Courier>RuntimeVisibleParameterAnnotations</font> (см. §4.7.18), <font face=Courier>RuntimeInvisibleParameterAnnotations</font> (см. §4.7.19) и <font face=Courier>AnnotationDefault</font> (см. §4.7.20)

:: Виртуальная машина Java должна игнорировать без сообщений об ошибках все атрибуты таблицы <font face=Courier>attributes</font> структуры <font face=Courier>method_info</font>, которые она не может распознать. Атрибутам, не определённым в данной спецификации запрещено влиять на семантику <font face=Courier>class</font>-файла, но разрешается предоставлять дополнительную описательную информацию (см. §4.7.1).

<br><br><br><br>

=== Атрибуты ===

Атрибуты используются в структурах <font face=Courier>ClassFile</font> (см. §4.1),  <font face=Courier>field_info</font> (см. §4.5),  <font face=Courier>method_info</font> (см. §4.6) и  <font face=Courier>Code_attribute</font> (см. §4.7.3). Все атрибуты имеют следующий общий формат:

 attribute_info {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 info[attribute_length];
    }

У всех атрибутов элемент <font face=Courier>attribute_name_index</font> должен быть действительным 16-ти битовым индексом в константном пуле класса. Элемент таблицы <font face=Courier>constant_pool</font> с индексом <font face=Courier>attribute_name_index</font> должен быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей имя атрибута. Значение элемента <font face=Courier>attribute_length</font> содержит размер атрибута в байтах. Длина не включает в себя начальные шесть байт, содержащихся в элементах <font face=Courier>attribute_name_index</font> и <font face=Courier>attribute_length</font>.
Таблица 4.21 – Предопределённые атрибуты class-файла
Некоторые атрибуты определены как часть спецификации <font face=Courier>class</font>-файла. Они приведены в таблице 4.21 совместно с версией Java платформы стандартной редакции («Java SE») и версией формата <font face=Courier>class</font>-файла, в которой они впервые встречаются. В контексте использования атрибутов в данной спецификации (то есть в таблице <font face=Courier>attributes</font> различных структур <font face=Courier>class</font>-файла) имена атрибутов являются зарезервированными. Для предопределённых атрибутов справедливо следующее:

* Реализация виртуальной машины Java должна считывать и корректно обрабатывать атрибуты <font face=Courier>ConstantValue</font>,  <font face=Courier>Code</font> и  <font face=Courier>Exceptions</font> в <font face=Courier>class</font>-файле.

* Атрибуты <font face=Courier>InnerClasses</font>,  <font face=Courier>EnclosingMethod</font> и  <font face=Courier>Synthetic</font> также должны распознаваться и корректно обрабатываться для реализации библиотеки классов платформы Java (см. §2.12).

* Атрибуты <font face=Courier>RuntimeVisibleAnnotations</font>,  <font face=Courier>RuntimeInvisibleAnnotations</font>, <font face=Courier>RuntimeVisibleParameterAnnotations</font>, <font face=Courier>RuntimeInvisibleParameterAnnotations</font> и <font face=Courier>AnnotationDefault</font> должны распознаваться и корректно обрабатываться для реализации библиотеки классов платформы Java (см. §2.12), если версия <font face=Courier>class</font>-файла равна 49.0 и выше и при этом реализация виртуальной машины Java распознает <font face=Courier>class</font>-файл, чья версия 49.0 и выше.

* Атрибут <font face=Courier>Signature</font> должен распознаваться и корректно обрабатываться, если версия <font face=Courier>class</font>-файла равна 49.0 и выше и при этом реализация виртуальной машины Java распознает <font face=Courier>class</font>-файл, чья версия 49.0 и выше.

* Атрибут <font face=Courier>StackMapTable</font> должен распознаваться и корректно обрабатываться, если версия <font face=Courier>class</font>-файла равна 50.0 и выше и при этом реализация виртуальной машины Java распознает <font face=Courier>class</font>-файл, чья версия 50.0 и выше.

* Атрибут <font face=Courier>BootstrapMethods</font> должен распознаваться и корректно обрабатываться, если версия <font face=Courier>class</font>-файла равна 51.0 и выше и при этом реализация виртуальной машины Java распознает <font face=Courier>class</font>-файл, чья версия 51.0 и выше.

Использование остальных предопределённых атрибутов не обязательно; процедура чтения <font face=Courier>class</font>-файла может использовать информацию, которая хранится в остальных атрибутах, либо может игнорировать их без сообщений об ошибках.

'''Таблица 4.21 – Предопределённые атрибуты <font face=Courier>class</font>-файла'''

{| border="1" style="border-collapse:collapse"
! Атрибут
! Java SE
! <font face=Courier>class</font>-файл
|-
| <font face=Courier>ConstantValue</font>(§4.7.2)
| 1.0.2
| 45.3
|-
| <font face=Courier>Code</font>(§4.7.3)
| 1.0.2
| 45.3
|-
| <font face=Courier>StackMapTable</font>(§4.7.4)
| 6
| 50
|-
| <font face=Courier>Exceptions</font>(§4.7.5)
| 1.0.2
| 45.3
|-
| <font face=Courier>InnerClasses</font>(§4.7.6)
| 1.1
| 45.3
|-
| <font face=Courier>EnclosingMethod</font>(§4.7.7)
| 5
| 49
|-
| <font face=Courier>Synthetic</font>(§4.7.8)
| 1.1
| 45.3
|-
| <font face=Courier>Signature</font>(§4.7.9)
| 5
| 49
|-
| <font face=Courier>SourceFile</font>(§4.7.10)
| 1.0.2
| 45.3
|-
| <font face=Courier>SourceDebugExtension</font>(§4.7.11)
| 5
| 49
|-
| <font face=Courier>LineNumberTable</font>(§4.7.12)
| 1.0.2
| 45.3
|-
| <font face=Courier>LocalVariableTable</font>(§4.7.13)
| 1.0.2
| 45.3
|-
| <font face=Courier>LocalVariableTypeTable</font>(§4.7.14)
| 5
| 49
|-
| <font face=Courier>Deprecated</font>(§4.7.15)
| 1.1
| 45.3
|-
| <font face=Courier>RuntimeVisibleAnnotations</font>(§4.7.16)
| 5
| 49
|-
| <font face=Courier>RuntimeInvisibleAnnotations</font>(§4.7.17)
| 5
| 49
|-
| <font face=Courier>RuntimeVisibleParameterAnnotations</font>(§4.7.18)
| 5
| 49
|-
| <font face=Courier>RuntimeInvisibleParameterAnnotations</font>(§4.7.19)
| 5
| 49
|-
| <font face=Courier>AnnotationDefault</font>(§4.7.20)
| 5
| 49
|-
| <font face=Courier>BootstrapMethods</font>(§4.7.21)
| 7
| 51
|}
<br><br><br><br>
==== Определение и именование новых атрибутов ====

Компиляторам допустимо определять и создавать <font face=Courier>class</font>-файлы, содержащие новые атрибуты в таблицах <font face=Courier>attributes</font>. Реализациям виртуальной машины Java разрешается распознавать и использовать новые атрибуты в таблицах <font face=Courier>attributes</font> структур <font face=Courier>class</font>-файла. Тем не менее, атрибуты, не определённые как часть виртуальной машины Java, не должны влиять на семантику классов или интерфейсов. Реализация виртуальной машины Java должна пропускать без сообщений об ошибках те атрибуты, которые она не может распознать.
Например, допустимо создать новый атрибут, для поддержки специального вида отладки, предоставляемого поставщиком. Поскольку реализации виртуальной машины Java должны игнорировать без сообщений об ошибках те атрибуты, которые они не в состоянии распознать, то <font face=Courier>class</font>-файл, содержащий дополнительны атрибуты можно будет выполнить и с помощью других реализаций виртуальной машины, даже, если они не поддерживают данную отладочную информацию.

Реализациям виртуальной машины Java намеренно запрещено генерировать исключения либо каким-либо иным способом блокировать использование <font face=Courier>class</font>-файла только лишь из-за наличия нераспознанных атрибутов. Дополнительное программное обеспечение, работающее с <font face=Courier>class</font>-файлом, может выдавать сообщения об ошибке, если необходимые атрибуты не найдены.

Два различных по смыслу атрибута, использующих одно и то же имя и имеющих одинаковую длину, приведут к конфликту в той реализации виртуальной машины, которая использует данный атрибут. Атрибуты, определённые за рамками данной спецификации должны использовать правила именования, описанные в ''Спецификации языка программирования Java SE 7 Edition'' (JLS §6.1).

В последующих редакциях данной спецификации могут быть определены дополнительные атрибуты.

<br><br><br><br>

==== Атрибут <font face=Courier>ConstantValue</font> ====

Атрибут <font face=Courier>ConstantValue</font> является атрибутом с фиксированной длинной в таблице <font face=Courier>attributes</font> структуры <font face=Courier>field_info</font> (см. §4.5). Атрибут <font face=Courier>ConstantValue</font> представляет собой значение константного поля. У заданной структуры <font face=Courier>field_info</font> может быть не более одного атрибута <font face=Courier>ConstantValue</font> в таблице <font face=Courier>attributes</font>. Если поле является статическим (то есть, установлен флаг <font face=Courier>ACC_STATIC</font>, (см. Таблицу 4.19) в элементе <font face=Courier>access_flags</font> структуры <font face=Courier>field_info</font>), то константному полю, описываемому структурой <font face=Courier>field_info</font>, присвоено значение, участвующее в процессе инициализации класса или интерфейса, в котором содержится данное поле (см. §5.5). Чтение атрибута происходит до вызова метода инициализации класса или интерфейса (см. §2.9).

Если структура <font face=Courier>field_info</font>, представляющая не статическое поле, имеет атрибут <font face=Courier>ConstantValue</font>, то такой атрибут игнорируется без сообщения об ошибке. Любая реализация виртуальной машины Java должна уметь распознавать атрибут <font face=Courier>ConstantValue</font>.

Атрибут <font face=Courier>ConstantValue</font> имеет следующий формат:

 ConstantValue_attribute {
    u2 attribute_name_index;
    u4 attribute_length;
    u2 constantvalue_index;
    }

Элементы структуры <font face=Courier>ConstantValue_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>ConstantValue</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>ConstantValue_attribute</font> должно быть 2.

<font face=Courier>constantvalue_index</font>
:: Значение элемента <font face=Courier>constantvalue_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом содержит константную структуру, которая описывается данным атрибутом. Тип константной структуры должен соответствовать типу данных поля, как указано в Таблице 4.22.

:: '''Таблица 4.22 Типы константных структур и типы полей'''

{| border="1" style="border-collapse:collapse; margin-left: 46px;"
! Тип поля
! Тип константной структуры
|-
| <font face=Courier>long</font>
| <font face=Courier>CONSTANT_Long</font>
|-
| <font face=Courier>float</font>
| <font face=Courier>CONSTANT_Float</font>
|-
| <font face=Courier>double</font>
| <font face=Courier>CONSTANT_Double</font>
|-
| <font face=Courier>int</font>, <font face=Courier>short</font>, <font face=Courier>char</font>, <font face=Courier>byte</font>, <font face=Courier>boolean</font>
| <font face=Courier>CONSTANT_Integer</font>
|-
| <font face=Courier>String</font>
| <font face=Courier>CONSTANT_String</font>
|}

<br><br><br><br>

==== Атрибут <font face=Courier>Code</font> ====

Атрибут <font face=Courier>Code</font> является атрибутом с переменной длинной в таблице <font face=Courier>attributes</font> структуры <font face=Courier>method_info</font> (см. §4.6). Атрибут <font face=Courier>Code</font> содержит инструкции виртуальной машины Java и вспомогательную информацию для одного метода экземпляра, метода инициализации экземпляра (см. §2.9), либо метода инициализации класса или интерфейса (см. §2.9). Любая реализация виртуальной машины Java должна уметь распознавать атрибут <font face=Courier>Code</font>. Если метод <font face=Courier>native</font> либо <font face=Courier>abstract</font>, то его структура <font face=Courier>method_info</font>, не должна иметь атрибут <font face=Courier>Code</font>. В противном случае структура <font face=Courier>method_info</font> должна иметь только один атрибут <font face=Courier>Code</font>.

Атрибут <font face=Courier>Code</font> имеет следующий формат:

 Code_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 max_stack;
 u2 max_locals;
 u4 code_length;
 u1 code[code_length];
 u2 exception_table_length;
 {    u2 start_pc;
      u2 end_pc;
      u2 handler_pc;
      u2 catch_type;
 } exception_table[exception_table_length];
 u2 attributes_count;
 attribute_info attributes[attributes_count];
 }

Элементы структуры <font face=Courier>Code_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>Code</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры определяет длину атрибута без учета начальных шести байт.

<font face=Courier>max_stack</font>
:: Значение элемента <font face=Courier>max_stack</font> задаёт максимально используемую глубину стека операндов (см. §2.6.2) при выполнении инструкций данного метода.

<font face=Courier>max_locals</font>
:: Значение элемента <font face=Courier>max_locals</font> определяет число локальных переменных, создаваемых при вызове метода (см. §2.6.1), включая локальные переменные, используемые для передачи параметров метода.

:: Максимальным индексом локальной переменной типа <font face=Courier>long</font> и <font face=Courier>double</font> является <font face=Courier>max_locals</font> - 2. Максимальным индексом локальной переменной всех остальных типов является <font face=Courier>max_locals</font> - 1.

<font face=Courier>code_length</font>
:: Значение элемента <font face=Courier>code_length</font> задает число байт в массиве <font face=Courier>code</font> для данного метода. Значение <font face=Courier>code_length</font> должно быть больше нуля; массив <font face=Courier>code</font> не должен быть пустым.

<font face=Courier>code[]</font>
:: Массив <font face=Courier>code</font> содержит байты инструкций виртуальной машины Java, которые, собственно, и реализуют метод.

:: В случае, когда массив <font face=Courier>code</font> считывается в память машины с байтовой адресацией и позиция первого байта массива выровнена  по 4-м байтам, то 32-х битные смещения инструкций ''tableswitch'' и ''lookupswitch'' также будут выравненны по 4-м байтам. (Подробности, описывающие принципы выравнивания, приведены в детальном описании каждой из указанных инструкций).

:: Ограничения для массива <font face=Courier>code</font> приведены в отдельном разделе (см. §4.9).

<font face=Courier>exception_table_length</font>
:: Значение элемента  <font face=Courier>exception_table_length</font> задает число элементов в таблице <font face=Courier>exception_table</font>.

<font face=Courier>exception_table[]</font>
:: Каждый элемент в массиве <font face=Courier>exception_table</font> один обработчик исключения метода, находящегося в массиве <font face=Courier>code</font>. Порядок обработчиков в массиве <font face=Courier>exception_table</font> имеет значение (см. §2.10).

:: Каждый элемент <font face=Courier>exception_table</font> содержит следующие поля:

:: <font face=Courier>start_pc</font>, <font face=Courier>end_pc</font>
:::: Значения двух полей <font face=Courier>start_pc</font> и <font face=Courier>end_pc</font> определяют границы кода в массиве <font face=Courier>code</font>, для которого написан обработчик исключений. Значение <font face=Courier>start_pc</font> должно быть действительным индексом  байт-кода инструкции в массиве <font face=Courier>code</font>. Значение <font face=Courier>end_pc</font> должно быть либо действительным индексом  байт-кода инструкции в массиве <font face=Courier>code</font> либо равно <font face=Courier>code_length</font> – длине массива <font face=Courier>code</font>. Значение <font face=Courier>start_pc</font> должно быть меньше <font face=Courier>end_pc</font>.

:::: Значение <font face=Courier>start_pc</font> считается включительно, а <font face=Courier>end_pc</font> не включительно; то есть обработчик исключений доступен, пока программный счётчик лежит в интервале адресов [<font face=Courier>start_pc</font>, <font face=Courier>end_pc</font>).
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 92px;" |
|
<span style="font-size:88%">Примечание. Тот факт, что конечная точка интервала <font face=Courier>end_pc</font> рассматривается не включительно, является исторической ошибкой в проектировании виртуальной машины Java: если размер байт-кода метода равен 65535 байтам и при этом длина последней инструкции равна одному байту, то эта инструкция не может быть включена в сегмент кода, для которого срабатывает исключение. Проектировщик компилятора языка Java может обойти эту ошибку, ограничив 65534 байтами размер кода метода экземпляра, инициализирующего метода и статического инициализатора.</span>
|}
<br>
:: <font face=Courier>handler_pc</font>
:::: Значение элемента <font face=Courier>handler_pc</font> определяет начало обработчика исключений. Значение элемента должно быть действительным индексом в массиве <font face=Courier>code</font> и указывать на байт-код инструкции.

:: <font face=Courier>catch_type</font>
:::: Если значение элемента <font face=Courier>catch_type</font> не нулевое, оно должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Элемент таблицы <font face=Courier>constant_pool</font> с указанным выше индексом должен быть структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1) представляющей класс исключения, на которое обработчик призван реагировать. Обработчик исключения будет вызван, только если выброшенное исключение является экземпляром или потомком данного исключения.

:::: Если значение элемента <font face=Courier>catch_type</font> равно нулю, то данный обработчик вызывается для всех исключений. Он используется для реализации блока <font face=Courier>finally</font> (см. §3.13).

<font face=Courier>attributes_count</font>
:: Значение элемента <font face=Courier>attributes_count</font> указывает на количество атрибутов (см. §4.7) элемента <font face=Courier>Code</font>.

<font face=Courier>attributes[]</font>
:: Каждое значение таблицы <font face=Courier>attributes</font> должно быть структурой атрибутов (см. §4.7). Элемент <font face=Courier>Code</font> может иметь любое число атрибутов связанных с ним. Допустимы следующие атрибуты таблицы <font face=Courier>attributes</font> структуры <font face=Courier>Code</font>, определяемые данной спецификацией: <font face=Courier>LineNumberTable</font> (см. §4.7.12), <font face=Courier>LocalVariableTable</font> (см. §4.7.13),  <font face=Courier>LocalVariableTypeTable</font> (см. §4.7.14) и <font face=Courier>StackMapTable</font> (см. §4.7.4).

:: Если реализация виртуальной машины Java распознает <font face=Courier>class</font>-файл версии 50.0 и выше, она также должна распознавать и корректно обрабатывать атрибут <font face=Courier>StackMapTable</font> (§4.7.4) в таблице <font face=Courier>attributes</font>  структуры  <font face=Courier>Code</font>.

:: Виртуальная машина Java должна игнорировать без сообщений об ошибках все атрибуты таблицы <font face=Courier>attributes</font> структуры <font face=Courier>Code</font>, которые она не может распознать. Атрибутам, не определённым в данной спецификации запрещено влиять на семантику <font face=Courier>class</font>-файла, но разрешается предоставлять дополнительную описательную информацию (см. §4.7.1).

<br><br><br><br>
==== Атрибут <font face=Courier>StackMapTable</font> ====

Атрибут <font face=Courier>StackMapTable</font> имеет переменную длину и находится в таблице <font face=Courier>attributes</font> атрибута <font face=Courier>Code</font> (см. §4.7.3). Этот атрибут используется анализатором типов (см. §4.10.1) в процессе верификации. Атрибут <font face=Courier>Code</font> должен иметь как минимум один атрибут <font face=Courier>StackMapTable</font>.

Атрибут <font face=Courier>StackMapTable</font> содержит ноль или более ''соответствий стековых фреймов''.  Каждый стековый фрейм определяет (явно либо неявно) смещение байт-кода, типы для проверок (см. §4.10.1) локальных переменных, типы для проверок стека операндов.

Анализатор типов работает с ожидаемыми типами локальных переменных метода и стека операндов. Везде в этом разделе мы ссылаемся либо на одну локальную переменную, либо на один элемент стека операндов.

Мы будем взаимозаменяемо использовать термины ''соответствие стекового фрейма'' и ''типизированное состояние'' для того, чтобы описать соответствие типов локальных переменных метода и стека операндов проверяемым типам. Мы будем часто использовать термин ''соответствие стекового фрейма'', когда данное соответствие установлено в <font face=Courier>class</font>-файле и ''термин типизированное состояние'', когда соответствие используется анализатором типов.

Если атрибут <font face=Courier>Code</font> не имеет атрибута <font face=Courier>StackMapTable</font>, то используется ''неявный атрибут для соответствия стекового фрейма'' в <font face=Courier>class</font>-файле, чья версия выше либо равна 50.0. Этот неявный атрибут  эквивалентен атрибуту <font face=Courier>StackMapTable</font>, у которого <font face=Courier>number_of_entries</font> равно нулю.

Атрибут <font face=Courier>StackMapTable</font> имеет следующий формат:

 StackMapTable_attribute {
 u2                 attribute_name_index;
 u4                 attribute_length;
 u2                 number_of_entries;
 stack_map_frame    entries[number_of_entries];
 }

Элементы структуры <font face=Courier>StackMapTable_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>StackMapTable</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры определяет длину атрибута без учета начальных шести байт.

<font face=Courier>number_of_entries</font>
:: Значение элемента <font face=Courier>number_of_entries</font> определяет количество элементов <font face=Courier>stack_map_frame</font> в таблице <font face=Courier>entries</font>

<font face=Courier>entries</font>
:: Массив <font face=Courier>entries</font> содержит структуры <font face=Courier>stack_map_frame</font>.

Каждая структура <font face=Courier>stack_map_frame</font> определяет состояние типов для конкретного смещения байт-кода. Каждый фрейм содержит явно или неявно значение <font face=Courier>offset_delta</font>, предназначенное для вычисления фактического смещения байт-кода, в пределах которого используется фрейм.  Смещения байт-кода, в пределах которого используется фрейм, вычисляется путем сложения <font face=Courier>offset_delta</font> + 1 и смещения предыдущего фрейма. Для начального фрейма смещения считается равным <font face=Courier>offset_delta</font>.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Используя разницу смещений, а не фактическое смещения байт-кода, мы по определению гарантируем, что соответствия стекового фрейма расположены в отсортированном порядке. Более того, последовательно используя формулу <font face=Courier>offset_delta</font> + 1 для всех фреймов, мы гарантируем отсутствие дубликатов. </span>
|}
<br>
Мы говорим, что инструкция в последовательности байт-кодов имеет соответствие стекового фрейма, если инструкция начинается со смещения ''i'' в массиве <font face=Courier>code</font> атрибута <font face=Courier>Code</font> и при этом атрибут <font face=Courier>Code</font> имеет атрибут <font face=Courier>StackMapTable</font>, чей элемент содержит структуру <font face=Courier>stack_map_frame</font>, относящуюся к байт-коду со смещением ''i''.

Структура <font face=Courier>stack_map_frame</font> состоит из тега размером один байт, за которым следуют ноль или более байтов, содержащих информацию в зависимости от тега.

Соответствие стекового фрейма может принадлежать нескольким типам:

 union stack_map_frame {
     same_frame;
     same_locals_1_stack_item_frame;
     same_locals_1_stack_item_frame_extended;
     chop_frame;
     same_frame_extended;
     append_frame;
     full_frame;
 }

Все типы фреймов, даже <font face=Courier>full_frame</font> используют предыдущие фреймы. Тогда закономерно возникает вопрос: что использует самый первый фрейм? Самый первый фрейм является неявным и формируется на основе дескриптора метода. Более подробно смотрите код для <font face=Courier>methodInitialStackFrame</font> (раздел «Проверка кода»).

* Тип фрейма <font face=Courier>same_frame</font> представлен тегами в диапазоне [0-63]. Если фрейм имеет тип <font face=Courier>same_frame</font>, то это значит, что фрейм имеет в точности те же локальные переменные, что и предыдущий фрейм и число элементов стека равно нулю. Значение <font face=Courier>offset_delta</font> для данного фрейма равно величине <font face=Courier>frame_type</font>.


<syntaxhighlight lang="java">same_frame {
u1 frame_type = SAME; /* 0-63 */
}  
</syntaxhighlight>


* Тип фрейма <font face=Courier>same_locals_1_stack_item_frame</font> представлен тегами в диапазоне [64, 127]. Если фрейм имеет тип <font face=Courier>same_locals_1_stack_item_frame</font>, то это значит, что фрейм имеет в точности те же локальные переменные, что и предыдущий фрейм и число элементов стека равно единице. Значение <font face=Courier>offset_delta</font> для данного фрейма равно величине (<font face=Courier>frame_type</font> – 64).


<syntaxhighlight lang="java">same_locals_1_stack_item_frame {
u1 frame_type = SAME_LOCALS_1_STACK_ITEM; /* 64-127 */
verification_type_info stack[1];
}   
</syntaxhighlight>


: Теги в интервале [128-246] зарезервированы для будущего использования.

* Тип фрейма <font face=Courier>same_locals_1_stack_item_frame_extended</font> представлен тегом 247. Если фрейм имеет тип <font face=Courier>same_locals_1_stack_item_frame_extended</font>, то это значит, что фрейм имеет в точности те же локальные переменные, что и предыдущий фрейм и число элементов стека равно единице. Значение <font face=Courier>offset_delta</font> для данного фрейма задано явно. За элементом <font face=Courier>frame_type</font> следует элемент <font face=Courier>verification_type_info</font>.


<syntaxhighlight lang="java">same_locals_1_stack_item_frame_extended {
u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */
u2 offset_delta;
verification_type_info stack[1];
}
</syntaxhighlight>


* Тип фрейма <font face=Courier>chop_frame</font> представлен тегами в диапазоне [248-250]. Если фрейм имеет тип <font face=Courier>chop_frame</font>, то это значит, что стек операндов пуст и фрейм имеет в точности те же локальные переменные, что и предыдущий фрейм, за исключением того, что последние ''k'' локальных переменных отсутствуют. Значение ''k'' равно величине 251 – <font face=Courier>frame_type</font>. 


<syntaxhighlight lang="java">chop_frame {
u1 frame_type = CHOP; /* 248-250 */
u2 offset_delta;
}   
</syntaxhighlight>


* Тип фрейма <font face=Courier>same_frame_extended</font> представлен тегом 251. Если фрейм имеет тип <font face=Courier>same_frame_extended</font>, то это значит, что фрейм имеет в точности те же локальные переменные, что и предыдущий фрейм и число элементов стека равно нулю.


<syntaxhighlight lang="java">same_frame_extended {
u1 frame_type = SAME_FRAME_EXTENDED; /* 251 */
u2 offset_delta;
}
</syntaxhighlight>


* Тип фрейма <font face=Courier>append_frame</font> представлен тегами в диапазоне [252-254]. Если фрейм имеет тип <font face=Courier>append_frame</font>, то это значит, что стек операндов пуст и фрейм имеет в точности те же локальные переменные, что и предыдущий фрейм, за исключением того, что дополнительно определены ''k'' локальных переменных. Значение ''k'' равно величине <font face=Courier>frame_type</font> – 251. 


<syntaxhighlight lang="java">append_frame {
u1 frame_type = APPEND; /* 252-254 */
u2 offset_delta;
verification_type_info locals[frame_type - 251];
}  
</syntaxhighlight>


: Нулевой элемент в <font face=Courier>locals</font> содержит тип первой дополнительной локальной переменной. Если <font face=Courier>locals[M]</font> соответствует локальной переменной <font face=Courier>N</font>, тогда <font face=Courier>locals[M+1]</font> содержит локальную переменную <font face=Courier>N</font> + 1, при условии, что <font face=Courier>locals[M]</font> является одной из структур:
<br>
::* <font face=Courier>Top_variable_info</font>
::* <font face=Courier>Integer_variable_info</font>
::* <font face=Courier>Float_variable_info</font>
::* <font face=Courier>Null_variable_info</font>
::* <font face=Courier>UninitializedThis_variable_info</font>
::* <font face=Courier>Object_variable_info</font>
::* <font face=Courier>Uninitialized_variable_info</font>

: В противном случае <font face=Courier>locals[M+1]</font> соответствует локальной переменной <font face=Courier>N</font> + 2.

: Считается ошибкой, если для произвольного индекса ''i'', элемент <font face=Courier>locals[i]</font> содержит локальную переменную, чей индекс больше чем максимальное число локальных переменных метода.

* Тип фрейма <font face=Courier>full_frame</font> представлен тегом 255.


<syntaxhighlight lang="java">full_frame {
u1 frame_type = FULL_FRAME; /* 255 */
u2 offset_delta;
u2 number_of_locals;
verification_type_info locals[number_of_locals];
u2 number_of_stack_items;
verification_type_info stack[number_of_stack_items];
}   
</syntaxhighlight>


: Нулевой элемент в <font face=Courier>locals</font> представляет собой тип локальной переменной 0. Если <font face=Courier>locals[M]</font> соответствует локальной переменной N, тогда <font face=Courier>locals[M+1]</font> содержит локальную переменную <font face=Courier>N</font>+1, при условии, что <font face=Courier>locals[M]</font> является одной из структур:

::* <font face=Courier>Top_variable_info</font>
::* <font face=Courier>Integer_variable_info</font>
::* <font face=Courier>Float_variable_info</font>
::* <font face=Courier>Null_variable_info</font>
::* <font face=Courier>UninitializedThis_variable_info</font>
::* <font face=Courier>Object_variable_info</font>
::* <font face=Courier>Uninitialized_variable_info</font>

: В противном случае <font face=Courier>locals[M+1]</font> соответствует локальной переменной <font face=Courier>N</font>+2.

: Считается ошибкой, если для произвольного индекса ''i'', элемент <font face=Courier>locals[i]</font> содержит локальную переменную, чей индекс больше чем максимальное число локальных переменных метода.

: Нулевой элемент в <font face=Courier>stack</font> представляет собой тип элемента на дне стека, а последующие элементы в <font face=Courier>stack</font> представляют типы элементов стека операндов по направлению к его вершине. Мы будем ссылаться на самый нижний элемент стека, как элемент с индексом 0, следующий за ним – 2 и так далее. Если <font face=Courier>stack[M]</font> соответствует локальной переменной <font face=Courier>N</font>, тогда <font face=Courier>stack[M+1]</font> содержит локальную переменную <font face=Courier>N</font>+1, при условии, что <font face=Courier>stack[M]</font> является одной из структур:

::* <font face=Courier>Top_variable_info</font>
::* <font face=Courier>Integer_variable_info</font>
::* <font face=Courier>Float_variable_info</font>
::* <font face=Courier>Null_variable_info</font>
::* <font face=Courier>UninitializedThis_variable_info</font>
::* <font face=Courier>Object_variable_info</font>
::* <font face=Courier>Uninitialized_variable_info</font>

: В противном случае <font face=Courier>stack[M+1]</font> соответствует локальной переменной <font face=Courier>N</font> + 2.
: Считается ошибкой, если для произвольного индекса ''i'', элемент <font face=Courier>stack[i]</font> содержит элемент стека, чей индекс больше чем максимальное число элементов в стеке операндов.

: Структура <font face=Courier>verification_type_info</font> состоит из тега размером в один байт, за которым следует ноль или более байт с дополнительной информацией о теге. Каждая структура <font face=Courier>verification_type_info</font> определяет проверочный тип для одной или двух локальных переменных.


<syntaxhighlight lang="java">union verification_type_info {
Top_variable_info;
Integer_variable_info;
Float_variable_info;
Long_variable_info;
Double_variable_info;
Null_variable_info;
UninitializedThis_variable_info;
Object_variable_info;
Uninitialized_variable_info;
}   
</syntaxhighlight>


* Тип <font face=Courier>Top_variable_info</font> соответствует тому, что локальная переменная имеет проверочный тип <font face=Courier>top</font>(<font face=Courier>T</font>).


<syntaxhighlight lang="java">Top_variable_info {
u1 tag = ITEM_Top; /* 0 */
}   
</syntaxhighlight>


* Тип <font face=Courier>Integer_variable_info</font> соответствует тому, что локальная переменная имеет проверочный тип <font face=Courier>int</font>.

<syntaxhighlight lang="java">Integer_variable_info {
u1 tag = ITEM_Integer; /* 1 */
}   
</syntaxhighlight>


* Тип <font face=Courier>Float_variable_info</font> соответствует тому, что локальная переменная имеет проверочный тип <font face=Courier>float</font>.


<syntaxhighlight lang="java">Float_variable_info {
u1 tag = ITEM_Float; /* 2 */
}   
</syntaxhighlight>


* Тип <font face=Courier>Long_variable_info</font> соответствует тому, что локальная переменная имеет проверочный тип <font face=Courier>long</font>.


<syntaxhighlight lang="java">Long_variable_info {
u1 tag = ITEM_Long; /* 4 */
}   
</syntaxhighlight>


: Данная структура описывает содержимое двух элементов стека операндов или двух элементов в массиве локальных переменных.

: Если описывается локальная переменная, тогда:

::::* Локальная переменная не должна быть переменной с максимальным индексом.
::::* Локальная переменная со следующим индексом также принадлежит к проверочному типу <font face=Courier>T</font>.

: Если описывается элемент стека операндов, тогда:

::::* Элемент стека операндов не должен быть на вершине стека.
::::* Элемент стека операндов, следующий по направлению к вершине стека,  также принадлежит к проверочному типу <font face=Courier>T</font>.

* Тип <font face=Courier>Double_variable_info</font> соответствует тому, что локальная переменная имеет проверочный тип <font face=Courier>double</font>.


<syntaxhighlight lang="java">Double_variable_info {
u1 tag = ITEM_Double; /* 3 */
}   
</syntaxhighlight>


: Данная структура описывает содержимое двух элементов стека операндов или двух элементов в массиве локальных переменных.

: Если описывается локальная переменная, тогда:

::::* Локальная переменная не должна быть переменной с максимальным индексом.
::::* Локальная переменная со следующим индексом также принадлежит к проверочному типу <font face=Courier>T</font>.

: Если описывается элемент стека операндов, тогда:

::::* Элемент стека операндов не должен быть на вершине стека.
::::* Элемент стека операндов, следующий по направлению к вершине стека,  также принадлежит к проверочному типу <font face=Courier>T</font>.

* Тип <font face=Courier>Null_variable_info</font> соответствует тому, что локальная переменная имеет проверочный тип <font face=Courier>null</font>.


<syntaxhighlight lang="java">Null_variable_info {
u1 tag = ITEM_Null; /* 5 */
}   
</syntaxhighlight>


* Тип <font face=Courier>UninitializedThis_variable_info</font> соответствует тому, что локальная переменная имеет проверочный тип <font face=Courier>uninitializedThis</font>.


<syntaxhighlight lang="java">UninitializedThis_variable_info {
u1 tag = ITEM_UninitializedThis; /* 6 */
}   
</syntaxhighlight>


* Тип <font face=Courier>Object_variable_info</font> соответствует тому, что описываемый элемент содержит экземпляр класса, представленный структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1) в таблице <font face=Courier>constant_pool</font> с индексом <font face=Courier>cpool_index</font>.


<syntaxhighlight lang="java">Object_variable_info {
u1 tag = ITEM_Object; /* 7 */
u2 cpool_index;
}   
</syntaxhighlight>


* Тип <font face=Courier>Object_variable_info</font> соответствует тому, что описываемый элемент имеет проверочный тип <font face=Courier>uninitialized</font>(<font face=Courier>offset</font>). Элемент <font face=Courier>offset</font> содержит смещение в массиве <font face=Courier>code</font> атрибута <font face=Courier>Code</font> (см. §4.7.3), который содержит данный атрибут <font face=Courier>StackMapTable</font>. Смещение указывает на расположение новых объектов, создаваемых с помощью инструкции ''new''.


<syntaxhighlight lang="java">Uninitialized_variable_info {
u1 tag = ITEM_Uninitialized /* 8 */
u2 offset;
}   
</syntaxhighlight>

<br><br><br><br>
==== Атрибут <font face=Courier>Exceptions</font> ====

Атрибут <font face=Courier>Exceptions</font> является атрибутом с переменной длинной, принадлежащим таблице <font face=Courier>attributes</font> структуры <font face=Courier>method_info</font> (см. §4.6). Атрибут <font face=Courier>Exceptions</font> указывает, какие проверяемые исключения метод может генерировать. Должен быть, по крайней мере, один атрибут <font face=Courier>Exceptions</font> в структуре <font face=Courier>method_info</font>.

Атрибут <font face=Courier>Exceptions</font> имеет следующий формат:

 Exceptions_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 number_of_exceptions;
 u2 exception_index_table[number_of_exceptions];
 }

Элементы структуры <font face=Courier>Exceptions_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>Exceptions</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры определяет длину атрибута без учёта начальных шести байт.

<font face=Courier>number_of_exceptions</font>
Значение элемента <font face=Courier>number_of_exceptions</font> определяет количество элементов <font face=Courier>stack_map_frame</font> в таблице <font face=Courier>exception_index_table</font>.

<font face=Courier>exception_index_table[]</font>
:: Каждое значение в массиве <font face=Courier>exception_index_table</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Элемент таблицы <font face=Courier>constant_pool</font> по указанному выше индексу должен быть структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1), представляющей класс исключения, который данный метод генерирует.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Метод должен генерировать исключение, только если хотя бы одно условие истинно:</span>

* <span style="font-size:88%">Исключение является экземпляром <font face=Courier>RuntimeException</font> или его наследника.</span>
* <span style="font-size:88%">Исключение является экземпляром <font face=Courier>Error</font> или его наследника.</span>
* <span style="font-size:88%">Исключение является экземпляром одного из классов, описанных выше в таблице <font face=Courier>exception_index_table</font> либо их наследника.</span>

<span style="font-size:88%">Эти условия налагаются не виртуальной машиной Java, а компилятором во время компиляции.</span>
|}

<br><br><br><br>
==== Атрибут <font face=Courier>InnerClasses</font>====

Атрибут <font face=Courier>InnerClasses</font> является атрибутом с переменной длинной, принадлежащим таблице <font face=Courier>attributes</font> структуры <font face=Courier>ClassFile</font> (см. §4.1). Если константный пул класса или интерфейса C содержит элемент <font face=Courier>CONSTANT_Class_info</font>, который представляет класс или интерфейс, не являющийся членом пакета, то структура <font face=Courier>ClassFile</font> класса или интерфейса C должна иметь в точности один атрибут <font face=Courier>InnerClasses</font> в таблице <font face=Courier>attributes</font>.

Атрибут <font face=Courier>InnerClasses</font> имеет следующий формат:

 InnerClasses_attribute {
     u2 attribute_name_index;
     u4 attribute_length;
     u2 number_of_classes;
     { u2 inner_class_info_index;
          u2 outer_class_info_index;
          u2 inner_name_index;
          u2 inner_class_access_flags;
     } classes[number_of_classes];
 }

Элементы структуры <font face=Courier>Exceptions_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>InnerClasses</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры определяет длину атрибута без учёта начальных шести байт.

<font face=Courier>number_of_classes</font>
:: Значение элемента <font face=Courier>number_of_classes</font> определяет количество элементов в массиве  <font face=Courier>classes</font>.

<font face=Courier>classes[]</font>
:: Каждый элемент <font face=Courier>CONSTANT_Class_info</font> в таблице <font face=Courier>constant_pool</font>, который соответствует классу или интерфейсу C, не являющемуся членом пакета, должен соответствовать одному и только одному элементу массива <font face=Courier>classes</font>.

:: Если класс имеет поля, являющиеся ссылками на экземпляр класса или имплементацию интерфейса, то таблица <font face=Courier>constant_pool</font> (и, следовательно, атрибут <font face=Courier>InnerClasses</font>) должны ссылаться на каждое такое поле, даже если это поле нигде в классе больше не упоминается. Из данного правила следует, что вложенный класс или интерфейс будут иметь в <font face=Courier>InnerClasses</font> информацию для каждого объемлющего класса и для каждого непосредственного члена данных.

:: Каждый элемент массива <font face=Courier>classes</font> состоит из следующих четырёх полей:

:: <font face=Courier>inner_class_info_index</font>
:::: Значение <font face=Courier>inner_class_info_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Элемент, с указанным выше индексом должен быть структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1), представляющей C. Оставшиеся поля элемента массива <font face=Courier>classes</font> содержат информацию о C.

:: <font face=Courier>outer_class_info_index</font>
:::: Если C не является членом-данным класса или интерфейса (т.е. C класс или интерфейс верхнего уровня (JLS §7.6), или локальный класс (JLS §14.3), или анонимный класс (JLS §15.9.5)), то значение <font face=Courier>outer_class_info_index</font> должно быть равно нулю.

:::: В противном случае значение <font face=Courier>outer_class_info_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>, а элемент с данным индексом должен быть структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1), представляющей класс или интерфейс, членом-данным которого является C.

:: <font face=Courier>inner_name_index</font>
:::: Если C анонимный класс (см. JLS §15.9.5), то значение <font face=Courier>inner_name_index</font> должно быть равно нулю.
:::: В противном случае значение <font face=Courier>inner_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font> а элемент с данным индексом должен быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей исходное имя C, как оно записано в исходном коде, на основании которого скомпилирован <font face=Courier>class</font>-файл.

:: <font face=Courier>inner_class_access_flags</font>
:::: Значение элемента <font face=Courier>inner_class_access_flags</font> представляет собой маску из флагов для обозначения прав доступа и свойств класса или интерфейса C, как они записаны в исходном коде, на основании которого скомпилирован <font face=Courier>class</font>-файл. Флаги показаны в таблице 4.23.

:::: '''Таблица 4.23 Флаги доступа и свойств метода'''
{| border="1" style="border-collapse:collapse; margin-left: 92px;"
! Имя флага
! Значение
! Описание
|-
| <font face=Courier>ACC_PUBLIC</font>
| <font face=Courier>0x0001</font>
| Объявлен <font face=Courier>public</font> в исходном коде.
|-
| <font face=Courier>ACC_PRIVATE</font>
| <font face=Courier>0x0002</font>
| Объявлен <font face=Courier>private</font> в исходном коде
|-
| <font face=Courier>ACC_PROTECTED</font>
| <font face=Courier>0x0004</font>
| Объявлен <font face=Courier>protected</font> в исходном коде
|-
| <font face=Courier>ACC_STATIC</font>
| <font face=Courier>0x0008</font>
| Объявлен <font face=Courier>static</font> в исходном коде.
|-
| <font face=Courier>ACC_FINAL</font>
| <font face=Courier>0x0010</font>
| Объявлен <font face=Courier>final</font> в исходном коде.
|-
| <font face=Courier>ACC_INTERFACE</font>
| <font face=Courier>0x0200</font>
| в исходном коде
|-
| <font face=Courier>ACC_ABSTRACT</font>
| <font face=Courier>0x0400</font>
| Объявлен <font face=Courier>abstract</font> в исходном коде.
|-
| <font face=Courier>ACC_SYNTHETIC</font>
| <font face=Courier>0x1000</font>
| Объявлен вспомогательным; отсутствует в исходном коде.
|-
| <font face=Courier>ACC_ANNOTATION</font>
| <font face=Courier>0x2000</font>
| Аннотация.
|-
| <font face=Courier>ACC_ENUM</font>
| <font face=Courier>0x4000</font>
| Перечисление.
|}

:: Все биты элемента <font face=Courier>inner_class_access_flags</font> не указанные в таблице 4.23 зарезервированы для будущего использования. Им должно быть присвоено нулевое значение при генерации <font face=Courier>class</font>-файла. Реализация виртуальной машины Java должно игнорировать биты, не указанные в таблице 4.23.

Если номер версии <font face=Courier>class</font>-файла больше либо равен 51.0 и атрибут <font face=Courier>InnerClasses</font> присутствует в таблице атрибутов, тогда для всех элементов  в массиве <font face=Courier>classes</font> атрибута <font face=Courier>InnerClasses</font> значение элемента <font face=Courier>outer_class_info_index</font>  должно быть нулевым, если значение <font face=Courier>inner_name_index</font> также ноль.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Реализация виртуальной машины Java компании <font face=Courier>Oracle</font> не проверяет взаимную согласованность атрибута <font face=Courier>InnerClasses</font> и собственно содержания <font face=Courier>class</font>-файла, представляющего класс или интерфейс, на который ссылается атрибут.
</span>
|}

<br><br><br><br>
==== Атрибут <font face=Courier>EnclosingMethod</font> ====

Атрибут <font face=Courier>EnclosingMethod</font> является необязательным атрибутом постоянной длины в таблице <font face=Courier>attributes</font> структуры <font face=Courier>ClassFile</font> (см. §4.1). Класс должен иметь атрибут <font face=Courier>EnclosingMethod</font> тогда и только тогда, когда он является локальным или анонимным классом. Класс может иметь не более одного атрибута <font face=Courier>EnclosingMethod</font>.

Атрибут <font face=Courier>EnclosingMethod</font> имеет следующий формат:

 EnclosingMethod_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 class_index;
 u2 method_index;
 }

Элементы структуры <font face=Courier>EnclosingMethod_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>EnclosingMethod</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> равно четырем.

<font face=Courier>class_index</font>
:: Значение элемента <font face=Courier>class_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1) представляющим ближайший класс, который содержит текущий класс.

<font face=Courier>method_index</font>
:: Если текущий класс не содержится непосредственно в методе или конструкторе, то значение элемента <font face=Courier>method_index</font> должно быть равно нулю.

:: В противном случае значение элемента <font face=Courier>method_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_NameAndType_info</font> (см. §4.4.6), представляющей имя и тип метода в классе, на который ссылается <font face=Courier>class_index</font> выше.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Проверка того, что метод по индексу <font face=Courier>method_index</font> в действительности является ближайшим включающим в себя данный класс, является ответственностью компилятора виртуальной машины Java.
</span>
|}

<br><br><br><br>
==== Атрибут <font face=Courier>Synthetic</font> ====

Атрибут <font face=Courier>Synthetic</font> является атрибутом фиксированной длины таблицы <font face=Courier>attributes</font> структур <font face=Courier>ClassFile</font> (см. §4.1), <font face=Courier>field_info</font> (см. §4.5) и <font face=Courier>method_info</font> (см. §4.6). Член класса, которого нет в исходном классе, должен быть помечен с помощью атрибута <font face=Courier>Synthetic</font> либо с помощью флага <font face=Courier>ACC_SYNTHETIC</font>. Единственное исключение из этого правила – это методы, сгенерированные компилятором, для которых не требуется имплементация: методы инициализации экземпляра, соответствующие конструктору по умолчанию языка программирования Java (см. §2.9), методы инициализации класса (см. §2.9), методы <font face=Courier>Enum</font>.<font face=Courier>values</font>() и <font face=Courier>Enum</font>.<font face=Courier>valueOf</font>().
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Атрибут <font face=Courier>Synthetic</font> был введен в JDK release 1.1 для поддержки вложенных классов и интерфейсов.
</span>
|}


Атрибут <font face=Courier>Synthetic</font> имеет следующий формат:

 Synthetic_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 }

Элементы структуры <font face=Courier>Synthetic_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>Synthetic</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> равно нулю.

<br><br><br><br>
==== Атрибут <font face=Courier>Signature</font> ====

Атрибут <font face=Courier>Signature</font> является необязательным атрибутом постоянной длины в таблице <font face=Courier>attributes</font> структуры <font face=Courier>ClassFile</font> (§4.1), <font face=Courier>field_info</font> (см. §4.5) и <font face=Courier>method_info</font> (см. §4.6). Атрибут <font face=Courier>Signature</font> содержит информацию о сигнатуре с обобщёнными типами для класса, интерфейса, конструктора или члена данного, чья обобщённая сигнатура в языке программирования Java содержит ссылку на переменную типа или параметризированный тип.

Атрибут <font face=Courier>Signature</font> имеет следующий формат:

 Signature_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 signature_index;
 }

Элементы структуры <font face=Courier>Signature_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>Signature</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>Signature_attribute</font> равно двум.

<font face=Courier>signature_index</font>
:: Значение элемента <font face=Courier>signature_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой сигнатуру класса (см. §4.3.4), если атрибут <font face=Courier>Signature</font> является атрибутом структуры <font face=Courier>ClassFile</font>; метода, если атрибут <font face=Courier>Signature</font> является атрибутом структуры <font face=Courier>method_info</font> или сигнатуру типа поля в противном случае.

<br><br><br><br>
==== Атрибут <font face=Courier>SourceFile</font> ====

Атрибут <font face=Courier>SourceFile</font> является необязательным атрибутом постоянной длины в таблице <font face=Courier>attributes</font> структуры <font face=Courier>ClassFile</font> (см. §4.1). Может быть не более одного атрибута <font face=Courier>SourceFile</font> в таблице <font face=Courier>attributes</font> данной структуры <font face=Courier>ClassFile</font>.

Атрибут <font face=Courier>SourceFile</font> имеет следующий формат:

 SourceFile_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 sourcefile_index;
 }

Элементы структуры <font face=Courier>SourceFile_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>SourceFile</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>SourceFile_attribute</font> равно двум.

<font face=Courier>sourcefile_index</font>
:: Значение элемента <font face=Courier>sourcefile_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку.

::Строка, на которую ссылается <font face=Courier>sourcefile_index</font>, интерпретируется как имя файла, из которого был скомпилирован <font face=Courier>class</font>-файл. Не предполагается, что данная строка будет содержать имя директории или абсолютный путь к файлу; такая платформенно зависимая дополнительная информация должна быть представлена интерпретатором времени выполнения или средствами разработки в момент, когда имя файла фактически используется.

<br><br><br><br>
==== Атрибут <font face=Courier>SourceDebugExtension</font> ====

Атрибут <font face=Courier>SourceDebugExtension</font> является необязательным атрибутом постоянной длины в таблице <font face=Courier>attributes</font> структуры <font face=Courier>ClassFile</font> (см. §4.1). Может быть не более одного атрибута <font face=Courier>SourceDebugExtension</font> в таблице <font face=Courier>attributes</font> данной структуры <font face=Courier>ClassFile</font>.

Атрибут <font face=Courier>SourceDebugExtension</font> имеет следующий формат:

 SourceDebugExtension_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u1 debug_extension[attribute_length];
 }

Элементы структуры <font face=Courier>SourceDebugExtension_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
::Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>SourceDebugExtension</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>SourceFile_attribute</font> содержит длину атрибута в байтах без учёта начальных шести байт. Поэтому значение элемента <font face=Courier>attribute_length</font> есть число байт в элементе <font face=Courier>debug_extension[]</font>.

<font face=Courier>debug_extension[]</font>
:: Массив <font face=Courier>debug_extension</font> содержит дополнительную отладочную информацию, которая не влияет на работу виртуальной машины Java. Информация представлена в виде модифицированной UTF-8 строки (см. §4.4.7) без завершающего нулевого байта.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Обратите внимание, что массив <font face=Courier>debug_extension</font> может содержать строку, длинна которой больше, чем длина строки, допустимая в классе <font face=Courier>String</font>.
</span>
|}

<br><br><br><br>
==== Атрибут <font face=Courier>LineNumberTable</font> ====

Атрибут <font face=Courier>LineNumberTable</font> является необязательным атрибутом переменной длины в таблице <font face=Courier>attributes</font> атрибута <font face=Courier>Code</font> (см. §4.7.3). Этот атрибут может быть использован отладчиком для определения того, какая часть массива  <font face=Courier>code</font> виртуальной машины Java соответствует какой строке в исходном файле.

Если атрибуты <font face=Courier>LineNumberTable</font> присутствуют в таблице <font face=Courier>attributes</font> данного атрибута <font face=Courier>Code</font>, то они могут появляться там в произвольном порядке. Более того, несколько атрибутов <font face=Courier>LineNumberTable</font> совместно могут представлять одну строку в исходном файле; то есть атрибуты <font face=Courier>LineNumberTable</font> не обязательно взаимно однозначно соответствуют строкам исходного файла.

Атрибут <font face=Courier>LineNumberTable</font> имеет следующий формат:

 LineNumberTable_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 line_number_table_length;
     { 
     u2 start_pc;
     u2 line_number; 
     } line_number_table[line_number_table_length];
 }

Элементы структуры <font face=Courier>LineNumberTable_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>LineNumberTable</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>LineNumberTable_attribute</font> содержит длину атрибута в байтах без учёта начальных шести байт.

<font face=Courier>line_number_table_length</font>
:: Значение элемента <font face=Courier>line_number_table_length</font> содержит число элементов в массиве <font face=Courier>line_number_table</font>.

<font face=Courier>line_number_table</font>[]
:: Каждый элемент массива <font face=Courier>line_number_table</font> сообщает, что номер строки в исходном файле изменился и принял новое значение в заданном смещении в массиве <font face=Courier>code</font>. Каждый элемент <font face=Courier>line_number_table</font> должен содержать два следующих элемента:

:: <font face=Courier>start_pc</font>
:::: Значение <font face=Courier>start_pc</font> указывает на индекс в массиве <font face=Courier>code</font>, где начинается новый номер строки в исходном файле соответственно. 

:::: Значение <font face=Courier>start_pc</font> должно быть меньше чем значение элемента <font face=Courier>code_length</font> атрибута <font face=Courier>Code</font>, для которого задан атрибут <font face=Courier>LineNumberTable</font>.

:: <font face=Courier>line_number</font>
:::: Значение элемента <font face=Courier>line_number</font> должно содержать соответствующий номер строки в исходном файле.

<br><br><br><br>
==== Атрибут <font face=Courier>LocalVariableTable</font> ====

Атрибут <font face=Courier>LocalVariableTable</font> является необязательным атрибутом переменной длины в таблице <font face=Courier>attributes</font> атрибута <font face=Courier>Code</font> (см. §4.7.3). Этот атрибут может быть использован отладчиком для определения значения локальной переменной во время выполнения метода.
Если атрибуты <font face=Courier>LocalVariableTable</font> присутствуют в таблице <font face=Courier>attributes</font> данного атрибута <font face=Courier>Code</font>, то они могут появляться там в произвольном порядке. Может быть не более одного атрибута <font face=Courier>LocalVariableTable</font> для одной локальной переменной в атрибуте <font face=Courier>Code</font>.

Атрибут <font face=Courier>LocalVariableTable</font> имеет следующий формат:

 LocalVariableTable_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 local_variable_table_length;
 { 	u2 start_pc;
        u2 length;
        u2 name_index;
        u2 descriptor_index;
        u2 index;
 } local_variable_table[local_variable_table_length];
 }

Элементы структуры <font face=Courier>LocalVariableTable_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>LocalVariableTable</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>LineNumberTable_attribute</font> содержит длину атрибута в байтах без учета начальных шести байт.

<font face=Courier>local_variable_table_length</font>
:: Значение элемента <font face=Courier>local_variable_table_length</font> содержит число элементов в массиве <font face=Courier>local_variable_table</font>.

<font face=Courier>local_variable_table[]</font>
:: Каждый элемент в массиве <font face=Courier>local_variable_table</font> содержит границы кода в массиве <font face=Courier>code</font>, в котором данная переменная имеет определенное значение. Он также содержит индекс в массиве локальных переменных текущего фрейма, по которому может быть найдена локальная переменная. Каждый элемент массива состоит из следующих пяти элементов:

:: <font face=Courier>start_pc</font>, <font face=Courier>length</font>
:::: Данная локальная переменная должна иметь значение в пределах индексов [<font face=Courier>start_pc</font>,  <font face=Courier>start_pc</font> + <font face=Courier>length</font>) в массиве <font face=Courier>code</font>. Это значит, что локальная переменная имеет значение, начиная с индекса <font face=Courier>start_pc</font> включительно и заканчивая <font face=Courier>start_pc</font> + <font face=Courier>length</font> не включительно.

:::: Значение <font face=Courier>start_pc</font> должно быть действительным индексом массива <font face=Courier>code</font> атрибута <font face=Courier>Code</font> и должно представлять собой индекс машинного кода инструкции виртуальной машины Java.

:::: Значение <font face=Courier>start_pc</font> + <font face=Courier>length</font> должно быть либо действительным индексом массива <font face=Courier>code</font> атрибута <font face=Courier>Code</font> и должно представлять собой индекс машинного кода инструкции виртуальной машины Java либо должно быть индексом на один большим размера массива <font face=Courier>code</font>.

:: <font face=Courier>name_index</font>
:::: Значение элемента <font face=Courier>name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой действительное имя (см. §4.2.2) локальной переменной.

:: <font face=Courier>descriptor_index</font>
:::: Значение элемента <font face=Courier>descriptor_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой дескриптор поля (см. §4.3.2) определяющий тип локальной переменной в исходном коде.

:: <font face=Courier>index</font>
:::: Данная локальная переменная должна находиться по индексу <font face=Courier>index</font> в массиве локальных переменных текущего фрейма.

:::: Если тип локальной переменной равен <font face=Courier>double</font> либо <font face=Courier>long</font>, то её значение расположено по индексам <font face=Courier>index</font> и <font face=Courier>index</font> + 1.

<br><br><br><br>
==== Атрибут <font face=Courier>LocalVariableTypeTable</font> ====

Атрибут <font face=Courier>LocalVariableTypeTable</font> является необязательным атрибутом переменной длины в таблице <font face=Courier>attributes</font> атрибута <font face=Courier>Code</font> (см. §4.7.3). Этот атрибут может быть использован отладчиком для определения значения локальной переменной во время выполнения метода.

Если атрибуты <font face=Courier>LocalVariableTypeTable</font> присутствуют в таблице <font face=Courier>attributes</font> данного атрибута <font face=Courier>Code</font>, то они могут появляться там в произвольном порядке. Может быть не более одного атрибута <font face=Courier>LocalVariableTypeTable</font> для одной локальной переменной в атрибуте <font face=Courier>Code</font>.

Атрибут <font face=Courier>LocalVariableTypeTable</font> отличается от <font face=Courier>LocalVariableTable</font> тем, что предоставляет информацию о сигнатуре, а не о дескрипторе. Это отличие имеет смысл только для тех переменных, чей тип принадлежит обобщённому типу (<font face=Courier>generic</font>). Такие переменные будут присутствовать в обеих таблицах, в то время как переменные остальных типов будут только в <font face=Courier>LocalVariableTable</font>.

Атрибут <font face=Courier>LocalVariableTypeTable</font> имеет следующий формат:

 LocalVariableTypeTable_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 local_variable_type_table_length;
 { 	u2 start_pc;
        u2 length;
        u2 name_index;
        u2 signature_index;
        u2 index;
 } local_variable_type_table[local_variable_type_table_length];
 }

Элементы структуры <font face=Courier>LocalVariableTypeTable_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>LocalVariableTypeTable</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>LineNumberTable_attribute</font> содержит длину атрибута в байтах без учета начальных шести байт.

<font face=Courier>local_variable_type_table_length</font>
:: Значение элемента <font face=Courier>local_variable_type_table_length</font> содержит число элементов в массиве <font face=Courier>local_variable_type_table</font>.

<font face=Courier>local_variable_type_table[]</font>
:: Каждый элемент в массиве <font face=Courier>local_variable_type_table</font> содержит границы кода в массиве <font face=Courier>code</font>, в котором данная переменная имеет определенное значение. Он также содержит индекс в массиве локальных переменных текущего фрейма, по которому может быть найдена локальная переменная. Каждый элемент массива состоит из следующих пяти элементов:

:: <font face=Courier>start_pc</font>, <font face=Courier>length</font>
:::: Данная локальная переменная должна иметь значение в пределах индексов [<font face=Courier>start_pc</font>,  <font face=Courier>start_pc</font> + <font face=Courier>length</font>) в массиве <font face=Courier>code</font>. Это значит, что локальная переменная имеет значение, начиная с индекса <font face=Courier>start_pc</font> включительно и заканчивая <font face=Courier>start_pc</font> + <font face=Courier>length</font> не включительно.

:::: Значение <font face=Courier>start_pc</font> должно быть действительным индексом массива <font face=Courier>code</font> атрибута <font face=Courier>Code</font> и должно представлять собой индекс машинного кода инструкции виртуальной машины Java.

:::: Значение <font face=Courier>start_pc</font> + <font face=Courier>length</font> должно быть либо действительным индексом массива <font face=Courier>code</font> атрибута <font face=Courier>Code</font> и должно представлять собой индекс машинного кода инструкции виртуальной машины Java либо должно быть индексом на один большим размера массива <font face=Courier>code</font>.

:: <font face=Courier>name_index</font>
:::: Значение элемента <font face=Courier>name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой действительное имя (см. §4.2.2) локальной переменной.

:: <font face=Courier>signature_index</font>
:::: Значение элемента <font face=Courier>signature_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой сигнатуру типа поля (см. §4.3.4) определяющую тип локальной переменной в исходном коде.

:: <font face=Courier>index</font>
:::: Данная локальная переменная должна находиться по индексу <font face=Courier>index</font> в массиве локальных переменных текущего фрейма.

:::: Если тип локальной переменной равен <font face=Courier>double</font> либо <font face=Courier>long</font>, то ее значение расположено по индексам <font face=Courier>index</font> и <font face=Courier>index</font> + 1.

<br><br><br><br>
==== Атрибут <font face=Courier>Deprecated</font> ====

Атрибут <font face=Courier>Deprecated</font> является необязательным атрибутом постоянной длины в таблице <font face=Courier>attributes</font> структур <font face=Courier>ClassFile</font> (см. §4.1), <font face=Courier>field_info</font> (см. §4.5) или <font face=Courier>method_info</font> (см. §4.6). Класс, интерфейс, метод или поле могут быть помечены с использованием атрибута <font face=Courier>Deprecated</font> как нежелательные к использованию (устаревшие).

Интерпретатор времени выполнения или инструмент для чтения <font face=Courier>class</font>-файла, такой как компилятор, может использовать данный атрибут, сообщая пользователю о том, что создана ссылка на устаревшие класс, интерфейс, метод либо поле. Присутствие атрибута <font face=Courier>Deprecated</font> не изменяет семантики класса или интерфейса.

Атрибут <font face=Courier>Deprecated</font> имеет следующий формат:

 Deprecated_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 }

Элементы структуры <font face=Courier>Deprecated_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>Deprecated</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> равно нулю.

<br><br><br><br>
==== Атрибут <font face=Courier>RuntimeVisibleAnnotations</font> ====

Атрибут <font face=Courier>RuntimeVisibleAnnotations</font> является необязательным атрибутом переменной длины в таблице <font face=Courier>attributes</font> структур <font face=Courier>ClassFile</font> (см. §4.1), <font face=Courier>field_info</font> (см. §4.5) или <font face=Courier>method_info</font> (см. §4.6). Атрибут <font face=Courier>RuntimeVisibleAnnotations</font> хранит аннотации времени выполнения языка программирования Java для соответствующего класса, поля или метода.

Каждая из структур <font face=Courier>ClassFile</font>,  <font face=Courier>field_info</font> и <font face=Courier>method_info</font> может содержать не более одного атрибута <font face=Courier>RuntimeVisibleAnnotations</font>, который содержит все аннотации времени выполнения языка программирования Java для соответствующего элемента программы. Виртуальная машина Java имеет доступ к этим аннотациям, так что они могут быть получены с помощью рефлексии и ее <font face=Courier>API</font>.

Атрибут <font face=Courier>RuntimeVisibleAnnotations</font> имеет следующий формат:

 RuntimeVisibleAnnotations_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 num_annotations;
 annotation annotations[num_annotations];
 }

Элементы структуры <font face=Courier>RuntimeVisibleAnnotations_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>RuntimeVisibleAnnotations</font>».

<font face=Courier>attribute_length</font>
::Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>LineNumberTable_attribute</font> содержит длину атрибута в байтах без учёта начальных шести байт. 

:: Значение <font face=Courier>attribute_length</font> зависит от аннотаций времени выполнения и значения этих аннотаций.

<font face=Courier>num_annotations</font>
:: Значение элемента <font face=Courier>num_annotations</font> содержит число аннотаций времени выполнения, находящихся в данной структуре.

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Программный элемент может иметь до 65535 аннотаций времени выполнения языка программирования Java.
</span>
|}

<font face=Courier>annotations</font>
:: Каждый элемент в таблице <font face=Courier>annotations</font> представляет собой одну аннотацию времени выполнения для программного элемента. Структура аннотации имеет следующий формат:

 annotation {
 u2 type_index;
 u2 num_element_value_pairs;
 { 	u2 element_name_index;
 element_value value;
 } element_value_pairs[num_element_value_pairs];
 }

Элементы структуры <font face=Courier>annotation</font> следующие:

<font face=Courier>type_index</font>
:: Значение элемента <font face=Courier>type_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой дескриптор поля, который описывает тип аннотации, представленной в данной структуре <font face=Courier>annotation</font>.

<font face=Courier>num_element_value_pairs</font>
:: Значение элемента <font face=Courier>num_element_value_pairs</font> равно числу пар элемент-значение, представленных в данной структуре <font face=Courier>annotation</font>.

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. В одной аннотации может содержаться до 65535 пар элемент-значение.
</span>
|}

<font face=Courier>element_value_pairs</font>
:: Каждое значение в таблице <font face=Courier>element_value_pairs</font> представляет собой одну пару элемент-значение, принадлежащую данной структуре <font face=Courier>annotation</font>. 

:: Каждый элемент из <font face=Courier>element_value_pairs</font> содержит два следующие элемента:

:: <font face=Courier>element_name_index</font>
:::: Значение элемента <font face=Courier>element_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой действительный дескриптор поля (см. §4.3.2), который обозначает имя типа аннотации, находящегося в паре <font face=Courier>element_value_pairs</font>.

:: <font face=Courier>value</font>
:::: Элемент <font face=Courier>value</font> представляет собой значение пары элемент-значение, находящейся в таблице <font face=Courier>element_value_pairs</font>.

<br><br><br><br>
===== Структура <font face=Courier>element_value</font> =====

Структура <font face=Courier>element_value</font> является отдельным элементом, содержащим значение из пары элемент-значение. Она используется для представления значения элемента во всех атрибутах, которые описывают аннотации (<font face=Courier>RuntimeVisibleAnnotations</font>,
<font face=Courier>RuntimeInvisibleAnnotations</font>,  <font face=Courier>RuntimeVisibleParameterAnnotations</font>, и
<font face=Courier>RuntimeInvisibleParameterAnnotations</font>).

Структура <font face=Courier>element_value</font> имеет следующий формат:

 element_value {
 u1 tag;
 union {
 u2 const_value_index;
 
 { 	u2 type_name_index;
        u2 const_name_index;
 } enum_const_value;
 
 u2 class_info_index;
 
 annotation annotation_value;
 
 { u2 num_values;
        element_value values[num_values];
 } array_value;
 } value;
 }

Элементы структуры <font face=Courier>element_value</font> следующие:

<font face=Courier>tag</font>
:: Элемент <font face=Courier>tag</font> определяет тип данной пары элемент-значение. Литеры «<font face=Courier>B</font>», «<font face=Courier>C</font>», «<font face=Courier>D</font>», «<font face=Courier>F</font>», «<font face=Courier>I</font>», «<font face=Courier>J</font>»,«<font face=Courier>S</font>», и «<font face=Courier>Z</font>» определяют примитивные типы. Они интерпретируются согласно таблице примитивных типов (см. Таблицу 4.2). Остальные допустимые значения для элемента <font face=Courier>tag</font> и их интерпретация приведены в Таблице 4.24.

:: '''Таблица 4.24 Дополнительные значения элемента <font face=Courier>tag</font>'''
{| border="1" style="border-collapse:collapse; margin-left: 46px;"
! Значение элемента <font face=Courier>tag</font>
! Тип элемента
|-
| <font face=Courier>s</font>
| <font face=Courier>String</font>
|-
| <font face=Courier>e</font>
| Перечисление
|-
| <font face=Courier>c</font>
| Класс
|-
| <font face=Courier>@</font>
| Аннотация
|-
| <font face=Courier>[</font>
| Массив
|}

<font face=Courier>value</font>
:: Элемент <font face=Courier>value</font> представляет собой значение аннотации. Он представляет собой объединение (<font face=Courier>union</font> — структура данных, члены которой расположены по одному и тому же адресу. Размер объединения равен размеру его наибольшего члена. В любой момент времени объединение хранит значение только одного из членов. – прим. перев.). Элемент <font face=Courier>tag</font> (см. выше) определяет какой именно элемент из объединения будет использован:

<font face=Courier>const_value_index</font>
:: Элемент <font face=Courier>const_value_index</font> используется, если <font face=Courier>tag</font> принимает значение «<font face=Courier>B</font>», «<font face=Courier>C</font>», «<font face=Courier>D</font>»,«<font face=Courier>F</font>», «<font face=Courier>I</font>», «<font face=Courier>J</font>», «<font face=Courier>S</font>», «<font face=Courier>Z</font>» или «<font face=Courier>s</font>». Значение элемента <font face=Courier>const_value_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой, представляющей собой корректную константу, соответствующую элементу <font face=Courier>tag</font> (см. Таблицу 4.24).

<font face=Courier>enum_const_value</font>
:: Элемент <font face=Courier>enum_const_value</font> используется, если <font face=Courier>tag</font> равен «e». Элемент <font face=Courier>enum_const_value</font> состоит из следующих двух элементов:

:: <font face=Courier>type_name_index</font>
:::: Значение элемента <font face=Courier>type_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой действительный дескриптор поля (см. §4.3.2), который обозначает внутреннюю форму двоичного имени (см. §4.2.1) типа перечисления, соответствующего структуре <font face=Courier>element_value</font>.

:: <font face=Courier>const_name_index</font>
:::: Значение элемента <font face=Courier>const_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой простое имя константы из перечисления, соответствующей структуре <font face=Courier>element_value</font>.


<font face=Courier>class_info_index</font>
:: Элемент <font face=Courier>class_info_index</font> используется, если <font face=Courier>tag</font> равен «c». Значение элемента <font face=Courier>const_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой дескриптор возвращаемого значения (см. §4.3.3), определяющий класс для структуры <font face=Courier>element_value</font>.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Например, «V» для <font face=Courier>Void</font>.<font face=Courier>class</font>, «<font face=Courier>Ljava</font>/<font face=Courier>lang</font>/<font face=Courier>Object</font>;» для <font face=Courier>Object</font> и так далее.
</span>
|}
<br>

<font face=Courier>annotation_value</font>
:: Элемент <font face=Courier>annotation_value</font> используется, если <font face=Courier>tag</font> равен «@». Структура <font face=Courier>element_value</font> представляет вложенную аннотацию.

<font face=Courier>array_value</font>
:: Элемент <font face=Courier>array_value</font> используется, если <font face=Courier>tag</font> равен «[». Элемент <font face=Courier>array_value</font> состоит из следующих двух элементов:

<font face=Courier>num_values</font>
:: Значение <font face=Courier>num_values</font> определяет число элементов в массиве, который соответствует структуре <font face=Courier>element_value</font>.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Допустимо не более 65535 значений в массиве.
</span>
|}
<br>

<font face=Courier>values</font>
:: Каждое значение таблицы <font face=Courier>values</font> представляет собой значения массива, соответствующего структуре <font face=Courier>element_value</font>.

<br><br><br><br>
==== Атрибут <font face=Courier>RuntimeInvisibleAnnotations</font> ====

	Атрибут <font face=Courier>RuntimeInvisibleAnnotations</font> похож на <font face=Courier>RuntimeVisibleAnnotations</font> за исключением того, что аннотации, представленные в атрибуте <font face=Courier>RuntimeVisibleAnnotations</font> не доступны с помощью механизма рефлексии, до тех пор, пока виртуальной машине Java не будет выдана команда сделать доступными эти аннотации, например с помощью флага командной строки. Если такой команды нет, виртуальная машина игнорирует данный атрибут.

Атрибут <font face=Courier>RuntimeInvisibleAnnotations</font> является необязательным атрибутом переменной длины в таблице <font face=Courier>attributes</font> структур <font face=Courier>ClassFile</font> (см. §4.1), <font face=Courier>field_info</font> (см. §4.5) или <font face=Courier>method_info</font> (см. §4.6). Атрибут <font face=Courier>RuntimeInvisibleAnnotations</font> хранит аннотации времени выполнения языка программирования Java для соответствующего класса, поля или метода.

Каждая из структур <font face=Courier>ClassFile</font>,  <font face=Courier>field_info</font> и <font face=Courier>method_info</font> может содержать не более одного атрибута <font face=Courier>RuntimeInvisibleAnnotations</font>, который содержит все не видимые во время выполнения аннотации языка программирования Java для соответствующего элемента программы.

Атрибут <font face=Courier>RuntimeInvisibleAnnotations</font> имеет следующий формат:

 RuntimeInvisibleAnnotations_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 num_annotations;
 annotation annotations[num_annotations];
 }

Элементы структуры <font face=Courier>RuntimeInvisibleAnnotations_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>RuntimeInvisibleAnnotations</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>LineNumberTable_attribute</font> содержит длину атрибута в байтах без учета начальных шести байт. 

:: Значение <font face=Courier>attribute_length</font> зависит от аннотаций времени выполнения и значения этих аннотаций.

<font face=Courier>num_annotations</font>
:: Значение элемента <font face=Courier>num_annotations</font> содержит число аннотаций времени выполнения, находящихся в данной структуре.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Программный элемент может иметь до 65535 аннотаций времени выполнения языка программирования Java.
</span>
|}
<br>

<font face=Courier>annotations</font>
:: Каждый элемент в таблице <font face=Courier>annotations</font> представляет собой одну аннотацию времени выполнения для программного элемента.

<br><br><br><br>
==== Атрибут <font face=Courier>RuntimeVisibleParameterAnnotations</font> ====

Атрибут <font face=Courier>RuntimeVisibleParameterAnnotations</font> является необязательным атрибутом переменной длины в таблице <font face=Courier>attributes</font> структуры <font face=Courier>method_info</font> (см. §4.6). Атрибут <font face=Courier>RuntimeVisibleParameterAnnotations</font> хранит аннотации времени выполнения языка программирования Java для параметра соответствующего метода.

Каждая структура <font face=Courier>method_info</font> может содержать не более одного атрибута <font face=Courier>RuntimeVisibleParameterAnnotations</font>, который содержит все аннотации времени выполнения языка программирования Java для соответствующего параметра метода. Виртуальная машина Java имеет доступ к этим аннотациям, так что они могут быть получены с помощью рефлексии и её <font face=Courier>API</font>.

Атрибут <font face=Courier>RuntimeVisibleParameterAnnotations</font> имеет следующий формат:

 RuntimeVisibleParameterAnnotations_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u1 num_parameters;
 { 	u2 num_annotations;
        annotation annotations[num_annotations];
 } parameter_annotations[num_parameters];
 }

Элементы структуры <font face=Courier>RuntimeVisibleParameterAnnotations_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>RuntimeVisibleParameterAnnotations</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>LineNumberTable_attribute</font> содержит длину атрибута в байтах без учета начальных шести байт.

:: Значение <font face=Courier>attribute_length</font> зависит от числа параметров, числа аннотаций времени выполнения для каждого параметра и значения этих аннотаций.

<font face=Courier>num_parameters</font>
:: Значение элемента <font face=Courier>num_parameters</font> представляет собой число параметров метода в структуре <font face=Courier>method_info</font>, для которых заданы аннотации. (Это дублирует информацию, которая может быть получена и дескриптора метода (см. §4.3.3).)

<font face=Courier>parameter_annotations</font>
:: Каждое значение в таблице <font face=Courier>parameter_annotations</font> представляет собой все аннотации времени выполнения для данного параметра. Последовательность элементов в таблице соответствует последовательности параметров в дескрипторе метода. Каждый элемент из <font face=Courier>parameter_annotations</font> содержит два элемента:

:: <font face=Courier>num_annotations</font>
:::: Значение элемента <font face=Courier>num_annotations</font> содержит число аннотаций времени выполнения для параметра, чей порядковый номер соответствует порядковому номеру данного элемента в таблице <font face=Courier>parameter_annotations</font>.

:: <font face=Courier>annotations</font>
:::: Каждый элемент в таблице <font face=Courier>annotations</font> представляет собой одну аннотацию времени выполнения для параметра, чей порядковый номер соответствует порядковому номеру данного элемента в таблице <font face=Courier>parameter_annotations</font>.

<br><br><br><br>
==== Атрибут <font face=Courier>RuntimeInvisibleParameterAnnotations</font> ====

Атрибут <font face=Courier>RuntimeInvisibleParameterAnnotations</font> похож на <font face=Courier>RuntimeVisibleParameterAnnotations</font> за исключением того, что аннотации, представленные в атрибуте  <font face=Courier>RuntimeInvisibleParameterAnnotations</font> не доступны с помощью механизма рефлексии, до тех пор, пока виртуальной машине Java не будет выдана команда сделать доступными эти аннотации, например с помощью флага командной строки. Если такой команды нет, виртуальная машина игнорирует данный атрибут.

Атрибут <font face=Courier>RuntimeInvisibleParameterAnnotations</font> является необязательным атрибутом переменной длины в таблице <font face=Courier>attributes</font> структуры <font face=Courier>method_info</font> (см. §4.6). Атрибут <font face=Courier>RuntimeVisibleParameterAnnotations</font> хранит не видимые во время выполнения аннотации языка программирования Java для параметра соответствующего метода.

Каждая структура <font face=Courier>method_info</font> может содержать не более одного атрибута <font face=Courier>RuntimeInvisibleParameterAnnotations</font>, который содержит все не видимые во время выполнения аннотации языка программирования Java для соответствующего параметра метода.

Атрибут <font face=Courier>RuntimeInvisibleParameterAnnotations</font> имеет следующий формат:

 RuntimeInvisibleParameterAnnotations_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u1 num_parameters;
 { u2 num_annotations;
   annotation annotations[num_annotations];
 } parameter_annotations[num_parameters];
 }

Элементы структуры <font face=Courier>RuntimeInvisibleParameterAnnotations_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>RuntimeInvisibleParameterAnnotations</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> структуры <font face=Courier>LineNumberTable_attribute</font> содержит длину атрибута в байтах без учета начальных шести байт.
Значение <font face=Courier>attribute_length</font> зависит от числа параметров, числа аннотаций, не видимых во время выполнения для каждого параметра и значения этих аннотаций.

<font face=Courier>num_parameters</font>
:: Значение элемента <font face=Courier>num_parameters</font> представляет собой число параметров метода в структуре <font face=Courier>method_info</font>, для которых заданы аннотации. (Это дублирует информацию, которая может быть получена и дескриптора метода (см. §4.3.3).)

<font face=Courier>parameter_annotations</font>
:: Каждое значение в таблице <font face=Courier>parameter_annotations</font> представляет собой все аннотации времени выполнения для данного параметра. Последовательность элементов в таблице соответствует последовательности параметров в дескрипторе метода. Каждый элемент из <font face=Courier>parameter_annotations</font> содержит два элемента:

:: <font face=Courier>num_annotations</font>
:::: Значение элемента <font face=Courier>num_annotations</font> содержит число аннотаций времени выполнения для параметра, чей порядковый номер соответствует порядковому номеру данного элемента в таблице <font face=Courier>parameter_annotations</font>.

:: <font face=Courier>annotations</font>
:::: Каждый элемент в таблице <font face=Courier>annotations</font> представляет собой одну аннотацию времени выполнения для параметра, чей порядковый номер соответствует порядковому номеру данного элемента в таблице <font face=Courier>parameter_annotations</font>.

<br><br><br><br>
==== Атрибут <font face=Courier>AnnotationDefault</font> ====

Атрибут <font face=Courier>AnnotationDefault</font> является необязательным атрибутом переменной длины в таблице <font face=Courier>attributes</font> структуры <font face=Courier>method_info</font> (см. §4.6), который может присутствовать там, где присутствуют аннотации других типов. Атрибут <font face=Courier>AnnotationDefault</font> содержит значение по умолчанию для аннотации, находящейся в структуре <font face=Courier>method_info</font>.

Каждая структура <font face=Courier>method_info</font> может содержать не более одного атрибута <font face=Courier>AnnotationDefault</font>. Виртуальная машина Java должна иметь доступ к этим аннотациям, так что они могут быть получены с помощью рефлексии и ее <font face=Courier>API</font>.

Атрибут <font face=Courier>AnnotationDefault</font> имеет следующий формат:

 AnnotationDefault_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 element_value default_value;
 }

Элементы структуры <font face=Courier>AnnotationDefault_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>AnnotationDefault</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> содержит длину атрибута в байтах без учёта начальных шести байт. Значение <font face=Courier>attribute_length</font> зависит от значения по умолчанию.

<font face=Courier>default_value</font>
:: Элемент <font face=Courier>default_value</font> представляет собой значение по умолчанию для аннотации, соответствующей атрибуту <font face=Courier>AnnotationDefault</font>.

<br><br><br><br>
==== Атрибут <font face=Courier>BootstrapMethods</font> ====

Атрибут <font face=Courier>BootstrapMethods</font> является атрибутом переменной длины в таблице <font face=Courier>attributes</font> структуры <font face=Courier>ClassFile</font> (см. §4.1). Атрибут <font face=Courier>BootstrapMethods</font> содержит спецификаторы загрузочных методов, на которые ссылается инструкция ''invokedynamic''.

Должен быть один и только один атрибут <font face=Courier>BootstrapMethods</font> в таблице <font face=Courier>attributes</font> данной структуры  <font face=Courier>ClassFile</font>, если таблица  <font face=Courier>constant_pool</font> структуры  <font face=Courier>ClassFile</font> имеет, по крайней мере, один элемент <font face=Courier>CONSTANT_InvokeDynamic_info</font> (см. §4.4.10). Может быть не более одного атрибута <font face=Courier>BootstrapMethods</font> в таблице <font face=Courier>attributes</font> данной структуры <font face=Courier>ClassFile</font>.

Атрибут <font face=Courier>BootstrapMethods</font> имеет следующий формат:

 BootstrapMethods_attribute {
 u2 attribute_name_index;
 u4 attribute_length;
 u2 num_bootstrap_methods;
 { 	u2 bootstrap_method_ref;
        u2 num_bootstrap_arguments;
        u2 bootstrap_arguments[num_bootstrap_arguments];
 } bootstrap_methods[num_bootstrap_methods];
 }

Элементы структуры <font face=Courier>BootstrapMethods_attribute</font> следующие:

<font face=Courier>attribute_name_index</font>
:: Значение элемента <font face=Courier>attribute_name_index</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Значение в таблице <font face=Courier>constant_pool</font> с упомянутым выше индексом должно быть структурой <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7), представляющей собой строку «<font face=Courier>BootstrapMethods</font>».

<font face=Courier>attribute_length</font>
:: Значение элемента <font face=Courier>attribute_length</font> содержит длину атрибута в байтах без учёта начальных шести байт.

:: Значение элемента <font face=Courier>attribute_length</font> зависит от числа инструкций ''invokedynamic'' в данной структуре <font face=Courier>ClassFile</font>.

<font face=Courier>num_bootstrap_methods</font>
:: Значение элемента <font face=Courier>num_bootstrap_methods</font> определяет число спецификаторов загрузочных методов в массиве <font face=Courier>bootstrap_methods</font>.

<font face=Courier>bootstrap_methods[]</font>
:: Каждый элемент массива <font face=Courier>bootstrap_methods</font> содержит указатель на структуру <font face=Courier>CONSTANT_MethodHandle_info</font> (см. §4.4.8), которая определяет загрузочный метод, и набор указателей (возможно пустой) на ''статические аргументы'' загрузочного метода.

:: Каждый элемент массива <font face=Courier>bootstrap_methods</font> должен содержать следующие три элемента:

:: <font face=Courier>bootstrap_method_ref</font>
:::: Значение <font face=Courier>bootstrap_method_ref</font> должно быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Элемент <font face=Courier>constant_pool</font> по этому индексу должен представлять собой структуру <font face=Courier>CONSTANT_MethodHandle_info</font> (см. §4.4.8)
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 92px;" |
|
<span style="font-size:88%">Примечание. Элемент <font face=Courier>reference_kind</font> структуры <font face=Courier>CONSTANT_MethodHandle_info</font> должен иметь значение 6 (<font face=Courier>REF_invokeStatic</font>) или 8 (<font face=Courier>REF_newInvokeSpecial</font>) (см. §5.4.3.5). В противном случае вызов обработчика загрузочного метода входе разрешения спецификатора узла вызова для инструкции <font face=Courier>invokedynamic</font> будет завершен аварийно.
</span>
|}
<br>

:: <font face=Courier>num_bootstrap_arguments</font>
:::: Значение элемента <font face=Courier>num_bootstrap_arguments</font> содержит число элементов в массиве <font face=Courier>bootstrap_arguments</font>.

:: <font face=Courier>bootstrap_arguments</font>
:::: Каждый элемент массива <font face=Courier>bootstrap_arguments</font> должен быть действительным индексом таблицы <font face=Courier>constant_pool</font>. Элемент <font face=Courier>constant_pool</font> по этому индексу должен быть одной из следующих структур: <font face=Courier>CONSTANT_String_info</font> (см. §4.4.3),  <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1), <font face=Courier>CONSTANT_Integer_info</font> (см. §4.4.4),  <font face=Courier>CONSTANT_Long_info</font> (см. §4.4.5), <font face=Courier>CONSTANT_Float_info</font> (см. §4.4.4),  <font face=Courier>CONSTANT_Double_info</font> (см. §4.4.5), <font face=Courier>CONSTANT_MethodHandle_info</font> (см. §4.4.8), либо <font face=Courier>CONSTANT_MethodType_info</font> (см. §4.4.9).

<br><br><br><br>
=== Проверка формата === 

Когда потенциальный <font face=Courier>class</font>-файл загружается (см. §5.3) виртуальной машиной Java, то виртуальная машина Java сначала проверяет, что формат загружаемого файла соответствует формату <font face=Courier>class</font>-файла (см. §4.1). Этот процесс известен как ''проверка формата''. Первые четыре байта должны содержать правильное кодовое число. Все распознанные атрибуты должны иметь соответствующую длину. <font face=Courier>Class</font>-файл не должен быть обрезанным или иметь лишние байты в конце. Константный пул не должен содержать не распознаваемую информацию.

Эта базовая проверка целостности <font face=Courier>class</font>-файла необходима при любой дальнейшей интерпретации содержимого <font face=Courier>class</font>-файла.

Проверка формата отличается от проверки байт-кода. Оба процесса являются частью процесса верификации.  Исторически, проверку формата часто путают с проверкой байт-кода, поскольку обе проверки являются проверками целостности.

<br><br><br><br>
=== Ограничения для кода виртуальной машины Java ===

Виртуальная машина Java хранит исходный код метода, инициализирующего метода экземпляра  (см. §2.9), класса или интерфейса (см. §2.9) хранит в массиве <font face=Courier>code</font> атрибута <font face=Courier>Code</font> структуры <font face=Courier>method_info</font> <font face=Courier>class</font>-файла (см. §4.7.3). Этот раздел посвящён ограничениям, связанным с содержимым структуры <font face=Courier>Code_attribute</font>.

<br><br><br><br>
==== Статические ограничения ====

Статические ограничения <font face=Courier>class</font>-файла – ограничения, проверяющие формальную правильность <font face=Courier>class</font>-файла. За исключением ограничений для кода виртуальной машины Java, эти ограничения были представлены в предыдущем разделе. Статические ограничения для кода виртуальной машины Java определяют, как инструкции виртуальной машины Java должны быть расположены в массиве <font face=Courier>code</font> и каковы должны быть операнды отдельных инструкций.

Статические ограничения для инструкций в массиве <font face=Courier>code</font>:

* Массив <font face=Courier>code</font> не должен быть пустым, то есть элемент <font face=Courier>code_length</font> не должен быть равным нулю.

* Значение <font face=Courier>code_length</font> должно быть меньше 65536.

* Байт-код первой инструкции должен начинаться с индекса 0.

* В массиве <font face=Courier>code</font> должны присутствовать только коды инструкций, описанных в §6.5. Зарезервированные коды инструкций (см. §6.2) или любые не задокументированные данной спецификацией коды не должны присутствовать в массиве <font face=Courier>code</font>.

* Если версия <font face=Courier>class</font>-файла 51.0 или выше, то коды инструкций ''jsr'' и ''jsr_w'' не должны присутствовать в массиве <font face=Courier>code</font>.

* Для каждой инструкции в массиве <font face=Courier>code</font> за исключением последней, индекс каждой следующей инструкции равен индексу текущей инструкции плюс длина инструкции, включая все операнды.

: Инструкция ''wide'' рассматривается так же, как и любая другая инструкция; байт-код, который расширяется с помощью инструкции ''wide'', рассматривается как один из операндов этой инструкции. В ходе работы программы непосредственный переход к этому байт-коду (минуя ''wide'') не должен совершаться.

* Последний байт последней инструкции должен находиться по индексу <font face=Courier>code_length</font> - 1.

: Статические ограничения для операндов инструкций в массиве <font face=Courier>code</font>:

* Целевой адрес перехода для каждой из инструкций передачи управления (''jsr'',  ''jsr_w'',  ''goto'',  ''goto_w'', ''ifeq'',  ''ifne'',  ''ifle'',  ''iflt'',  ''ifge'',  ''ifgt'',  ''ifnull'',  ''ifnonnull'',  ''if_icmpeq'',  ''if_icmpne'',  ''if_icmple'', ''if_icmplt'',  ''if_icmpge'',  ''if_icmpgt'',  ''if_acmpeq'',  ''if_acmpne'') должен быть байт-кодом операции в границах метода.

: Целевой адрес перехода для инструкций передачи управления, не может указывать на операнд инструкции ''wide'' (являющийся расширяемой инструкцией). Адрес перехода для такой составной команды должен всегда указывать на саму инструкцию ''wide''.

* Каждый целевой адрес, включая адрес по умолчанию каждой инструкции ''tableswitch'' должен указывать на байт-код в пределах метода.

: Каждая инструкция ''tableswitch'' должна иметь число элементов в таблице переходов, соответствующее значениям операндов <font face=Courier>low</font> и <font face=Courier>high</font>, при этом операнд <font face=Courier>low</font> должен быть меньше либо равен операнду <font face=Courier>high</font>.

: Целевой адрес перехода для ''tableswitch'', не может указывать на операнд инструкции ''wide'' (являющийся расширяемой инструкцией). Адрес перехода для такой составной команды должен всегда указывать на саму инструкцию ''wide''.

* Каждый целевой адрес, включая адрес по умолчанию каждой инструкции ''lookupswitch'' должен указывать на байт-код в пределах метода.

: Каждая ''lookupswitch'' инструкция должна иметь число пар значение-смещение  в соответствии со значением операнда <font face=Courier>npairs</font>. Пары значение-смещение  должны быть расположены в порядке возрастания величины знакового значения.

: Целевой адрес перехода для ''lookupswitch'', не может указывать на операнд инструкции ''wide'' (являющийся расширяемой инструкцией). Адрес перехода для такой составной команды должен всегда указывать на саму инструкцию ''wide''.

* Операнд каждой из инструкций ''ldc'' и ''ldc_w'' должен быть действительным индексом в таблице <font face=Courier>constant_pool</font>. Элемент константного пула по этому индексу должен иметь тип:

::* <font face=Courier>CONSTANT_Integer</font>, <font face=Courier>CONSTANT_Float</font>, либо <font face=Courier>CONSTANT_String</font>, если версия <font face=Courier>class</font>-файла меньше 49.0.

::* <font face=Courier>CONSTANT_Integer</font>, <font face=Courier>CONSTANT_Float</font>, <font face=Courier>CONSTANT_String</font>, либо <font face=Courier>CONSTANT_Class</font>, если версия <font face=Courier>class</font>-файла равна 49.0 или 50.0.

::* <font face=Courier>CONSTANT_Integer</font>, <font face=Courier>CONSTANT_Float</font>, <font face=Courier>CONSTANT_String</font>, <font face=Courier>CONSTANT_Class</font>, <font face=Courier>CONSTANT_MethodType</font>, либо <font face=Courier>CONSTANT_MethodHandle</font>, если версия <font face=Courier>class</font>-файла равна 51.0.

* Операнды каждой инструкции ''ldc2_w'' должны представлять собой действительный индекс в таблице <font face=Courier>constant_pool</font>. Элемент константного пула по этому индексу должен иметь тип <font face=Courier>CONSTANT_Long</font> или <font face=Courier>CONSTANT_Double</font>.

: В дополнение к этому, последующий индекс в константном пуле должен также быть  действительным индексом и значение константного пула по этому индексу не должно использоваться.

* Операнды инструкций ''getfield'', ''putfield'', ''getstatic'' и ''putstatic'' должны представлять собой действительный индекс в таблице <font face=Courier>constant_pool</font>. Элемент константного пула по этому индексу должен иметь тип <font face=Courier>CONSTANT_Fieldref</font>.

* Операнды <font face=Courier>indexbyte</font> инструкций ''invokevirtual'',  ''invokespecial'' и  ''invokestatic'' должны представлять собой действительный индекс в таблице <font face=Courier>constant_pool</font>. Элемент константного пула по этому индексу должен иметь тип <font face=Courier>CONSTANT_Methodref</font>.

* Операнды <font face=Courier>indexbyte</font> инструкции ''invokedynamic'' должны представлять собой действительный индекс в таблице <font face=Courier>constant_pool</font>. Элемент константного пула по этому индексу должен иметь тип <font face=Courier>CONSTANT_InvokeDynamic</font>.

: Третий и четвёртый байты операндов каждой из инструкции ''invokedynamic'' должны иметь нулевое значение.

* Только для инструкции ''invokespecial'' допустимо вызывать инициализирующий метод экземпляра (см. §2.9).

: Никакой другой метод, начинающийся с символа «<» («<font face=Courier>\u003c</font>») не может быть вызван инструкцией вызова метода непосредственно. В частности, инициализирующий метод класса или интерфейса, имеющий имя <font face=Courier><clinit></font> никогда не вызывается явно из инструкций виртуальной машины Java, а вызывается неявно только самой виртуальной машиной Java.

* Операнды <font face=Courier>indexbyte</font> инструкции ''invokeinterface'' должны представлять собой действительный индекс в таблице <font face=Courier>constant_pool</font>. Элемент константного пула по этому индексу должен иметь тип <font face=Courier>CONSTANT_InterfaceMethodref</font>.

: Значение операнда <font face=Courier>count</font> каждой инструкции ''invokeinterface'' должно отражать число локальных переменных необходимых для хранения аргументов, передаваемых в метод. Это описано в дескрипторе структуры <font face=Courier>CONSTANT_NameAndType_info</font>, на которую ссылается элемент константного пула <font face=Courier>CONSTANT_InterfaceMethodref</font>.

: Четвёртый байт операнда каждой инструкции ''invokeinterface'' должен иметь нулевое значение.

* Операнды инструкций ''instanceof'',  ''checkcast'', ''new'' и  ''anewarray'' и операнды ''indexbyte'' каждой инструкции ''multianewarray'' должны представлять собой действительный индекс в таблице <font face=Courier>constant_pool</font>. Элемент константного пула по этому индексу должен иметь тип <font face=Courier>CONSTANT_Class</font>.

* Инструкция ''anewarray'' не должна использоваться для создания массива с более чем 255 размерностью.

* Инструкция ''new'' не должна ссылаться на элемент <font face=Courier>CONSTANT_Class</font>  таблицы <font face=Courier>constant_pool</font>, представляющий собой массив. Инструкция ''new'' не может использоваться для создания массива.

* Инструкция ''multianewarray'' должна использоваться для создания массива, имеющего, по крайней мере, столько размерностей, сколько указано в его операнде ''размерность''. Это значит, что от инструкции ''multianewarray'' не требуется создавать все размерности (если их в константном пуле, на элемент которого ссылается операнд ''indexbyte'',  указано больше чем в операнде ''размерность'').

: Операнд ''размерность'' каждой инструкции ''multianewarray'' не должен быть нулём.

* Операнд <font face=Courier>atype</font> каждой инструкции ''newarray'' должен принимать одно из значений <font face=Courier>T_BOOLEAN</font>(4),  <font face=Courier>T_CHAR</font>(5),  <font face=Courier>T_FLOAT</font>(6),  <font face=Courier>T_DOUBLE</font>(7),  <font face=Courier>T_BYTE</font>(8),  <font face=Courier>T_SHORT</font>(9), <font face=Courier>T_INT</font>(10) либо <font face=Courier>T_LONG</font>(11).

* Операнд индекс каждой из инструкций ''iload'', ''fload'', ''aload'', ''istore'', ''fstore'', ''astore'', ''iinc'' и ''ret'' должен быть не отрицательным целым числом не превосходящим <font face=Courier>max_locals</font> - 1.

* Неявный индекс каждой из инструкций ''iload_<n>'',  ''fload_<n>'',  ''aload_<n>'',  ''istore_<n>'', ''fstore_<n>'' и  ''astore_<n>'' должен быть числом не превосходящим <font face=Courier>max_locals</font> - 1.

* Операнд индекс каждой из инструкций ''lload'',  ''dload'',  ''lstore'' и ''dstore'' должен быть числом не превосходящим <font face=Courier>max_locals</font> - 2.

* Неявный индекс каждой из инструкций ''lload_<n>'',  ''dload_<n>'',  ''lstore_<n>'' и  ''dstore_<n>'' должен быть числом не превосходящим <font face=Courier>max_locals</font> - 2.

* Операнд <font face=Courier>indexbyte</font> каждой инструкции ''wide'', модифицирующей инструкции ''iload'',  ''fload'', ''aload'',  ''istore'',  ''fstore'',  ''astore'',  ''ret'' либо ''iinc'' должен быть не отрицательным целым числом не превосходящим <font face=Courier>max_locals</font> - 1.

* Операнд <font face=Courier>indexbyte</font> каждой инструкции ''wide'', модифицирующей инструкции ''lload'',  ''dload'', ''lstore'' либо  ''dstore'' должен быть не отрицательным целым числом не превосходящим <font face=Courier>max_locals</font> - 2.

<br><br><br><br>
==== Структурные ограничения ====

Структурные ограничения на массив <font face=Courier>code</font> представляют собой ограничения на взаимное использование инструкций друг с другом. Существуют следующие структурные ограничения:

* Каждая инструкция должна быть выполнена только с соответствующим типом и числом аргументов в стеке операндов и необходимыми локальными переменными, вне зависимости от того как и какие инструкции были выполнены до этого.

: Для инструкции, работающей со значениями типа <font face=Courier>int</font> также допустимо оперировать значениями типа <font face=Courier>boolean</font>,  <font face=Courier>byte</font>,  <font face=Courier>char</font> и <font face=Courier>short</font>. (Как указано в  §2.3.4 и §2.11.1 виртуальная машина Java неявно конвертирует значения типов <font face=Courier>boolean</font>,  <font face=Courier>byte</font>,  <font face=Courier>char</font>, и <font face=Courier>short</font> к типу <font face=Courier>int</font>.)

* Если инструкция может быть выполнена по нескольким различным путям выполнения, то стек операндов должен иметь одинаковую глубину (см. §2.6.2) до момента выполнения инструкции вне зависимости от выбранного пути исполнения.

* Во время выполнения инструкций виртуальной машины запрещено менять местами, разделять или рассматривать по отдельности части переменной, содержащей значение типа <font face=Courier>long</font> либо <font face=Courier>double</font>.

* Если локальной переменной (или паре локальных переменных в случае значений типа <font face=Courier>long</font> или <font face=Courier>double</font>) не присвоено значение, то доступ к ним запрещён.

* Во время выполнения инструкций виртуальной машины запрещено увеличивать глубину стека операндов (см. §2.6.2) более чем указано элементом <font face=Courier>max_stack</font>.

* Во время выполнения инструкций виртуальной машины запрещено считывать из стека операндов больше значений, чем находится.

* Каждой инструкции ''invokespecial'' должен соответствовать инициализирующий метод экземпляра (см. §2.9). Он может быть в текущем классе или в предке текущего класса.

: Если инструкции ''invokespecial''  соответствует инициализирующий метод экземпляра не из текущего класса или его предка и целевая ссылка в стеке операндов указывает на экземпляр класса, созданный ранее инструкцией ''new'', то ''invokespecial''  должен соответствовать инициализирующий метод экземпляра из экземпляра класса по целевой ссылке в стеке операндов.

* Когда вызывается инициализирующий метод экземпляра (см. §2.9), то неинициализированный экземпляр класса должен быть в соответствующей позиции в стеке операндов.

: Инициализирующий метод экземпляра не должен вызываться для уже инициализированного экземпляра класса.

* Когда вызывается метод экземпляра или производится обращение к переменной экземпляра, то экземпляр класса, который содержит метод или переменную, должен быть уже инициализирован.

* Не инициализированный экземпляр класса не должен находиться в стеке операндов или в локальной переменной в качестве целевого класса возвратной ветви программы. Исключение составляет специальный тип не инициализированного экземпляра класса, сам для себя являющийся целевым для инструкции ветвления (см. §4.10.2.4).

* Не инициализированный экземпляр класса не должен находиться в локальной переменной того сегмента кода, который защищён обработчиком исключений (см. §4.10.2.4).

* Не инициализированный экземпляр класса не должен находиться в стеке операндов или в локальной переменной, если выполняются инструкции ''jsr'' или ''jsr_w''.
* Каждый инициализирующий метод экземпляра (см. §2.9), за исключением инициализирующего метода унаследованного от конструктора класса <font face=Courier>Object</font>, должен вызвать либо другой инициализирующий метод экземпляра <font face=Courier>this</font>, либо инициализирующий метод своего непосредственного предка <font face=Courier>super</font>, прежде чем можно будет обращаться к членам данным этого экземпляра.

: Тем не менее, допустимо присваивать значения членам данным класса <font face=Courier>this</font>, прежде чем будет вызван инициализирующий метод экземпляра.

* Аргументы метода должны быть должны быть совместимы по типам (см. JLS §5.3) с типами в дескрипторе метода (см. §4.3.3).

* Тип каждого экземпляра класса, являющийся целевым для инструкции вызова метода, должен быть совместим (см. JLS §5.2) с типом класса или интерфейса, определённого в инструкции.

: В дополнение, целевой тип инструкции ''invokespecial'' должен быть совместим с текущим классом за исключением случая, когда вызывается инициализирующий метод экземпляра.

* Тип каждой инструкции возврата из метода должен соответствовать типу возвращаемого значения:

::* Если метод возвращает <font face=Courier>boolean</font>,  <font face=Courier>byte</font>,  <font face=Courier>char</font>,  <font face=Courier>short</font> или  <font face=Courier>int</font>, то допустимо использовать только инструкцию ''ireturn''.

::* Если метод возвращает <font face=Courier>float</font>,  <font face=Courier>long</font> либо <font face=Courier>double</font>, то соответственно допустимо использовать только инструкцию ''dreturn''.
::* Если метод возвращает ссылочный тип (<font face=Courier>reference</font>), то допустимо использовать только инструкцию ''areturn'', причем тип возвращаемого значения должен быть совместим (см. JLS §5.2) с типом, объявленным в дескрипторе метода (см. §4.3.3).

* Если ''getfield'' либо ''putfield'' используются для доступа к <font face=Courier>protected</font> полям, объявленным классе-предке, который находится в пакете, отличном от пакета текущего класса, то экземпляра класса, к которому производится доступ должен быть тем же что и текущий класс, либо быть его наследником.

* Если ''invokevirtual'' либо ''invokespecial'' используются для доступа к <font face=Courier>protected</font> методам, объявленным классе-предке, который находится в пакете, отличном от пакета текущего класса, то экземпляра класса, к которому производится доступ должен быть тем же что и текущий класс, либо быть его наследником.

* Тип каждого экземпляра класса, к которому обращается инструкция ''getfield'' или модифицирует инструкция ''putfield'' должен быть совместим (см. JLS §5.2) с типом, определенным в инструкции.

* Тип значения, сохраняемый с помощью инструкций ''putfield'' или  ''putstatic'', должен быть совместим с типом в дескрипторе поля (см. §4.3.2) класса или экземпляра, где происходит сохранение:

::* Если тип в дескрипторе есть <font face=Courier>boolean</font>,  <font face=Courier>byte</font>,  <font face=Courier>char</font>,  <font face=Courier>short</font> либо <font face=Courier>int</font>, то значение должно быть <font face=Courier>int</font>.

::* Если тип в дескрипторе есть <font face=Courier>float</font>,  <font face=Courier>long</font> либо <font face=Courier>double</font>, то значение должно быть <font face=Courier>float</font>,  <font face=Courier>long</font> либо <font face=Courier>double</font> соответственно.

::* Если тип в дескрипторе есть ссылочный тип (<font face=Courier>reference</font>), то значение должно быть типом, совместимым (см. JLS §5.2) с ним.

* Тип каждого значения, сохраняемого в массиве с помощью инструкции ''aastore'', должен быть ссылочным типом (<font face=Courier>reference</font>).

* Тип компонент массива, сохраняемых помощью инструкции ''aastore'', также должен быть ссылочным типом (<font face=Courier>reference</font>).

* Каждая инструкция ''athrow'' должна иметь в качестве аргумента только значения, являющиеся экземплярами класса <font face=Courier>Throwable</font> или его наследниками.

: Каждый класс, упомянутый в элементе <font face=Courier>catch_type</font>, в таблице исключений метода должен быть экземпляром <font face=Courier>Throwable</font> или его наследником.

* Выполнение инструкций никогда не должно заходить за границы массива <font face=Courier>code</font>.

* Адрес возврата (значение типа <font face=Courier>returnAddress</font>) не должен загружаться из локальной переменной.

* Перейти к инструкциям, которые следуют за инструкциями  ''jsr'' либо ''jsr_w'' можно только с помощью одной инструкции ''ret''.

* Запрещено использовать инструкции ''jsr'' либо ''jsr_w'' (если управление к ним перешло в результате возврата из подпрограммы) для рекурсивного вызова подпрограммы, если подпрограмма уже присутствует в цепи вызова. (Подпрограммы допустимо вызывать из блока <font face=Courier>finally</font> конструкции <font face=Courier>try</font>-<font face=Courier>finally</font>).

* Каждый адрес возврата <font face=Courier>returnAddress</font> может быть использован не более чем один раз.

* Если в результате выполнения инструкции ''ret'' выполнен переход к точке подпрограммы в цепи вызовов выше инструкции ''ret'', (соответствующей данному экземпляру типа <font face=Courier>returnAddress</font>), то этот экземпляр не может быть использован в качестве адреса возврата.

<br><br><br><br>
=== Проверка <font face=Courier>class</font>-файлов ===

Не смотря на то, что каждый компилятор языка программирования Java должен генерировать только <font face=Courier>class</font>-файлы, удовлетворяющие всем статическим и структурным ограничениям, описанным в предыдущем разделе, виртуальная машина Java не имеет гарантий того, что произвольный файл, загруженный ею, будет сгенерирован таким компилятором или корректно сформирован вообще. Приложения, такие как веб-браузеры, не загружают исходный код, который они бы могли потом скомпилировать; такие приложения загружают только уже скомпилированные <font face=Courier>class</font>-файлы. Браузеру необходимо определить был ли <font face=Courier>class</font>-файл произведён компилятором, которому можно доверять, и представляет собой умышленную попытку вывести виртуальную машину Java из строя.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Дополнительная проблема проверки во время компилирования – это конфликт версий. Пользователь может успешно скомпилировать класс, например <font face=Courier>PurchaseStockOptions</font>, который является производным классом <font face=Courier>TradingClass</font>. Но определение класса <font face=Courier>TradingClass</font> может быть изменено с момента компиляции, так что класс теперь не совместим с существующими скомпилированными классами. Могут быть удалены методы или их возвращаемый тип может быть изменен либо модификаторы доступа могут быть изменены. Поля могут изменить свои типы, либо могут быть перенесены из полей экземпляра в поля класса. Модификаторы доступа метода или переменной могут быть изменены с  <font face=Courier>public</font> на  <font face=Courier>private</font>. Более подробно см. главу 13 «Двоичная совместимость» в Спецификации языка Java (<font face=Courier>The</font> Java™ <font face=Courier>Language</font> <font face=Courier>Specification</font>, Java SE 7 <font face=Courier>Edition</font>.)
</span>
|}
<br>

Из-за этих возможных трудностей, виртуальной машине Java необходимо самостоятельно проверять <font face=Courier>class</font>-файлы, с которыми она работает. Реализация виртуальной машины Java проверяет, что каждый <font face=Courier>class</font>-файл удовлетворяет необходимым ограничениям во время компоновки (см. §5.4).
Выполнение проверки во время компоновки улучшает производительность интерпретатора. Сложные проверки, которые в противном случае необходимо было бы выполнять во время выполнения программы для каждой инструкции, теперь выполняются только один раз во время компоновки. Виртуальная машина может предполагать, что все проверки уже выполнены. Например, виртуальная машина Java будет знать следующее:

* Нет переполнения стека или потери данных из стека

* Использование и хранение локальных переменных выполнено корректно.

* Аргументы всех инструкций виртуальной машины Java используют правильные типы данных.

Алгоритм проверки также выполняет проверку без просмотра массива <font face=Courier>code</font> атрибута <font face=Courier>Code</font> (см. §4.7.3). Операция включает в себя следующее:

* Проверка того, что <font face=Courier>final</font> классы не имеют наследников, а <font face=Courier>final</font> методы не замещаются (см. §5.4.5).

* Проверка того, что каждый класс (за исключением <font face=Courier>Object</font>) имеет непосредственного предка.

* Проверка того, что удовлетворяет объявленным статическим ограничениям; например, каждая структура  <font face=Courier>CONSTANT_Class_info</font> в константном пуле содержит элемент <font face=Courier>name_index</font> – действительный индекс в константном пуле для структуры <font face=Courier>CONSTANT_Utf8_info</font>.

* Проверка того, что все ссылки на поля и методы в константном пуле имеют действительные имена, действительные классы и действительные дескрипторы типов.

Обратите внимание, что указанные выше проверки не гарантируют, ни того что данное поле или метод на самом деле существуют в данном классе, ни того что данные дескрипторы типов ссылаются на действительные классы. Они только гарантируют, что указанные элементы имеют правильную структуру. Более детальная проверка выполняется, когда проверяется непосредственно байт-код, а также во время разрешения зависимостей.

Существуют две стратегии, которые может использовать для проверки реализация виртуальной машины Java:

* Проверка сравнением типов должна использоваться для <font face=Courier>class</font>-файлов, чей номер версии больше либо равен 50.0.

* Проверка логическим выведением типов должна поддерживаться всеми реализациями виртуальной машины Java, для которых номер версии <font face=Courier>class</font>-файла меньше 50.0, за исключением тех реализаций, которые соответствуют профайлам Java ME CLDC и Java Card.

Проверка для реализаций виртуальных машин Java поддерживающих профайлы Java ME CLDC и Java Card описана в соответствующих спецификациях.

<br><br><br><br>
==== Проверка сравнением типов ====

<font face=Courier>Class</font>-файл, чей номер версии больше либо равен 50.0,  должен быть проверен с использованием правил проверки типов, данных в этом разделе. Тогда и только тогда, когда номер версии <font face=Courier>class</font>-файла равен 50.0 и проверка типов закончилась аварийно, реализация виртуальной машины Java может выполнить проверку логическим выведением типов.

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Эта двойная проверка, спроектирована для упрощения перехода на новый способ проверки. Многие инструментальные программы, работающие с <font face=Courier>class</font>-файлами, могут модифицировать байт-код метода таким образом, что может понадобиться выравнивание стековых фреймов метода. Если инструментальная программа не выполняет необходимого выравнивания стековых фреймов метода, то проверка типов завершиться аварийно, не смотря на то, что сам байт-код принципиально может быть верным. Чтобы дать время разработчикам адаптировать их программные инструменты, виртуальная машина Java будет также поддерживать и старую парадигму проверки,  но только ограниченное время.
</span>

<span style="font-size:88%">В тех случаях, когда проверка типов завершается аварийно, но интерфейсный тип успешно используется, производительность кода уменьшится. Этого уменьшения нельзя избежать. Оно также должно служить сигналом поставщикам программного обеспечения, что их выходной код нуждается в выравнивании стековых фреймов, а также дает поставщикам дополнительный мотив для проведения операции выравнивания.
</span>

<span style="font-size:88%">В заключение необходимо отметить, что перехват управления при отказе для проверки интерфейсных типов поддерживает как постепенное добавление стековых фреймов (если их нет в версии <font face=Courier>class</font>-файла 50.0, то перехват управления при отказе будет выполнен) и постепенное удаление инструкций  ''jsr'' и ''jsr_w'' из платформы Java SE (если они присутствуют в <font face=Courier>class</font>-файле версии 50.0, то перехват управления при отказе будет выполнен).
</span>
|}
<br>

Если реализация виртуальной машины Java выполняет поверку с помощью интерфейсных типов для версии <font face=Courier>class</font>-файла 50.0, то ей необходимо выполнять данную проверку везде, где проверка по типам закончилась неудачей.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Это означает, что реализация виртуальной машины Java не может сделать выбор в одном случае прибегать к проверке с помощью интерфейсных типов, а в другом случае – нет. Она должна либо отклонить <font face=Courier>class</font>-файлы, которые не проверяются с помощью проверки типов, либо последовательно выполнить перехват управления при отказе для проверки интерфейсных типов, для каждой неудачной проверки типов.
</span>
|}
<br>

Для выполнения проверки по типам необходим список стековых фреймов для каждого метода с атрибутом <font face=Courier>Code</font>. Модуль проверки по типам считывает стековые фреймы для каждого метода и использует их для подтверждения безопасности типов для каждой инструкции в атрибуте <font face=Courier>Code</font>.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Замысел в том, что стековые фреймы должны появляться в начале каждого базового блока в методе. Стековые фреймы определяют тип проверки для каждого элемента стека операндов и для каждой локальной переменной в начале каждого базового блока.
</span>
|}
<br>

Применяющиеся правила проверки типов определены средствами языка Пролог. Текст на русском языке используется для описания правил проверки типов в свободной манере, в то время как код на языке Пролог является формальной спецификацией.
Тогда и только тогда, когда предикат <font face=Courier>classIsTypeSafe</font> не является истинным, система проверки типов может сгенерировать исключение  <font face=Courier>VerifyError</font>, означающее, что <font face=Courier>class</font>-файл сформирован неверно. В противном случае проверка типов <font face=Courier>class</font>-файла и проверка байт-кода завершена успешно.

 classIsTypeSafe(Class) :-
  classClassName(Class, Name), 
  classDefiningLoader(Class, L),
  superclassChain(Name, L, Chain),
  Chain \= [],
  classSuperClassName(Class, SuperclassName),
  loadedClass(SuperclassName, L, Superclass),
  classIsNotFinal(Superclass), 
  classMethods(Class, Methods), 
  checklist(methodIsTypeSafe(Class), Methods).
  
  classIsTypeSafe(Class) :-
  classClassName(Class, 'java/lang/Object'),
  classDefiningLoader(Class, L),
  isBootstrapClassLoader(L),
  classMethods(Class, Methods), 
  checklist(methodIsTypeSafe(Class), Methods).

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Таким образом, класс прошёл проверку на безопасность типов, если каждый его метод прошёл проверку на безопасность типов и класс не является наследником класса с модификатором <font face=Courier>final</font>.
</span>
|}
<br>

Предикат <font face=Courier>classIsTypeSafe</font> предполагает, что <font face=Courier>Class</font> – это структура на языке Пролог, представляющая двоичный класс, который был успешно синтаксически разобран и загружен. Данная спецификация не задаёт точную реализацию этой структуры, но требует, чтобы определённые предикаты (например, <font face=Courier>classMethods</font>) были в ней определены так, как указано в разделе «4.10.1.3.1 Средства доступа».
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Предположим, например, что предикат <font face=Courier>classMethods</font>(<font face=Courier>Class</font>, <font face=Courier>Methods</font>) такой, что  данный терм (терм – выражение формального языка, имя объекта или формы – прим. перев.) связывает свой первый аргумент (класс, описанный выше) со своим вторым аргументом, представляющим собой список всех методов класса, данных в удобной форме, описанной ниже.
</span>
|}
<br>

Мы также требуем существование предиката <font face=Courier>loadedClass</font>(<font face=Courier>Name</font>, <font face=Courier>InitiatingLoader</font>, <font face=Courier>ClassDefinition</font>), который предполагает, что существует класс с именем <font face=Courier>Name</font>, чьё представление (в соответствии с данной спецификацией) будучи загружено загрузчиком классов <font face=Courier>InitiatingLoader</font> является структурой <font face=Courier>ClassDefinition</font>. Все остальные необходимые предикаты обсуждаются в разделе «Средства доступа».

Отдельные инструкции представлены термами, чей функтор – это имя инструкции (функтор – имя терма. Пример терма:  ''t(X1, X2, … , Xn)'', где ''t'' – функтор, ''X1, X2, … , Xn'' - термы, структурированные или простейшие. ''Прим. перев.'')
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Например, инструкция ''aload'' представлена термом  <font face=Courier>aload(N)</font>, который включает в себя индекс <font face=Courier>N</font>, являющийся операндом инструкции.
</span>
|}
<br>
Операндами некоторых инструкций являются элементы константного пула, представляющие собой методы, узлы динамического вызова и поля. Метод представлен структурами <font face=Courier>CONSTANT_InterfaceMethodref_info</font> (для метода интерфейса) либо <font face=Courier>CONSTANT_Methodref_info</font> (для метода класса) в константном пуле. Узел динамического вызова представлен структурой <font face=Courier>CONSTANT_InvokeDynamic_info</font> в константном пуле.

Следующие структуры представлены в виде функторов:

* <font face=Courier>imethod</font>(<font face=Courier>MethodIntfName</font>, <font face=Courier>MethodName</font>, <font face=Courier>MethodDescriptor</font>) для интерфейсных методов, где <font face=Courier>MethodIntfName</font> имя интерфейса, на который ссылается элемент <font face=Courier>class_index</font> структуры <font face=Courier>CONSTANT_InterfaceMethodref_info</font>. И <font face=Courier>MethodName</font> и <font face=Courier>MethodDescriptor</font> соответствуют имени и типу дескриптора, на который ссылается элемент <font face=Courier>name_and_type_index</font> структуры <font face=Courier>CONSTANT_InterfaceMethodref_info</font>;

* <font face=Courier>method</font>(<font face=Courier>MethodClassName</font>, <font face=Courier>MethodName</font>, <font face=Courier>MethodDescriptor</font>) для методов класса, где <font face=Courier>MethodClassName</font> имя класса, на который ссылается элемент <font face=Courier>class_index</font> структуры  <font face=Courier>CONSTANT_Methodref_info</font>. И <font face=Courier>MethodName</font>, и <font face=Courier>MethodDescriptor</font> соответствуют имени и типу дескриптора, на который ссылается элемент <font face=Courier>name_and_type_index</font> структуры <font face=Courier>CONSTANT_Methodref_info</font>;

* <font face=Courier>dmethod</font>(<font face=Courier>CallSiteName</font>, <font face=Courier>MethodDescriptor</font>) для узлов динамического вызова, где <font face=Courier>CallSiteName</font> и <font face=Courier>MethodDescriptor</font> соответствуют имени и типу дескриптора, на который ссылается элемент <font face=Courier>name_and_type_index</font> структуры <font face=Courier>CONSTANT_InvokeDynamic_info</font>.

Аналогично поля представлены в структуре <font face=Courier>CONSTANT_Fieldref_info</font> в <font face=Courier>class</font> файле. Структуры представлены как приложения функторов формы <font face=Courier>field</font>(<font face=Courier>FieldClassName</font>, <font face=Courier>FieldName</font>, <font face=Courier>FieldDescriptor</font>), где <font face=Courier>FieldClassName</font> имя класса, на который ссылается элемент <font face=Courier>class_index</font>, а <font face=Courier>FieldName</font> и <font face=Courier>FieldDescriptor</font> соответствуют имени и дескриптору типов, на которые ссылается элемент структуры <font face=Courier>name_and_type_index</font>.

Для ясности мы полагаем, что дескрипторы типов поставлены в соответствие более читаемым именам: где ведущая литера <font face=Courier>L</font> и оконечная точка с запятой (;) выброшены из имени класса, а символы базовых типов для примитивных типов поставлены в соответствие именам типов.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Пример. То есть инструкция ''getfield'', чей операнд был индекс в константном пуле, который ссылается на поле <font face=Courier>foo</font> с типом <font face=Courier>F</font> в классе <font face=Courier>Bar</font> будет представлен как ''getfield''(<font face=Courier>field</font>('<font face=Courier>Bar</font>', '<font face=Courier>foo</font>', '<font face=Courier>F</font>')).
</span>
|}
<br>

Элементы константного пула, которые ссылаются на постоянные значение, такие как <font face=Courier>CONSTANT_String</font>, <font face=Courier>CONSTANT_Integer</font>, <font face=Courier>CONSTANT_Float</font>, <font face=Courier>CONSTANT_Long</font>, <font face=Courier>CONSTANT_Double</font>, и <font face=Courier>CONSTANT_Class</font> кодируются функторами с именами <font face=Courier>string</font>, <font face=Courier>int</font>, <font face=Courier>float</font>, <font face=Courier>long</font>, <font face=Courier>double</font>, и <font face=Courier>classConstant</font> соответственно.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Пример. Инструкция ''ldc'' для загрузки целого числа 91 будет представлена как <font face=Courier>ldc(int(91))</font>.
</span>
|}
<br>

Инструкции в целом представлены как список термов формы <font face=Courier>instruction</font>(<font face=Courier>Offset</font>, <font face=Courier>AnInstruction</font>).
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Пример. <font face=Courier>instruction(21, aload(1))</font>.
</span>
|}
<br>

Порядок следования инструкций в данном списке должен быть такой же как и в <font face=Courier>class</font> файле.

Стековые фреймы представлены как список термов следующей формы <font face=Courier>stackMap</font>(<font face=Courier>Offset</font>,<font face=Courier>TypeState</font>), где <font face=Courier>Offset</font> целочисленное значение равное смещению инструкции фрейма, а <font face=Courier>TypeState</font> — ожидаемое входящее состояние типа для данной инструкции. Порядок следования инструкций в данном списке должен быть такой же как и в <font face=Courier>class</font> файле.

<font face=Courier>TypeState</font> имеет форму <font face=Courier>frame</font>(<font face=Courier>Locals</font>, <font face=Courier>OperandStack</font>, <font face=Courier>Flags</font>).

<font face=Courier>Locals</font> — это список проверочных типов, таких что N-ный элемент в списке (счёт ведётся с нуля) представляет тип локальной переменной N. Если какая либо переменная в <font face=Courier>Locals</font> имеет тип <font face=Courier>uninitializedThis</font>, то <font face=Courier>Flags</font> равен [<font face=Courier>flagThisUninit</font>], в противном случае это пустой список.

<font face=Courier>OperandStack</font> представляет собой список типов, такой что первый элемент соответствует типу на вершине стека операндов, второй элемент — следующему под вершинным элементом и так далее.

Однако обратите внимание, что типы, имеющие размер 2, представлены двумя сущностями первая из которых <font face=Courier>top</font>, а вторая, собственно и есть тип.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Пример. Стек со значениями <font face=Courier>double</font>,  <font face=Courier>int</font>, и <font face=Courier>long</font> будет представлен как [<font face=Courier>top</font>, <font face=Courier>double</font>, <font face=Courier>int</font>, <font face=Courier>top</font>, <font face=Courier>long</font>].
</span>
|}
<br>

Массивы представлены путём применения функтора <font face=Courier>arrayOf</font> к аргументу, обозначающему компонент типа массива.
Остальные ссылочные типы представлен с использованием функтора <font face=Courier>class</font>. Поэтому <font face=Courier>class(N, L)</font> представляет собой класс, чьё двоичное имя <font face=Courier>N</font> и который загружается загрузчиком <font face=Courier>L</font>.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Таким образом  <font face=Courier>L</font> — инициирующий загрузчик класса, представленного как <font face=Courier>class(N, L)</font>. Он может быть, а может и не быть определяющим загрузчиком.
</span>
|}
<br>

Тип <font face=Courier>uninitialized</font>(<font face=Courier>offset</font>) представлен путём применения функтора <font face=Courier>uninitialized</font> к аргументу, представляющему собой численное значение смещения <font face=Courier>offset</font>.

Остальные проверочные типы представлены элементами Пролога, имена которых обозначают проверочные типы со знаком вопроса.
<br><br>
:: <span style="font-size:88%">Примечание. Иными словами, класс <font face=Courier>Object</font> будет представлен как <font face=Courier>class</font>('<font face=Courier>java</font>/<font face=Courier>lang</font>/<font face=Courier>Object</font>', <font face=Courier>BL</font>), где <font face=Courier>BL</font> — начальный загрузчик. Типы <font face=Courier>int[]</font> и <font face=Courier>Object[]</font> будут представлены как <font face=Courier>arrayOf</font>(<font face=Courier>int</font>) и <font face=Courier>arrayOf</font>(<font face=Courier>class</font>('<font face=Courier>java</font>/<font face=Courier>lang</font>/<font face=Courier>Object</font>', <font face=Courier>BL</font>)) соответственно.
</span>
<br>

<font face=Courier>Flags</font> — это список, который может быть как пустым так и иметь один элемент <font face=Courier>flagThisUninit</font>.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Этот флаг используется в конструкторах, чтобы обозначить состояния типов, инициализация которых ещё не была завершена. В таких состояниях типов запрещено делать возврат из метода.
</span>
|}
<br>

<br><br><br><br>
===== Иерархия типов =====

Использование проверщика типов, приводит к созданию иерархии типов изображённой ниже. Большинство типов верификатора имеют прямое соответствие с дескрипторами типов виртуальной машины Java как показано в таблице 4.2. Единственным исключением являются дескрипторы полей <font face=Courier>B</font> , <font face=Courier>C</font> , <font face=Courier>S</font> и <font face=Courier>Z</font>, которые соответствуют типу верификатора <font face=Courier>int</font>.

 Проверочные типы:
                                          top 
  
                              ____________/\____________
                             /                          \
                            /                            \
                       oneWord                           twoWord
                     /   |   \                          /      \ 
                    /    |    \                        /        \                
                  int  float  reference              long      double
                              /      \
                             /        \________________
                            /                          \
                           /                            \
                   uninitialized                       Object
                    /       \                             \
                   /         \                             \
 uninitializedThis   uninitialized(offset)           +-----------------------+
                                                     |                       |
                                                     | Иерархия классов Java |
                                                     |                       |
                                                     +-----------------------+
                                                                 |
                                                                 |
                                                                null
<br><br><br><br>
===== Правила подтипов =====

Правила подтипов рефлексивны:

 isAssignable(X, X).
 
 isAssignable(oneWord, top).
 isAssignable(twoWord, top).
 
 
 isAssignable(int, X) :- isAssignable(oneWord, X).
 isAssignable(float, X) :- isAssignable(oneWord, X).
 isAssignable(long, X) :- isAssignable(twoWord, X).
 isAssignable(double, X) :- isAssignable(twoWord, X).
 
 isAssignable(reference, X) :- isAssignable(oneWord, X).
 isAssignable(class(_, _), X) :- isAssignable(reference, X).
 isAssignable(arrayOf(_), X) :- isAssignable(reference, X).
 
 isAssignable(uninitialized, X) :- isAssignable(reference, X).
 isAssignable(uninitializedThis, X) :- isAssignable(uninitialized, X).
 isAssignable(uninitialized(_), X) :- isAssignable(uninitialized, X).
 
 isAssignable(null, class(_, _)).
 isAssignable(null, arrayOf(_)).
 isAssignable(null, X) :- isAssignable(class('java/lang/Object', BL), X),
 isBootstrapLoader(BL).


Эти правила подтипов не обязательно очевидные следствия взаимосвязи типов и подтипов. Есть чёткое разделение между правилами подтипов для ссылочных типов языка программирования Java и правилами для оставшихся проверочных типов.  Это разделение позволяет нам установить общие отношения между типами языка программирования Java и остальными проверочными типами. Отношения справедливы вне зависимости от положения Java типа в иерархии класса, и позволяют предотвратить излишнюю загрузку классов в реализации виртуальной машины Java. Например, мы не начнём подниматься вверх по иерархии классов Java если запрос имеет вид <font face=Courier>class</font>(<font face=Courier>foo,L) <: twoWord</font>.

Правила подтипов для ссылочных типов в языке программирования Java очевидным образом определены рекурсивно с помощью <font face=Courier>isJavaAssignable</font>. Оставшиеся проверочные типы имеют правила подтипов следующей формы:

 isAssignable(v, X) :- isAssignable(the_direct_supertype_of_v, X).

Где  <font face=Courier>v</font> подтип  <font face=Courier>X</font>, если непосредственный подтип  <font face=Courier>v</font> есть подтип  <font face=Courier>X</font>.

Также имеется правило, согласно которому отношение подтипов рефлексивно, так что совместно эти правила покрывают большинство проверочных типов, которые не являются ссылочными типами языка программирования Java.

 isAssignable(class(X, Lx), class(Y, Ly)) :-
     isJavaAssignable(class(X, Lx), class(Y, Ly)).
 
 
 isAssignable(arrayOf(X), class(Y, L)) :-
     isJavaAssignable(arrayOf(X), class(Y, L)).
 
 
 isAssignable(arrayOf(X), arrayOf(Y)) :-
     isJavaAssignable(arrayOf(X), arrayOf(Y)).

При присвоениях интерфейсы рассматриваются как <font face=Courier>Object</font>.

 isJavaAssignable(class(_, _), class(To, L)) :-
     loadedClass(To, L, ToClass),
     classIsInterface(ToClass).
 
 isJavaAssignable(From, To) :-
     isJavaSubclassOf(From, To).

Массивы являются подтипами <font face=Courier>Object</font>.

 isJavaAssignable(arrayOf(_), class('java/lang/Object', BL)) :-
     isBootstrapLoader(BL).

Смысл здесь в том, что массив является подтипом <font face=Courier>Cloneable</font> и <font face=Courier>java</font>.<font face=Courier>io</font>.<font face=Courier>Serializable</font>.

 isJavaAssignable(arrayOf(_), X) :-
     isArrayInterface(X).
 
Отношение подтипов между массивами и примитивными типами это отношение тождества.

 isJavaAssignable(arrayOf(X), arrayOf(Y)) :-
     atom(X),
     atom(Y),
     X = Y.

Отношение подтипов между массивами и ссылочными типами ковариантно.

 isJavaAssignable(arrayOf(X), arrayOf(Y)) :-
     compound(X), compound(Y), isJavaAssignable(X, Y).
 
 isArrayInterface(class('java/lang/Cloneable', BL)) :-
     isBootstrapLoader(BL).
 
 isArrayInterface(class('java/io/Serializable', BL)) :-
      isBootstrapLoader(BL).
 
Наследование рефлексивно.

 isJavaSubclassOf(class(SubclassName, L), class(SubclassName, L)).
 
 isJavaSubclassOf(class(SubclassName, LSub), class(SuperclassName, LSuper)) :-
     superclassChain(SubclassName, LSub, Chain),
     member(class(SuperclassName, L), Chain),
     loadedClass(SuperclassName, L, Sup),
     loadedClass(SuperclassName, LSuper, Sup).
 
 
 superclassChain(ClassName, L, [class(SuperclassName, Ls) | Rest]) :-
     loadedClass(ClassName, L, Class),
     classSuperClassName(Class, SuperclassName),
     classDefiningLoader(Class, Ls),
     superclassChain(SuperclassName, Ls, Rest).
 
 
 superclassChain('java/lang/Object', L, []) :-
     loadedClass('java/lang/Object', L, Class),
     classDefiningLoader(Class, BL),
     isBootstrapLoader(BL).

Отношение подтипов расширяется к типам состояний.

Массив локальных переменных метода имеет фиксированную длину по построению (в <font face=Courier>methodInitialStackFrame</font>), в то время как стек операндов может увеличиваться и уменьшаться. Следовательно нам необходима явная проверка длинны стека операндов, при присваивании фреймов.

 frameIsAssignable(frame(Locals1, StackMap1, Flags1),
                                frame(Locals2, StackMap2, Flags2)) :-
 
     length(StackMap1, StackMapLength),
     length(StackMap2, StackMapLength),
     maplist(isAssignable, Locals1, Locals2),
     maplist(isAssignable, StackMap1, StackMap2),
     subset(Flags1, Flags2).

<br><br><br><br>
===== Правила проверки типов =====
====== Средства доступа ======

''Заранее оговорённые средства доступа'': повсюду в данной спецификации мы предполагаем существование определённых предикатов Пролога, чьи формальные определения не даны в спецификации. Ниже мы приводим данные предикаты и описываем их ожидаемое поведение.
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Руководящим принципом в определении того какие средства доступа полностью определены, а какие оговорены и определены заранее, являлось намерение не перегружать <font face=Courier>class</font> файл излишним кодом. Предоставляя определённые средства доступа к терму класса или метода, мы вынуждены полностью определять формат терма Пролога, представляющего <font face=Courier>class</font> файл.
</span>
|}
<br>

<font face=Courier>parseFieldDescriptor</font>(<font face=Courier>Descriptor</font>, <font face=Courier>Type</font>)

:: Преобразует дескриптор поля <font face=Courier>Descriptor</font> в соответствующий проверочный тип <font face=Courier>Type</font> (см. начало §4.10.1.1 для точного определения этого соответствия)

<font face=Courier>parseMethodDescriptor</font>(<font face=Courier>Descriptor</font>, <font face=Courier>ArgTypeList</font>, <font face=Courier>ReturnType</font>)

:: Преобразует дескриптор метода  <font face=Courier>Descriptor</font> в список проверочных типов <font face=Courier>ArgTypeList</font>, соответствующих (см. §4.10.1.1) типам аргументов метода и проверочный тип <font face=Courier>ReturnType</font>, соответствующий возвращаемому типу.

<font face=Courier>parseCodeAttribute</font>(<font face=Courier>Class</font>, <font face=Courier>Method</font>, <font face=Courier>FrameSize</font>, <font face=Courier>MaxStack</font>, <font face=Courier>ParsedCode</font>, <font face=Courier>Handlers</font>, <font face=Courier>StackMap</font>)

:: Извлекает поток инструкций <font face=Courier>ParsedCode</font> метода  <font face=Courier>Method</font> в классе  <font face=Courier>Class</font>, а также максимальный размер стека операндов <font face=Courier>MaxStack</font>, максимальное количество локальных переменных <font face=Courier>FrameSize</font>, обработчики исключений <font face=Courier>Handlers</font> и отображение стека <font face=Courier>StackMap</font>.

:: Представление атрибутов потока инструкций и  отображение стека должно быть таким, как описано в начале §4.10.1.

:: Каждый обработчик исключения представлен функтором вида <font face=Courier>handler</font>(<font face=Courier>Start</font>, <font face=Courier>End</font>, <font face=Courier>Target</font>, <font face=Courier>ClassName</font>), чьи аргументы соответственно начало и конец интервала инструкций, принадлежащих обработчику, первая инструкция обработчика, и имя исключения, которое обрабатывает данный обработчик.

<font face=Courier>classClassName</font>(<font face=Courier>Class</font>, <font face=Courier>ClassName</font>)

:: Возвращает имя  <font face=Courier>ClassName</font> класса <font face=Courier>Class</font>.

<font face=Courier>classIsInterface</font>(<font face=Courier>Class</font>)

:: Истинно тогда и только тогда, когда <font face=Courier>Class</font> является интерфейсом.

<font face=Courier>classIsNotFinal</font>(<font face=Courier>Class</font>)

:: Истинно тогда и только тогда, когда <font face=Courier>Class</font> не является <font face=Courier>final</font> классом.

<font face=Courier>classSuperClassName</font>(<font face=Courier>Class</font>, <font face=Courier>SuperClassName</font>)

:: Возвращает имя  <font face=Courier>SuperClassName</font> класса предка.

<font face=Courier>classInterfaces</font>(<font face=Courier>Class</font>, <font face=Courier>Interfaces</font>)

:: Возвращает список <font face=Courier>Interfaces</font> непосредственных предков класса <font face=Courier>Class</font>.

<font face=Courier>classMethods</font>(<font face=Courier>Class</font>, <font face=Courier>Methods</font>)

:: Возвращает список методов <font face=Courier>Methods</font> объявленных в классе <font face=Courier>Class</font>.

<font face=Courier>classAttributes</font>(<font face=Courier>Class</font>, <font face=Courier>Attributes</font>)

:: Возвращает список атрибутов <font face=Courier>Attributes</font> класса <font face=Courier>Class</font>. Каждый атрибут представляет собой приложение функтора к форме <font face=Courier>attribute</font>(<font face=Courier>AttributeName</font>, <font face=Courier>AttributeContents</font>), где <font face=Courier>AttributeName</font> — имя атрибута. Формат содержимого атрибутов неопределён.

<font face=Courier>classDefiningLoader</font>(<font face=Courier>Class</font>, <font face=Courier>Loader</font>)

:: Возвращает определяющий загрузчик <font face=Courier>Loader</font> класса  <font face=Courier>Class</font>.

<font face=Courier>isBootstrapLoader</font>(<font face=Courier>Loader</font>)

:: Истинно тогда и только тогда, когда <font face=Courier>Loader</font> — начальный загрузчик.

<font face=Courier>methodName</font>(<font face=Courier>Method</font>, <font face=Courier>Name</font>)

:: Возвращает имя <font face=Courier>Name</font> метода  <font face=Courier>Method</font>.

<font face=Courier>methodAccessFlags</font>(<font face=Courier>Method</font>, <font face=Courier>AccessFlags</font>)

:: Возвращает флаги доступа <font face=Courier>AccessFlags</font> метода <font face=Courier>Method</font>.

<font face=Courier>methodDescriptor</font>(<font face=Courier>Method</font>, <font face=Courier>Descriptor</font>)

:: Возвращает дескриптор <font face=Courier>Descriptor</font> метода  <font face=Courier>Method</font>.

<font face=Courier>methodAttributes</font>(<font face=Courier>Method</font>, <font face=Courier>Attributes</font>)

:: Возвращает список атрибутов <font face=Courier>Attributes</font> метода  <font face=Courier>Method</font>.

<font face=Courier>isNotFinal</font>(<font face=Courier>Method</font>, <font face=Courier>Class</font>)

:: Истинно тогда и только тогда, когда метод  <font face=Courier>Method</font> в классе  <font face=Courier>Class</font> не является <font face=Courier>final</font>.

<font face=Courier>isProtected</font>(<font face=Courier>MemberClass</font>, <font face=Courier>MemberName</font>, <font face=Courier>MemberDescriptor</font>)

:: Истинно тогда и только тогда, когда поле <font face=Courier>MemberName</font> с дескриптором <font face=Courier>MemberDescriptor</font> в классе  <font face=Courier>MemberClass</font> является <font face=Courier>protected</font>.

<font face=Courier>isNotProtected</font>(<font face=Courier>MemberClass</font>, <font face=Courier>MemberName</font>, <font face=Courier>MemberDescriptor</font>)

:: Истинно тогда и только тогда, когда поле <font face=Courier>MemberName</font> с дескриптором <font face=Courier>MemberDescriptor</font> в классе  <font face=Courier>MemberClass</font> не является <font face=Courier>protected</font>.

<font face=Courier>samePackageName</font>(<font face=Courier>Class1</font>, <font face=Courier>Class2</font>)

:: Истинно тогда и только тогда, когда имя пакетов у классов  <font face=Courier>Class1</font> и <font face=Courier>Class2</font> совпадают.

<font face=Courier>differentPackageName</font>(<font face=Courier>Class1</font>, <font face=Courier>Class2</font>)

:: Истинно тогда и только тогда, когда имя пакетов у классов  <font face=Courier>Class1</font> и <font face=Courier>Class2</font> различаются.

''Заранее оговорённые средства доступа и утилиты'': мы определяем средства доступа и вспомогательные правила, которые получают необходимую информацию из описания классов и их методов.

Окружение — это кортеж, состоящий из шести элементов:

* класс
* метод
* объявленный возвращаемый тип метода.
* инструкции метода
* максимальный размер стека операндов
* список обработчиков исключений

 maxOperandStackLength(Environment, MaxStack) :-
     Environment = environment(_Class, _Method, _ReturnType,
                               _Instructions, MaxStack, _Handlers).
 
 
 exceptionHandlers(Environment, Handlers) :-
     Environment = environment(_Class, _Method, _ReturnType,
                               _Instructions, _, Handlers).
 
 
 thisMethodReturnType(Environment, ReturnType) :-
     Environment = environment(_Class, _Method, ReturnType,
                               _Instructions, _, _).
 
 
 thisClass(Environment, class(ClassName, L)) :-
     Environment = environment(Class, _Method, _ReturnType,
                               _Instructions, _, _),
     classDefiningLoader(Class, L),
     classClassName(Class, ClassName).
 
 
 allInstructions(Environment, Instructions) :-
     Environment = environment(_Class, _Method, _ReturnType,
                               Instructions, _, _).
 
 
 offsetStackFrame(Environment, Offset, StackFrame) :-
     allInstructions(Environment, Instructions),
     member(stackMap(Offset, StackFrame), Instructions).
 
 
 currentClassLoader(Environment, Loader) :-
     thisClass(Environment, class(_, Loader)).
 
 
 notMember(_, []).
 
 notMember(X, [A | More]) :- X \= A, notMember(X, More).
 
 
 sameRuntimePackage(Class1, Class2) :-
     classDefiningLoader(Class1, L),
     classDefiningLoader(Class2, L),
     samePackageName(Class1, Class2).
 
 
 differentRuntimePackage(Class1, Class2) :-
     classDefiningLoader(Class1, L1),
     classDefiningLoader(Class2, L2),
     L1 \= L2.
 
 
 differentRuntimePackage(Class1, Class2) :-
     differentPackageName(Class1, Class2).

<br><br><br><br>
====== Абстрактные методы и методы Native ======

Абстрактные методы и методы Native считаются корректными по типам, если они не замещают метод <font face=Courier>final</font>.

 methodIsTypeSafe(Class, Method) :-
     doesNotOverrideFinalMethod(Class, Method),
     methodAccessFlags(Method, AccessFlags),
     member(abstract, AccessFlags).
 
 methodIsTypeSafe(Class, Method) :-
     doesNotOverrideFinalMethod(Class, Method),
     methodAccessFlags(Method, AccessFlags),
     member(native, AccessFlags).
 
 
 doesNotOverrideFinalMethod(class('java/lang/Object', L), Method) :-
     isBootstrapLoader(L).
 
 
 doesNotOverrideFinalMethod(Class, Method) :-
     classSuperClassName(Class, SuperclassName),
     classDefiningLoader(Class, L),
     loadedClass(SuperclassName, L, Superclass),
     classMethods(Superclass, MethodList),
     finalMethodNotOverridden(Method, Superclass, MethodList).
 
 
 finalMethodNotOverridden(Method, Superclass, MethodList) :-
     methodName(Method, Name),
     methodDescriptor(Method, Descriptor),
     member(method(_, Name, Descriptor), MethodList),
     isNotFinal(Method, Superclass).
 
 
 finalMethodNotOverridden(Method, Superclass, MethodList) :-
     methodName(Method, Name),
     methodDescriptor(Method, Descriptor),
     notMember(method(_, Name, Descriptor), MethodList),
     doesNotOverrideFinalMethod(Superclass, Method).

<br><br><br><br>
====== Проверка кода ======

Не абстрактные и не нативные методы  считаются корректными по типам, если они они имеют код и этот код корректен по типам.

 methodIsTypeSafe(Class, Method) :-
     doesNotOverrideFinalMethod(Class, Method),
     methodAccessFlags(Method, AccessFlags),
     methodAttributes(Method, Attributes),
     notMember(native, AccessFlags),
 
     notMember(abstract, AccessFlags),
    member(attribute('Code', _), Attributes),
    methodWithCodeIsTypeSafe(Class, Method).

Метод с кодом, является безопасным по типам, если возможно объединить код и стек фреймов в один поток, так что каждое стековое соответствие предшествует инструкции, которой оно соответствует, и объеденный поток корректен по типам.

 methodWithCodeIsTypeSafe(Class, Method) :-
     parseCodeAttribute(Class, Method, FrameSize, MaxStack,
                        ParsedCode, Handlers, StackMap),
     mergeStackMapAndCode(StackMap, ParsedCode, MergedCode),
     methodInitialStackFrame(Class, Method, FrameSize, StackFrame, ReturnType),
     Environment = environment(Class, Method, ReturnType, MergedCode,
                               MaxStack, Handlers),
     handlersAreLegal(Environment),
     mergedCodeIsTypeSafe(Environment, MergedCode, StackFrame).

Начальное состояние по типам в методе состоит из пустого стека операндов и типов локальных переменных, унаследованных от типа <font face=Courier>this</font> и аргументов, а также соответствующего флага, зависящего от того является ли данны метод <font face=Courier><init></font> методом или нет.

 methodInitialStackFrame(Class, Method, FrameSize, frame(Locals, [], Flags),
                         ReturnType):-
     methodDescriptor(Method, Descriptor),
     parseMethodDescriptor(Descriptor, RawArgs, ReturnType),
     expandTypeList(RawArgs, Args),
     methodInitialThisType(Class, Method, ThisList),
     flags(ThisList, Flags),
     append(ThisList, Args, ThisArgs),
     expandToLength(ThisArgs, FrameSize, top, Locals).
 
 flags([uninitializedThis], [flagThisUninit]).
 flags(X, []) :- X \= [uninitializedThis].
 
 expandToLength(List, Size, _Filler, List) :- length(List, Size).
 expandToLength(List, Size, Filler, Result) :-
     length(List, ListLength),
     ListLength < Size,
     Delta is Size - ListLength,
     length(Extra, Delta),
     checklist(=(Filler), Extra),
     append(List, Extra, Result).

Для статических методов <font face=Courier>this</font> не определено; список пуст. Для метода экземпляра мы получаем тип <font face=Courier>this</font> и помещаем его в список.

 methodInitialThisType(_Class, Method, []) :-
     methodAccessFlags(Method, AccessFlags),
     member(static, AccessFlags),
     methodName(Method, MethodName),
     MethodName \= ' <init> '.
 
 methodInitialThisType(Class, Method, [This]) :-
     methodAccessFlags(Method, AccessFlags),\
     notMember(static, AccessFlags),\
     instanceMethodInitialThisType(Class, Method, This).

В методе <font face=Courier><init></font> класса <font face=Courier>Object</font> тип <font face=Courier>this</font> это <font face=Courier>Object</font>. В других <font face=Courier><init></font> методах тип <font face=Courier>this</font> это <font face=Courier>uninitializedThis</font>. В противном случае  тип <font face=Courier>this</font> в методе экземпляра - это <font face=Courier>class</font>(N, L), где N — имя класса, содержащего метода и L — определяющий загрузчик класса.

 instanceMethodInitialThisType(Class, Method, class('java/lang/Object', L)) :-
     methodName(Method, ' <init> '),
     classDefiningLoader(Class, L),
     isBootstrapLoader(L),
     classClassName(Class, 'java/lang/Object').
 
 
 instanceMethodInitialThisType(Class, Method, uninitializedThis) :-
     methodName(Method, '<init>'),
     classClassName(Class, ClassName),
     classDefiningLoader(Class, CurrentLoader),
     superclassChain(ClassName, CurrentLoader, Chain),
     Chain \= [].
 
 instanceMethodInitialThisType(Class, Method, class(ClassName, L)) :-
     methodName(Method, MethodName),
     MethodName \= '<init>',
     classDefiningLoader(Class, L),
     classClassName(Class, ClassName).

Ниже представлены правила для прохождения по потоку кода. Мы предполагаем, что поток является правильно форматированной смесью инструкций и стековых соответствий, таких что стековое соответствие для байткода с индексом N находится непосредственно перед инструкцией N. Правила для построения такого смешанного потока даны ниже в предикате <font face=Courier>mergeStackMapAndCode</font>.

Специальный маркер <font face=Courier>aftergoto</font> используется для обозначения безусловного перехода. Если мы имеем безусловный переход в конце кода, то это означает остановку.

 mergedCodeIsTypeSafe(_Environment, [endOfCode(Offset)], afterGoto).

После безусловного перехода, в случае если мы имеем стековое соответствие дающее состояние типов для следующих инструкций, то мы можем продолжить и выполнить для них проверку типов используя состояние типов из стекового соответствия.

 mergedCodeIsTypeSafe(Environment, [stackMap(Offset, MapFrame) | MoreCode],
afterGoto):-
 
 mergedCodeIsTypeSafe(Environment, MoreCode, MapFrame).

Если мы имеем стековое соответствие и входящее  состояние типов, то  состояние типов должно иметь возможность быть присвоенным одному из стековых соответствий. Тогда мы продолжим проверку типов остального потока с состоянием типа, находящимся в стековом соответствии.

 mergedCodeIsTypeSafe(Environment, [stackMap(Offset, MapFrame) | MoreCode],            
                     frame(Locals, OperandStack, Flags)) :-
    frameIsAssignable(frame(Locals, OperandStack, Flags), MapFrame),
    mergedCodeIsTypeSafe(Environment, MoreCode, MapFrame).

Допустимо иметь код после безусловного перехода без стекового фрейма для него.

 mergedCodeIsTypeSafe(_Environment, [instruction(_, _) | _MoreCode],
                     afterGoto) :-
    write_ln('No stack frame after unconditional branch'),
    fail.

Объединённый поток кода является безопасным по типам по отношению к входящему состоянию типов T, если он начинается с инструкции I, которая является безопасной по типу к  T и  I удовлетворяет его обработчикам исключений, причём остаток потока безопасен по типу данному состоянию типов, следующему за исполнением  I.

<font face=Courier>NextStackFrame</font> показывает, что будет передаваться следующей инструкции.
<font face=Courier>ExceptionStackFrame</font> показывает, что передаётся обработчикам исключений.

 mergedCodeIsTypeSafe(Environment, [instruction(Offset, Parse) | MoreCode],
                      frame(Locals, OperandStack, Flags)) :-
     instructionIsTypeSafe(Parse, Environment, Offset,
                           frame(Locals, OperandStack, Flags),
                           NextStackFrame, ExceptionStackFrame),
     instructionSatisfiesHandlers(Environment, Offset, ExceptionStackFrame),
     mergedCodeIsTypeSafe(Environment, MoreCode, NextStackFrame).

Переход к целевому объекту является безопасным по типам, если целевой объект имеет связанный с ним стековый фрейм и текущий стековый фрейм <font face=Courier>StackFrame</font> допустимо присваивать <font face=Courier>Frame</font>.

 targetIsTypeSafe(Environment, StackFrame, Target) :-
     offsetStackFrame(Environment, Target, Frame),
     frameIsAssignable(StackFrame, Frame).

<br><br><br><br>
====== Комбинирование потоков стековых соответствий и инструкций ======

Слияние пустого <font face=Courier>StackMap</font> и списка инструкций приводит к исходному списку инструкций.

 mergeStackMapAndCode([], CodeList, CodeList).

Пусть дан список фреймов стековых соответствий, начинающийся с состояния типа для инструкции по смещению <font face=Courier>Offset</font> и список инструкций, начинающийся со смещения <font face=Courier>Offset</font>. Объединённый список - это вершина списка стека фреймов, за которой следует вершина списка инструкций, за которыми следует объединение оставшихся элементов фрейма и инструкций.

 mergeStackMapAndCode([stackMap(Offset, Map) | RestMap],
                      [instruction(Offset, Parse) | RestCode],
                      [stackMap(Offset, Map),
                        instruction(Offset, Parse) | RestMerge]) :-
     mergeStackMapAndCode(RestMap, RestCode, RestMerge).
 
В противном случае, пусть дан  список фреймов стековых соответствий, начинающийся с состояния типа для инструкции по смещению <font face=Courier>OffsetM</font> и  список инструкций, начинающийся со смещения <font face=Courier>OffsetP</font>. Тогда, если <font face=Courier>OffsetP</font> < <font face=Courier>OffsetM</font>, то объединённый список состоит из вершины списка инструкций, за которой следует  объединение списка стековых фреймов и оставшегося списка инструкций.

 mergeStackMapAndCode([stackMap(OffsetM, Map) | RestMap],
                      [instruction(OffsetP, Parse) | RestCode],
                      [instruction(OffsetP, Parse) | RestMerge]) :-
     OffsetP < OffsetM,
     mergeStackMapAndCode([stackMap(OffsetM, Map) | RestMap], RestCode, RestMerge).

В противном случае, объединение двух списков не определено. Так как список инструкций имеет монотонно возрастающие смещения, объединение двух списков не определено до тех пор, пока каждый фрейм стекового соответствия имеет соответствующее смещение инструкции и  фреймы стекового соответствия находятся в возрастающем порядке.

<br><br><br><br>
====== Обработка исключений ======

Инструкция ''удовлетворяет её обработчикам исключений'', если она удовлетворяет каждому обработчику исключения, который применим к инструкции.

 instructionSatisfiesHandlers(Environment, Offset, ExceptionStackFrame) :-
     exceptionHandlers(Environment, Handlers),
     sublist(isApplicableHandler(Offset), Handlers, ApplicableHandlers),
     checklist(instructionSatisfiesHandler(Environment, ExceptionStackFrame),
               ApplicableHandlers).

Обработчик исключений ''применим'' к инструкции, если смещение инструкции больше либо равно началу интервала обработчика и меньше конца интервала обработчика.

 isApplicableHandler(Offset, handler(Start, End, _Target, _ClassName)) :-
     Offset >= Start,
     Offset < End.

Инструкция ''удовлетворяет'' обработчику исключений, если её входящее состояние типов есть <font face=Courier>StackFrame</font> и цель обработчика исключений (начальная инструкция в коде обработчика) безопасна по типу при предположении, что входящее состояние типов равно T.  Состояние типов T унаследовано от <font face=Courier>StackFrame</font> через замену стека операндов стеком, чей единственный элемент это класс обработчика исключений.

 instructionSatisfiesHandler(Environment, StackFrame, Handler) :-
     Handler = handler(_, _, Target, _),
     currentClassLoader(Environment, CurrentLoader),
     handlerExceptionClass(Handler, ExceptionClass, CurrentLoader),
     /* The stack consists of just the exception. */
     StackFrame = frame(Locals, _, Flags),
     ExcStackFrame = frame(Locals, [ ExceptionClass ], Flags),
     operandStackHasLegalLength(Environment, ExcStackFrame),
     targetIsTypeSafe(Environment, ExcStackFrame, Target).

Класс обработчика исключений это <font face=Courier>Throwable</font>, если класс обработчика не задан явно и класс заданный в обработчике в противном случае.

 handlerExceptionClass(handler(_, _, _, 0), class('java/lang/Throwable', BL), _) :-
     isBootstrapLoader(BL).
 
 handlerExceptionClass(handler(_, _, _, Name), class(Name, L), L) :-
     Name \= 0.

Обработчик исключений корректен, если его начало (<font face=Courier>Start</font>) меньше чем его конец (<font face=Courier>End</font>), а также существует инструкция, чьё смещение равно <font face=Courier>Start</font>, а также существует инструкция, чьё смещение равно  <font face=Courier>End</font> и класс обработчика исключений допустимо присваивать классу <font face=Courier>Throwable</font>.

 handlersAreLegal(Environment) :-
     exceptionHandlers(Environment, Handlers),
     checklist(handlerIsLegal(Environment), Handlers).
 
 handlerIsLegal(Environment, Handler) :-
     Handler = handler(Start, End, Target, _),
     Start < End,
     allInstructions(Environment, Instructions),
     member(instruction(Start, _), Instructions),
     offsetStackFrame(Environment, Target, _),
     instructionsIncludeEnd(Instructions, End),
     currentClassLoader(Environment, CurrentLoader),
     handlerExceptionClass(Handler, ExceptionClass, CurrentLoader),
     isBootstrapLoader(BL),
     isAssignable(ExceptionClass, class('java/lang/Throwable', BL)).
 
 instructionsIncludeEnd(Instructions, End) :-
     member(instruction(End, _), Instructions).
 
 instructionsIncludeEnd(Instructions, End) :-
     member(endOfCode(End), Instructions).

<br><br><br><br>
===== Инструкции =====
====== Изоморфные инструкции ======

Множество байткодов имеют правила типов совершенно изоморфные между собой. Если байткод b1 изоморфен другому байт-коду b2, то правило типов для b1 такое же как и для b2.

 instructionIsTypeSafe(Instruction, Environment, Offset, StackFrame,
                       NextStackFrame, ExceptionStackFrame) :-
     instructionHasEquivalentTypeRule(Instruction, IsomorphicInstruction),
     instructionIsTypeSafe(IsomorphicInstruction, Environment, Offset, StackFrame,
     NextStackFrame, ExceptionStackFrame).

<br><br><br><br>
====== Манипулирование стеком операндов ======

В этом разделе определены правила корректного манипулирования состоянием типов стека операндов. Манипулирование стеком операндов осложняется тем фактом, что некоторые типы данных занимают два элемента в стеке операндов. Это учтено в предикатах, данных в этом разделе, что позволяет в остальных разделах спецификации абстрагироваться от данного факта.

 canPop(frame(Locals, OperandStack, Flags), Types,
        frame(Locals, PoppedOperandStack, Flags)) :-
     popMatchingList(OperandStack, Types, PoppedOperandStack).
 
 popMatchingList(OperandStack, [], OperandStack).
 
 popMatchingList(OperandStack, [P | Rest], NewOperandStack) :-
     popMatchingType(OperandStack, P, TempOperandStack, _ActualType),
     popMatchingList(TempOperandStack, Rest, NewOperandStack).
 
 sizeOf(X, 2) :- isAssignable(X, twoWord).
 sizeOf(X, 1) :- isAssignable(X, oneWord).
 sizeOf(top, 1).

Считываем определённый тип из стека операндов. Более точно, если логическая вершина стека является подтипом определённого типа <font face=Courier>Type</font>, тогда считываем её. Если тип занимает два элемента в стеке, то логическая вершина стека на самом деле это тип под вершиной, а вершина — это неиспользуемый тип <font face=Courier>top</font>.

 popMatchingType([ActualType | OperandStack], Type, OperandStack, ActualType) :-
     sizeOf(Type, 1),
     isAssignable(ActualType, Type).
 
 popMatchingType([top, ActualType | OperandStack], Type, OperandStack, ActualType) :-
     sizeOf(Type, 2),
     isAssignable(ActualType, Type).

Записываем логический тип в стек. Точное поведение зависит от размера типа. Если записываемый тип имеет размер 1, то мы просто записываем его в стек. Если записываемый тип имеет размер 2, то мы записываем его, а затем записываем <font face=Courier>top</font>.

 pushOperandStack(OperandStack, 'void', OperandStack).
 pushOperandStack(OperandStack, Type, [Type | OperandStack]) :-
     sizeOf(Type, 1).
 pushOperandStack(OperandStack, Type, [top, Type | OperandStack]) :-
     sizeOf(Type, 2).

Размер стека операндов не должен превышать объявленного максимума. 

 operandStackHasLegalLength(Environment, OperandStack) :-
     length(OperandStack, Length),
     maxOperandStackLength(Environment, MaxStack),
     Length =< MaxStack.

Тип категории 1 занимает ровно один элемент в стеке. Считывание логического типа категории 1 (<font face=Courier>Type</font>) возможно, если вершина стека это <font face=Courier>Type</font> и <font face=Courier>Type</font> не равен <font face=Courier>top</font> (в противном случае он может означать верхнюю половину типа категории 2). В результате получаем стек, у которого с вершины снят один элемент.

 popCategory1([Type | Rest], Type, Rest) :-
     Type \= top,
     sizeOf(Type, 1).

Тип категории 2 занимает два элемента в стеке.  Считывание логического типа категории 2 (<font face=Courier>Type</font>) возможно, если вершина стека это тип равный <font face=Courier>top</font>, а элемент непосредственно ниже — это <font face=Courier>Type</font>. В результате получаем стек, у которого с вершины снято два элемента.

 popCategory2([top, Type | Rest], Type, Rest) :-
     sizeOf(Type, 2).
 
 canSafelyPush(Environment, InputOperandStack, Type, OutputOperandStack) :-
     pushOperandStack(InputOperandStack, Type, OutputOperandStack),
     operandStackHasLegalLength(Environment, OutputOperandStack).
 
 canSafelyPushList(Environment, InputOperandStack, Types, OutputOperandStack) :-
     canPushList(InputOperandStack, Types, OutputOperandStack),
     operandStackHasLegalLength(Environment, OutputOperandStack).
 
 canPushList(InputOperandStack, [Type | Rest], OutputOperandStack) :-
     pushOperandStack(InputOperandStack, Type, InterimOperandStack),
     canPushList(InterimOperandStack, Rest, OutputOperandStack).
     canPushList(InputOperandStack, [], InputOperandStack).

<br><br><br><br>
====== Инструкции загрузки ======

Все инструкции загрузки представляют собой разновидности общего шаблона, в зависимости от типа загружаемого значения.

Загрузка значения с типом <font face=Courier>Type</font> из локальной переменной <font face=Courier>Index</font> является безопасной по типу, если тип локальной переменной это <font face=Courier>ActualType</font>, при этом <font face=Courier>ActualType</font> допустимо присваивать <font face=Courier>Type</font> и запись во входящий стек операндов <font face=Courier>ActualType</font> является допустимым преобразованием типов, которое приводит к новому состоянию типов <font face=Courier>NextStackFrame</font>. После выполнения инструкции загрузки состояние типов будет <font face=Courier>NextStackFrame</font>.

 loadIsTypeSafe(Environment, Index, Type, StackFrame, NextStackFrame) :-
     StackFrame = frame(Locals, _OperandStack, _Flags),
     nth0(Index, Locals, ActualType),
     isAssignable(ActualType, Type),
     validTypeTransition(Environment, [], ActualType, StackFrame, NextStackFrame).

<br><br><br><br>
====== Инструкции сохранения ======

Все инструкции сохранения представляют собой разновидности общего шаблона, в зависимости от типа сохраняемого значения.

В общем случае, инструкция сохранения является безопасной по типу, если локальная переменная, на которую она ссылается имеет тип более общий чем <font face=Courier>Type</font>, а вершина стека операндов является подтипом <font face=Courier>Type</font>, где  <font face=Courier>Type</font> — это тип, который призвана сохранять инструкция.

Говоря более точно,  инструкция сохранения является безопасной по типу, если можно считать из стека операндов тип <font face=Courier>ActualType</font>, который «подходит»  <font face=Courier>Type</font> (например, является подтипом <font face=Courier>Type</font>), а затем корректно присвоить этот тип локальной переменной <font face=Courier>Lindex</font>.

 storeIsTypeSafe(_Environment, Index, Type,
                 frame(Locals, OperandStack, Flags),
                 frame(NextLocals, NextOperandStack, Flags)) :-
     popMatchingType(OperandStack, Type, NextOperandStack, ActualType),
     modifyLocalVariable(Index, ActualType, Locals, NextLocals).

Учитывая локальные переменные <font face=Courier>Locals</font>, изменение <font face=Courier>Index</font>, чтобы он имел тип <font face=Courier>Type</font> приводит к созданию локального списка переменных <font face=Courier>NewLocals</font>. Эти изменения немного запутанные, потому что некоторые значения (и их соответствующие типы) занимают две локальные переменные. Следовательно, изменения <font face=Courier>L<sub>N</sub></font> могут потребовать изменений в <font face=Courier>L<sub>N+1</sub></font> (потому что тип занимает две ячейки: <font face=Courier>N</font> и <font face=Courier>N</font>+1) либо в <font face=Courier>L<sub>N-1</sub></font> (потому что локальное <font face=Courier>N</font> представляет собой верхнюю половину двухсловного значения, начинающегося с  <font face=Courier>N</font>-1 и поэтому локальное <font face=Courier>N</font>-1 должно быть помечено как недействительное) либо и то и другое вместе. Это описано немного ниже. Мы начнём с  <font face=Courier>L<sub>0</sub></font> и будем продолжать.

 modifyLocalVariable(Index, Type, Locals, NewLocals) :-
     modifyLocalVariable(0, Index, Type, Locals, NewLocals).

Учитывая <font face=Courier>LocalsRest</font>, суффикс списка локальной переменной, начинающийся с индекса I, изменения локальной переменной <font face=Courier>Index</font>, чтобы она имела тип <font face=Courier>Type</font> приводит к созданию списка локальных переменных <font face=Courier>NewLocalsRest</font>.

Если <font face=Courier>I</font> < <font face=Courier>Index</font> - 1, то просто копируем вход в выход и идём далее. Если <font face=Courier>I</font> = <font face=Courier>Index</font>-1, то тип локальной <font face=Courier>I</font> может измениться. Это может произойти, если <font face=Courier>L<sub>I</sub></font> имеет тип размера 2. Когда мы установили <font face=Courier>L<sub>I+1</sub></font> в новый тип (и соответствующее значение), то тип/значение <font face=Courier>L<sub>I</sub></font> может быть помечен как недействительный, так как его верхняя половина будет потеряна.  Затем мы движемся далее.

Когда мы находим переменную и она занимает только одно слово, мы заменяем её на <font face=Courier>Type</font>.

Когда мы находим переменную и она занимает два слова, мы заменяем её тип на  <font face=Courier>Type</font>, а следующее слово на <font face=Courier>top</font>.

 modifyLocalVariable(I, Index, Type,
                     [Locals1 | LocalsRest], [Locals1 | NextLocalsRest] ) :-
     I < Index - 1,
     I1 is I + 1,
     modifyLocalVariable(I1, Index, Type, LocalsRest, NextLocalsRest).
 
 modifyLocalVariable(I, Index, Type,
                    [Locals1 | LocalsRest], [NextLocals1 | NextLocalsRest] ) :-
     I =:= Index - 1,
     modifyPreIndexVariable(Locals1, NextLocals1),
     modifyLocalVariable(Index, Index, Type, LocalsRest, NextLocalsRest).
 
 modifyLocalVariable(Index, Index, Type,
                     [_ | LocalsRest], [Type | LocalsRest]) :-
     sizeOf(Type, 1).
 
 modifyLocalVariable(Index, Index, Type,
                     [_, _ | LocalsRest], [Type, top | LocalsRest]) :-
     sizeOf(Type, 2).

Мы ссылаемся на локальную переменную, чей индекс непосредственно предшествует локальной переменной, тип которой будет изменён на ''переменная предшествующая индексу''. Будущий тип переменной предшествующей индексу с типом <font face=Courier>InputType</font> это <font face=Courier>Result</font>. Если тип <font face=Courier>Type</font>  переменной предшествующей индексу имеет размер 1, то он не меняется. Если тип <font face=Courier>Type</font> переменной предшествующей индексу имеет размер 2, то нам необходимо пометить нижнюю половину его двухсловного значения как неиспользуемую посредством присваивания ей типа <font face=Courier>top</font>.

 modifyPreIndexVariable(Type, Type) :- sizeOf(Type, 1).
 modifyPreIndexVariable(Type, top) :- sizeOf(Type, 2).

Если дан список типов, то мы получаем список, где каждый тип размера 2 замещён двумя элементами: непосредственно типом и элементом <font face=Courier>top</font>. В таком случае результат соответствует представлению списка набора 32-х битных слов в виртуальной машине Java.

 expandTypeList([], []).
 
 expandTypeList([Item | List], [Item | Result]) :-
     sizeOf(Item, 1),
     expandTypeList(List, Result).
 
 expandTypeList([Item | List], [Item, top | Result]) :-
     sizeOf(Item, 2),
     expandTypeList(List, Result).

<br><br><br><br>
====== Список инструкций ======

В общем случае тип правила для инструкции дан относительно окружения <font face=Courier>Environment</font>, которое определяет класс и метод, в которых встречается инструкция и смещение <font face=Courier>Offset</font> внутри метода, по которому расположена инструкция. Правило утверждает входящее состояние типов <font face=Courier>StackFrame</font> удовлетворяет определенным требованиям, тогда:

* Инструкция безопасна по типу.

* Можно доказать, что состояние типов после инструкции, выполнившейся успешно, имеет определённую форму, заданную в <font face=Courier>NextStackFrame</font>, и состояние типов после инструкции, выполнившейся аварийно, дано в <font face=Courier>ExceptionStackFrame</font>.

Мы старались сделать описание правил на естественном языке легко читаемым, интуитивно понятным и кратким. Поэтому в описании не повторяются все концептуальные предположения данные ниже. В частности:

* Явно мы не упоминаем окружение.

* Когда мы говорим о стеке операндов или о локальных переменных, мы ссылаемся на компоненту состояния типов стека операндов или локальных переменных: либо входящее состояние типов либо исходящее.

* Состояние типов после того как инструкция завершается аварийно, почти всегда равно входящему состоянию типов. Мы обсуждаем состояние типов после аварийного завершения инструкции только если оно не равно исходному.

* Мы говорим о записи и считывание типов в стек и из стека операндов. Явно мы не обсуждаем случаи переполнения и антипереполнения стека, но предполагаем, что запись и считывание могут пройти успешно. Формальные правила для работы со стеком операндов гарантируют, что необходимые проверки пройдены. 

* Аналогично, в тексте описана работы только с логическими типами. На практике, некоторые типы занимают более одного слова. Мы абстрагируемся от этих деталей представления в нашем обсуждении, но не в логических правилах которые используют эти типы данных.

Любые неопределённости могут быть разрешены посредством обращения к формальным правилам Пролога.

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aaload'''''
| style="text-align:right;"  | '''''aaload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''aaload'' безопасна по типу тогда и только тогда, когда мы правомерно можем заменить тип <font face=Courier>int</font> и массив с компонентами <font face=Courier>ComponentType</font>, где <font face=Courier>ComponentType</font> это подтип  <font face=Courier>Object</font>  на <font face=Courier>ComponentType</font> равный  выходному состоянию типов.
|}
 
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">instructionIsTypeSafe(aaload, Environment, _Offset, StackFrame,
			NextStackFrame, ExceptionStackFrame) :-
    nth1OperandStackIs(2, StackFrame, ArrayType),
    arrayComponentType(ArrayType, ComponentType),
    isBootstrapLoader(BL),
    validTypeTransition(Environment,
			  [int, arrayOf(class('java/lang/Object', BL))],
                        ComponentType, StackFrame, NextStackFrame),
exceptionStackFrame(StackFrame, ExceptionStackFrame).   
</syntaxhighlight>
|}

{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Тип компонента массива <font face=Courier>X</font> это <font face=Courier>X</font>. Мы определяем тип компонента <font face=Courier>null</font> равным <font face=Courier>null</font>.
|}
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
arrayComponentType(arrayOf(X), X).
arrayComponentType(null, null).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aastore'''''
| style="text-align:right;"  | '''''aastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''aastore'' безопасна по типу тогда и только тогда, когда мы правомерно можем считать из входящего стека операндов типы, соответствующие <font face=Courier>Object</font>, <font face=Courier>int</font> и массиву <font face=Courier>Object</font> и после этого получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(aastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    isBootstrapLoader(BL),
    canPop(StackFrame,
           [class('java/lang/Object', BL),
           int,
           arrayOf(class('java/lang/Object', BL))],
           NextStackFrame),
exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aconst_null'''''
| style="text-align:right;"  | '''''aconst_null'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''aconst_null'' безопасна по типу тогда и только тогда, когда мы правомерно можем записать во входящий стек тип <font face=Courier>null</font> и после этого получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(aconst_null, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], null, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aload'''''
| style="text-align:right;"  | '''''aload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''aload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>reference</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(aload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
     loadIsTypeSafe(Environment, Index, reference,
     StackFrame,  NextStackFrame),
     exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aload_<n>'''''
| style="text-align:right;"  | '''''aload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''aload_<n>'' для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''aload'' безопасна по типу. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(aload_0,aload(0)).
instructionHasEquivalentTypeRule(aload_1,aload(1)).
instructionHasEquivalentTypeRule(aload_2,aload(2)).
instructionHasEquivalentTypeRule(aload_3,aload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''anewarray'''''
| style="text-align:right;"  | '''''anewarray'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''anewarray'' с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда  <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего либо класс, либо массив и можно правомерно заменить тип <font face=Courier>int</font> во входящем стеке операндов на массив с компонентами  <font face=Courier>CP</font> и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(anewarray(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    (CP = class(_, _) ; CP = arrayOf(_)),
    validTypeTransition(Environment, [int], arrayOf(CP),
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''areturn'''''
| style="text-align:right;"  | '''''areturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''areturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>ReturnType</font> равный типу <font face=Courier>reference</font> и допустимо считать тип соответствующий <font face=Courier>ReturnType</font> из входящего стека операндов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(areturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, ReturnType),
    isAssignable(ReturnType, reference),
    canPop(StackFrame, [ReturnType], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''arraylength'''''
| style="text-align:right;"  | '''''arraylength'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''arraylength'' безопасна по типу тогда и только тогда, когда допустимо заменить тип массива во входящем стеке операндов на тип <font face=Courier>int</font> и при этом получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(arraylength, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    nth1OperandStackIs(1, StackFrame, ArrayType),
    arrayComponentType(ArrayType, _),
    validTypeTransition(Environment, [top], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''astore'''''
| style="text-align:right;"  | '''''astore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''astore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>reference</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(astore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, reference, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''astore_<n>'''''
| style="text-align:right;"  | '''''astore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''astore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''astore''  также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(astore_0, astore(0)).
instructionHasEquivalentTypeRule(astore_1, astore(1)).
instructionHasEquivalentTypeRule(astore_2, astore(2)).
instructionHasEquivalentTypeRule(astore_3, astore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''athrow'''''
| style="text-align:right;"  | '''''athrow'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''athrow'' безопасна по типу тогда и только тогда, когда на вершине стека операндов находится элемент, соответствующий <font face=Courier>Throwable</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(athrow, _Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    isBootstrapLoader(BL),
    canPop(StackFrame, [class('java/lang/Throwable', BL)], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''baload'''''
| style="text-align:right;"  | '''''baload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''baload'' безопасна по типу тогда и только тогда, когда допустимо заменить типы, соответствующие <font face=Courier>int</font> и массиву «малых» типов во входящем стеке операндов на тип <font face=Courier>int</font> и после замены получить выходное состояние типов.

Массив является ''массивом «малых» типов''  если это массив из типов <font face=Courier>byte</font>, либо <font face=Courier>boolean</font>, либо <font face=Courier>null</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(baload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :
    nth1OperandStackIs(2, StackFrame, Array),
    isSmallArray(Array),
    validTypeTransition(Environment, [int, top], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).

isSmallArray(arrayOf(byte)).
isSmallArray(arrayOf(boolean)).
isSmallArray(null).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''bastore'''''
| style="text-align:right;"  | '''''bastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''bastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font>, <font face=Courier>int</font> и массиву «малых» типов и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(bastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    nth1OperandStackIs(3, StackFrame, Array),
    isSmallArray(Array),
    canPop(StackFrame, [int, int, top], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''bipush'''''
| style="text-align:right;"  | '''''bipush'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''bastore''  безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''sipush'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(bipush(Value), sipush(Value)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''caload'''''
| style="text-align:right;"  | '''''caload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''caload'' безопасна по типу тогда и только тогда, когда допустимо заменить типы, соответствующие <font face=Courier>int</font> и массиву типов <font face=Courier>char</font> во входящем стеке операндов на тип <font face=Courier>int</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(caload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(char)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''castore'''''
| style="text-align:right;"  | '''''castore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''castore'' безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font>, <font face=Courier>int</font> и массиву  типов <font face=Courier>char</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(castore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int, int, arrayOf(char)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''checkcast'''''
| style="text-align:right;"  | '''''checkcast'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''checkcast''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего либо класс либо массив и допустимо заменить тип <font face=Courier>Object</font> на вершине входящего стека операндов на тип, обозначенный через  <font face=Courier>CP</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(checkcast(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    (CP = class(_, _) ; CP = arrayOf(_)),
    isBootstrapLoader(BL),
    validTypeTransition(Environment, [class('java/lang/Object', BL)], CP,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2f'''''
| style="text-align:right;"  | '''''d2f'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''d2f''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип <font face=Courier>double</font>, заменить его на <font face=Courier>float</font> и после получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(d2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2i'''''
| style="text-align:right;"  | '''''d2i'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''d2i''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип <font face=Courier>double</font>, заменить его на <font face=Courier>int</font> и после получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(d2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2l'''''
| style="text-align:right;"  | '''''d2l'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''d2l''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип <font face=Courier>double</font>, заменить его на <font face=Courier>long</font> и после получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(d2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
     validTypeTransition(Environment, [double], long,
                         StackFrame, NextStackFrame),
     exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dadd'''''
| style="text-align:right;"  | '''''dadd'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dadd'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>double</font> и <font face=Courier>double</font>, на <font face=Courier>double</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
     validTypeTransition(Environment, [double, double], double,
                         StackFrame, NextStackFrame),
     exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''daload'''''
| style="text-align:right;"  | '''''daload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''daload'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>double</font>, на <font face=Courier>double</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(daload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(double)], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dastore'''''
| style="text-align:right;"  | '''''dastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>double</font>, <font face=Courier>int</font> и массиву типов <font face=Courier>double</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [double, int, arrayOf(double)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dcmp<op>'''''
| style="text-align:right;"  | '''''dcmp<op>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dcmpg'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>double</font> и <font face=Courier>double</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dcmpg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double, double], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dcmpl'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dcmpg'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dcmpl, dcmpg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dconst_<d>'''''
| style="text-align:right;"  | '''''dconst_<d>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dconst_0''  безопасна по типу тогда и только тогда, когда допустимо записать во входящий стек операндов тип, соответствующий <font face=Courier>double</font>,  и после записи получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dconst_1'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dconst_0'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dconst_1, dconst_0).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ddiv'''''
| style="text-align:right;"  | '''''ddiv'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ddiv'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ddiv, dadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dload'''''
| style="text-align:right;"  | '''''dload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>double</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    loadIsTypeSafe(Environment, Index, double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dload_<n>'''''
| style="text-align:right;"  | '''''dload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''dload_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''dload'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dload_0, dload(0)).
instructionHasEquivalentTypeRule(dload_1, dload(1)).
instructionHasEquivalentTypeRule(dload_2, dload(2)).
instructionHasEquivalentTypeRule(dload_3, dload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dmul'''''
| style="text-align:right;"  | '''''dmul'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dmul'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dmul, dadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dneg'''''
| style="text-align:right;"  | '''''dneg'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dneg''  безопасна по типу тогда и только тогда, когда  во входящем стеке  находится тип, соответствующие <font face=Courier>double</font>. Инструкция ''dneg''  не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''drem'''''
| style="text-align:right;"  | '''''drem'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''drem'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(drem, dadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dreturn'''''
| style="text-align:right;"  | '''''dreturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dreturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>double</font>  и допустимо считать тип соответствующий <font face=Courier>double</font> из входящего стека операндов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dreturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, double),
    canPop(StackFrame, [double], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dstore'''''
| style="text-align:right;"  | '''''dstore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dstore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>double</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dstore_<n>'''''
| style="text-align:right;"  | '''''dstore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''dstore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''dstore'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dstore_0, dstore(0)).
instructionHasEquivalentTypeRule(dstore_1, dstore(1)).
instructionHasEquivalentTypeRule(dstore_2, dstore(2)).
instructionHasEquivalentTypeRule(dstore_3, dstore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dsub'''''
| style="text-align:right;"  | '''''dsub'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dsub'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dsub, dadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup'''''
| style="text-align:right;"  | '''''dup'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup''  безопасна по типу тогда и только тогда, когда допустимо заменить тип <font face=Courier>Type</font>, принадлежащий категории 1 на типы <font face=Courier>Type</font> , <font face=Courier>Type</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    popCategory1(InputOperandStack, Type, _),
    canSafelyPush(Environment, InputOperandStack, Type, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup_x1'''''
| style="text-align:right;"  | '''''dup_x1'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x1''  безопасна по типу тогда и только тогда, когда допустимо заменить два типа <font face=Courier>Type1</font> и <font face=Courier>Type2</font>, принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup_x1, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup_x2'''''
| style="text-align:right;"  | '''''dup_x2'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x2'' безопасна по типу тогда и только тогда, когда она представляет собой одну из безопасных по типу форм этой инструкции:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup_x2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack,
                             OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x2'' является ''безопасной по типу формой'' инструкции ''dup_x2''  только тогда, когда она является формой 1 инструкции ''dup_x2'' или формой 2 этой инструкции.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x2''  является ''безопасной по типу формой 1'' инструкции dup_x2 тогда и только тогда, когда допустимо заменить три типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и <font face=Courier>Type3</font>, принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x2''  является ''безопасной по типу формой 2'' инструкции dup_x2 тогда и только тогда, когда допустимо заменить  тип <font face=Courier>Type1</font>, принадлежащий категории 1, и тип <font face=Courier>Type2</font>, принадлежащий категории 2, на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>,  <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory2(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2'''''
| style="text-align:right;"  | '''''dup2'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2'' безопасна по типу тогда и только тогда, когда она представляет собой одну из безопасных по типу форм этой инструкции:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2SomeFormIsTypeSafe(Environment,InputOperandStack, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2'' является ''безопасной по типу формой'' инструкции dup2  только тогда, когда она является формой 1 инструкции ''dup2'' или формой 2 этой инструкции.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2Form1IsTypeSafe(Environment,InputOperandStack, OutputOperandStack).

dup2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2Form2IsTypeSafe(Environment,InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2''  является ''безопасной по типу формой 1'' инструкции dup2 тогда и только тогда, когда допустимо заменить два типа <font face=Courier>Type1</font> и  <font face=Courier>Type2</font>  принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack):-
    popCategory1(InputOperandStack, Type1, TempStack),
    popCategory1(TempStack, Type2, _),
    canSafelyPushList(Environment, InputOperandStack, [Type1, Type2],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2''  является безопасной по типу формой 2 инструкции ''dup2'' тогда и только тогда, когда допустимо заменить  тип <font face=Courier>Type</font>, принадлежащий категории 2,  на типы <font face=Courier>Type</font>, <font face=Courier>Type</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack):-
    popCategory2(InputOperandStack, Type, _),
    canSafelyPush(Environment, InputOperandStack, Type, OutputOperandStack).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2_x1'''''
| style="text-align:right;"  | '''''dup2_x1'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x1'' безопасна по типу тогда и только тогда, когда она представляет собой одну из безопасных по типу форм этой инструкции:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup2_x1, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2_x1SomeFormIsTypeSafe(Environment, InputOperandStack,
                              OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x1'' является ''безопасной по типу формой'' инструкции dup2_x1  только тогда, когда она является формой 1 инструкции ''dup2_x1'' или формой 2 этой инструкции.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
up2_x1SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x1Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup2_x1SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x1Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x1''  является ''безопасной по типу формой 1'' инструкции dup2_x1 тогда и только тогда, когда допустимо заменить три типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font>  и  <font face=Courier>Type3</font>  принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x1Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest, [Type2, Type1, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x1''  является ''безопасной по типу формой 2'' инструкции dup2_x1 тогда и только тогда, когда допустимо заменить  тип <font face=Courier>Type1</font>, принадлежащий категории 2, и тип <font face=Courier>Type2</font>, принадлежащий категории 1  на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x1Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2_x2'''''
| style="text-align:right;"  | '''''dup2_x2'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2'' безопасна по типу тогда и только тогда, когда она представляет собой одну из безопасных по типу форм этой инструкции:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup2_x2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack,
                              OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2'' является ''безопасной по типу формой'' инструкции dup2_x2  только тогда, когда справедливо одно из следующих утверждений:
* она является безосной по типу формой 1 инструкции ''dup2_x2''.
* она является безосной по типу формой 2 инструкции ''dup2_x2''.
* она является безосной по типу формой 3 инструкции ''dup2_x2''.
* она является безосной по типу формой 4 инструкции ''dup2_x2''.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form3IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form4IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2''  является ''безопасной по типу формой 1'' инструкции dup2_x2 тогда и только тогда, когда допустимо заменить четыре типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>   и  <font face=Courier>Type4</font>  принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type4</font>, <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Stack3),
    popCategory1(Stack3, Type4, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type2, Type1, Type4, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2''  является ''безопасной по типу формой 2'' инструкции dup2_x2 тогда и только тогда, когда допустимо заменить  тип <font face=Courier>Type1</font>, принадлежащий категории 2, и два типа <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, принадлежащий категории 1  на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type1, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2''  является ''безопасной по типу формой 3'' инструкции dup2_x2 тогда и только тогда, когда допустимо заменить  два типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, принадлежащие категории 1, и  тип <font face=Courier>Type3</font>, принадлежащий категории 2,  на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2Form3IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory2(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type2, Type1, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2''  является ''безопасной по типу формой 4'' инструкции dup2_x2 тогда и только тогда, когда допустимо заменить  два типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, принадлежащие категории 2,  на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type1</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2Form4IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory2(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2d'''''
| style="text-align:right;"  | '''''f2d'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''f2d''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>float</font>, и заменить его на <font face=Courier>double</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(f2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2i'''''
| style="text-align:right;"  | '''''f2i'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''f2i''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>float</font>, и заменить его на <font face=Courier>int</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(f2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float], int,
                    StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2l'''''
| style="text-align:right;"  | '''''f2l'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''f2l''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>float</font>, и заменить его на <font face=Courier>long</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(f2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fadd'''''
| style="text-align:right;"  | '''''fadd'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fadd''  безопасна по типу тогда и только тогда, когда допустимо заменить во входящем стеке операндов типы, соответствующие <font face=Courier>float</font> и <font face=Courier>float</font>,  на <font face=Courier>float</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float, float], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>



<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''faload'''''
| style="text-align:right;"  | '''''faload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''faload''  безопасна по типу тогда и только тогда, когда допустимо заменить во входящем стеке операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>float</font>,  на <font face=Courier>float</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(faload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(float)], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fastore'''''
| style="text-align:right;"  | '''''fastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>float</font>,  <font face=Courier>int</font> и массиву <font face=Courier>float</font>,   и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [float, int, arrayOf(float)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fcmp<op>'''''
| style="text-align:right;"  | '''''fcmp<op>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fcmpg''  безопасна по типу тогда и только тогда, когда допустимо заменить во входящем стеке операндов типы, соответствующие <font face=Courier>float</font> и  <font face=Courier>float</font>,  на <font face=Courier>int</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fcmpg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float, float], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fcmpl''  безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fcmpg'' также  безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fcmpl, fcmpg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fconst_<f>'''''
| style="text-align:right;"  | '''''fconst_<f>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fconst_0''  безопасна по типу тогда и только тогда, когда допустимо записать во входящий стек операндов тип, соответствующий <font face=Courier>float</font>   и после записи получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Правила для остальных вариантов инструкции <font face=Courier>fconst</font> эквивалентны.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fconst_1, fconst_0).
instructionHasEquivalentTypeRule(fconst_2, fconst_0).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fdiv'''''
| style="text-align:right;"  | '''''fdiv'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fdiv'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fdiv, fadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fload'''''
| style="text-align:right;"  | '''''fload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>float</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    loadIsTypeSafe(Environment, Index, float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fload_<n>'''''
| style="text-align:right;"  | '''''fload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''fload_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''fload'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fload_0, fload(0)).
instructionHasEquivalentTypeRule(fload_1, fload(1)).
instructionHasEquivalentTypeRule(fload_2, fload(2)).
instructionHasEquivalentTypeRule(fload_3, fload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fmul'''''
| style="text-align:right;"  | '''''fmul'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fmul'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fmul, fadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fneg'''''
| style="text-align:right;"  | '''''fneg'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fneg''  безопасна по типу тогда и только тогда, когда  во входящем стеке  находится тип, соответствующие <font face=Courier>float</font>. Инструкция ''fneg''  не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''frem'''''
| style="text-align:right;"  | '''''frem'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''frem'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(frem, fadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''freturn'''''
| style="text-align:right;"  | '''''freturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''freturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>float</font>  и допустимо считать тип соответствующий <font face=Courier>float</font> из входящего стека операндов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(freturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, float),
    canPop(StackFrame, [float], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fstore'''''
| style="text-align:right;"  | '''''fstore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fstore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>float</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fstore_<n>'''''
| style="text-align:right;"  | '''''fstore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''fstore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''fstore'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fstore_0, fstore(0)).
instructionHasEquivalentTypeRule(fstore_1, fstore(1)).
instructionHasEquivalentTypeRule(fstore_2, fstore(2)).
instructionHasEquivalentTypeRule(fstore_3, fstore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fsub'''''
| style="text-align:right;"  | '''''fsub'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fsub'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fsub, fadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''getfield'''''
| style="text-align:right;"  | '''''getfield'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''getfield'' с операндом <font face=Courier>CP</font> безопасна по типу тогда и только тогда, когда  <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего поле, чей объявленный тип равен <font face=Courier>FieldType</font>, в классе <font face=Courier>FieldClass</font> и допустимо заменить во входящем стеке операндов тип, соответствующий <font face=Courier>FieldClass</font> на тип <font face=Courier>FieldType</font> и после замены получить выходящее состояние типов. <font face=Courier>FieldClass</font> не должен быть массивом. Поля с модификатором доступа <font face=Courier>protected</font> обсуждаются ниже.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(getfield(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = field(FieldClass, FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    passesProtectedCheck(Environment, FieldClass, FieldName,
                         FieldDescriptor, StackFrame),
    validTypeTransition(Environment, [class(FieldClass)], FieldType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Проверка для модификатора <font face=Courier>protected</font> применима только к членам данным классов предков текущего класса. Остальные случаи вступают в силу при выполнении проверок во время разрешения ссылок. Если имя текущего класса не совпадает с именем класса предка, то такой случай может быть безопасно проигнорирован.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor, StackFrame) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    notMember(class(MemberClassName, _), Chain).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Использование членов данных, которые не являются <font face=Courier>protected</font> тривиально и является корректным.

Если <font face=Courier>MemberClassName</font> такой же как и имя класса предка, то класс, чьё разрешение сейчас происходит, может быть на самом деле классом предком. В этом случае, если в другом  пакете времени выполнения отсутствует класс предок с именем <font face=Courier>MemberClassName</font>, который имеет член с модификатором <font face=Courier>protected</font>, именем <font face=Courier>MemberName</font> и дескриптором <font face=Courier>MemberDescriptor</font>, то нет необходимости применять проверку для <font face=Courier>protected</font>.

Так происходит потому, что класс, разрешение которого в данный момент происходит, будет  одним из тех классов предков, для которых мы знаем, что либо это тот же пакет времени выполнения и доступ в этом случае может быть предоставлен; либо член данное, о котором идёт речь, не является  <font face=Courier>protected</font> и проверка не применяется; либо он будет классом наследником, и в этом случае проверка закончится успешно всегда; либо он будет каким-либо другим классом в том же пакете времени выполнения и это значит доступ  может быть предоставлен, а в проверке нет необходимости; либо верификатор считает, что нет необходимости отмечать эту ситуацию как проблемную, поскольку она будет все равно перехвачена аварийно завершившегося разрешения. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor, StackFrame) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWithProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, []).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Если в классе предке существует член с модификатором <font face=Courier>protected</font> в другом пакете времени выполнения, выполняется загрузка <font face=Courier>MemberClassName</font>; если член данное не является <font face=Courier>protected</font>, то проверка не выполняется.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor,

                     frame(_Locals, [Target | Rest], _Flags)) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWIthProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, List),
    List /= [],
    loadedClass(MemberClassName, CurrentLoader, ReferencedClass),
    isNotProtected(ReferencedClass, MemberName, MemberDescriptor).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
В противном случае использование члена с типом <font face=Courier>Target</font> требует того, чтобы <font face=Courier>Target</font> можно было присвоить типу в текущем классе.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor,
    frame(_Locals, [Target | Rest], _Flags)) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWithProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, List),
  List /= [],
  loadedClass(MemberClassName, CurrentLoader, ReferencedClass),
  isProtected(ReferencedClass, MemberName, MemberDescriptor),
  isAssignable(Target, class(CurrentClassName, CurrentLoader)).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Предикат <font face=Courier>classesInOtherPkgWithProtectedMember</font>(<font face=Courier>Class</font>, <font face=Courier>MemberName</font>, <font face=Courier>MemberDescriptor</font>, <font face=Courier>MemberClassName</font>, <font face=Courier>Chain</font>, <font face=Courier>List</font>) является истинным, если <font face=Courier>List</font> — это набор классов цепи <font face=Courier>Chain</font> с находящимся в нем именем <font face=Courier>MemberClassName</font>, причём класс <font face=Courier>MemberClassName</font> расположен в отличном пакете времени выполнения, чем  класс <font face=Courier>Class</font>, который имеет член данное  <font face=Courier>MemberName</font> с модификатором <font face=Courier>protected</font> и дескриптором <font face=Courier>MemberDescriptor</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
classesInOtherPkgWithProtectedMember(_, _, _, _, [], []).

classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     [class(MemberClassName, L) | T]) :-
    differentRuntimePackage(Class, class(MemberClassName, L)),
    loadedClass(MemberClassName, L, Super),
    isProtected(Super, MemberName, MemberDescriptor),
    classesInOtherPkgWithProtectedMember(
      Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).

classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     T) :-
   differentRuntimePackage(Class, class(MemberClassName, L)),
   loadedClass(MemberClassName, L, Super),
   isNotProtected(Super, MemberName, MemberDescriptor),
   classesInOtherPkgWithProtectedMember(
     Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).

classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     T] :-
    sameRuntimePackage(Class, class(MemberClassName, L)),
    classesInOtherPkgWithProtectedMember(
      Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''getstatic'''''
| style="text-align:right;"  | '''''getstatic'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''getstatic'' с операндом <font face=Courier>CP</font> безопасна по типу тогда и только тогда, когда  <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего поле, чей объявленный тип равен <font face=Courier>FieldType</font>,  и допустимо записать во входящий стек операндов тип, соответствующий  <font face=Courier>FieldType</font> и после записи получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(getstatic(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = field(_FieldClass, _FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    validTypeTransition(Environment, [], FieldType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''goto'''''
| style="text-align:right;"  | '''''goto'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''goto''  безопасна по типу тогда и только тогда, когда её целевой операнд может быть точкой перехода.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(goto(Target), Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    targetIsTypeSafe(Environment, StackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''goto_w'''''
| style="text-align:right;"  | '''''goto_w'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''goto_w''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''goto'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(goto_w(Target), goto(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2b'''''
| style="text-align:right;"  | '''''i2b'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2b''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''ineg'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(i2b, ineg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2c'''''
| style="text-align:right;"  | '''''i2c'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2c''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''ineg'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(i2c, ineg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2d'''''
| style="text-align:right;"  | '''''i2d'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2d''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>int</font>, затем записать туда  <font face=Courier>double</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(i2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2f'''''
| style="text-align:right;"  | '''''i2f'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2f''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>int</font>, затем записать туда  <font face=Courier>float</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(i2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2l'''''
| style="text-align:right;"  | '''''i2l'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2f''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>int</font>, затем записать туда  <font face=Courier>long</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(i2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2s'''''
| style="text-align:right;"  | '''''i2s'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2s''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''ineg'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(i2s, ineg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iadd'''''
| style="text-align:right;"  | '''''iadd'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iadd'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и <font face=Courier>int</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, int], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iaload'''''
| style="text-align:right;"  | '''''iaload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iaload'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>int</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iaload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(int)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iand'''''
| style="text-align:right;"  | '''''iand'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iand''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''iadd'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(iand, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iastore'''''
| style="text-align:right;"  | '''''iastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font>, <font face=Courier>int</font> и массиву типов <font face=Courier>int</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int, int, arrayOf(int)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if_acmp<cond>'''''
| style="text-align:right;"  | '''''if_acmp<cond>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''if_acmpeq''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>reference</font> и <font face=Courier>reference</font> и после считывания получить выходное состояние типов <font face=Courier>NextStackFrame</font>, причём операнд <font face=Courier>Target</font> инструкции ''if_acmpeq'' является  допустимой целью для перехода, принимая во внимание <font face=Courier>NextStackFrame</font> как  входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(if_acmpeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [reference, reference], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Правило для ''if_acmpne'' идентично.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(if_acmpne(Target), if_acmpeq(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if_icmp<cond>'''''
| style="text-align:right;"  | '''''if_icmp<cond>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''if_icmpeq''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и <font face=Courier>int</font> и после считывания получить выходное состояние типов <font face=Courier>NextStackFrame</font>, причём операнд <font face=Courier>Target</font> инструкции ''if_icmpeq'' является  допустимой целью для перехода, принимая во внимание <font face=Courier>NextStackFrame</font> как  входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(if_icmpeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int, int], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Правила для остальных вариантов инструкции ''if_icmp<cond>'' идентичны.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(if_icmpge(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmpgt(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmple(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmplt(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmpne(Target), if_icmpeq(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if<cond>'''''
| style="text-align:right;"  | '''''if<cond>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ifeq''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>int</font>  и после считывания получить выходное состояние типов <font face=Courier>NextStackFrame</font>, причём операнд <font face=Courier>Target</font> инструкции ''ifeq'' является  допустимой целью для перехода, принимая во внимание <font face=Courier>NextStackFrame</font> как  входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ifeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Правила для остальных вариантов инструкции ''if<cond>'' идентичны.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ifge(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifgt(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifle(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(iflt(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifne(Target), ifeq(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ifnonnull'''''
| style="text-align:right;"  | '''''ifnonnull'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ifnonnull'' безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>reference</font>  и после считывания получить выходное состояние типов <font face=Courier>NextStackFrame</font>, причём операнд <font face=Courier>Target</font> инструкции ''ifnonnull'' является  допустимой целью для перехода, принимая во внимание <font face=Courier>NextStackFrame</font> как  входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ifnonnull(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [reference], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ifnull'''''
| style="text-align:right;"  | '''''ifnull'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ifnull''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''ifnonnull'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ifnull(Target), ifnonnull(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iinc'''''
| style="text-align:right;"  | '''''iinc'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iinc'' с первым операндом <font face=Courier>Index</font> безопасна по типу тогда и только тогда, когда  <font face=Courier>LIndex</font> имеет тип <font face=Courier>int</font>. Инструкция ''iinc'' не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iinc(Index, _Value), _Environment, _Offset,
                     StackFrame, StackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, _OperandStack, _Flags),
    nth0(Index, Locals, int),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iload'''''
| style="text-align:right;"  | '''''iload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>int</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iload(Index), Environment, _Offset, StackFrame,
NextStackFrame, ExceptionStackFrame) :-
loadIsTypeSafe(Environment, Index, int, StackFrame, NextStackFrame),
exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iload_<n>'''''
| style="text-align:right;"  | '''''iload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''iload_<n>'', где 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная им инструкция ''iload'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(iload_0, iload(0)).
instructionHasEquivalentTypeRule(iload_1, iload(1)).
instructionHasEquivalentTypeRule(iload_2, iload(2)).
instructionHasEquivalentTypeRule(iload_3, iload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''imul'''''
| style="text-align:right;"  | '''''imul'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''imul'' безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''iadd'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(imul, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ineg'''''
| style="text-align:right;"  | '''''ineg'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ineg'' безопасна по типу тогда и только тогда, когда во входящем стеке операндов находится тип, соответствующий <font face=Courier>int</font>. Инструкция ''ineg'' не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ineg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''instanceof'''''
| style="text-align:right;"  | '''''instanceof'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''instanceof''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего либо класс либо массив и допустимо заменить тип <font face=Courier>Object</font> на вершине входящего стека операндов на тип <font face=Courier>int</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(instanceof(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    (CP = class(_, _) ; CP = arrayOf(_)),
    isBootstrapLoader(BL),
    validTypeTransition(Environment, [class('java/lang/Object'), BL], int,
                        StackFrame,NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokedynamic'''''
| style="text-align:right;"  | '''''invokedynamic'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokedynamic'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:


* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего узел динамического вызова с именем <font face=Courier>CallSiteName</font> и дескриптором <font face=Courier>Descriptor</font>.
* <font face=Courier>CallSiteName</font> не является <font face=Courier><init></font>.
* <font face=Courier>CallSiteName</font> не является <font face=Courier><clinit></font>.
* Во входящем стеке операндов допустимо заменить типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokedynamic(CP,0,0), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :-
    CP = dmethod(CallSiteName, Descriptor),
    CallSiteName \= ' <init> ',
    CallSiteName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    reverse(OperandArgList, StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokeinterface'''''
| style="text-align:right;"  | '''''invokeinterface'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokeinterface'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:


* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего метод интерфейса с именем <font face=Courier>MethodName</font> и дескриптором <font face=Courier>Descriptor</font>, который является членом интерфейса с именем <font face=Courier>MethodIntfName</font>.
* <font face=Courier>CallSiteName</font> не является <font face=Courier><init></font>.
* <font face=Courier>CallSiteName</font> не является <font face=Courier><clinit></font>.
* Её второй операнд <font face=Courier>Count</font> является действительным счётчиком (см ниже).
* Во входящем стеке операндов допустимо заменить тип, соответствующий <font face=Courier>MethodIntfName</font> и типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokeinterface(CP, Count, 0), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :-
    CP = imethod(MethodIntfName, MethodName, Descriptor),
    MethodName \= ' <init> ',
    MethodName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    currentClassLoader(Environment, L),
    reverse([class(MethodIntfName, L) | OperandArgList], StackArgList),
    canPop(StackFrame, StackArgList, TempFrame),
    validTypeTransition(Environment, [], ReturnType, TempFrame, NextStackFrame),
    countIsValid(Count, StackFrame, TempFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Операнд <font face=Courier>Count</font> инструкции ''invokeinterface'' является действительным, если он равен количеству аргументов инструкции. Количество аргументов равно разнице размеров <font face=Courier>InputFrame</font> и <font face=Courier>OutputFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
countIsValid(Count, InputFrame, OutputFrame) :-
    InputFrame = frame(_Locals1, OperandStack1, _Flags1),
    OutputFrame = frame(_Locals2, OperandStack2, _Flags2),
    length(OperandStack1, Length1),
    length(OperandStack2, Length2),
    Count =:= Length1 - Length2.
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokespecial'''''
| style="text-align:right;"  | '''''invokespecial'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokespecial'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:

* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего метод с именем <font face=Courier>MethodName</font> и дескриптором <font face=Courier>Descriptor</font>, который является членом класса с именем <font face=Courier>MethodClassName</font>.

Либо:

* <font face=Courier>MethodName</font> не является <font face=Courier><init></font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><clinit></font>.
* Во входящем стеке операндов допустимо заменить тип, соответствующий текущему классу и типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов. 
* Во входящем стеке операндов допустимо заменить тип, соответствующий  классу <font face=Courier>MethodClassName</font> и типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokespecial(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(MethodClassName, MethodName, Descriptor),
    MethodName \= ' <init> ',
    MethodName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    thisClass(Environment, CurrentClass),
    reverse([CurrentClass | OperandArgList], StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    currentClassLoader(Environment, L),
    reverse([class(MethodClassName, L) | OperandArgList], StackArgList2),
    validTypeTransition(Environment, StackArgList2, ReturnType,
                        StackFrame, _ResultStackFrame),
    isAssignable(class(CurrentClassName, L), class(MethodClassName, L)).
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Либо:

* <font face=Courier>MethodName</font>  является <font face=Courier><init></font>.
* В дескрипторе <font face=Courier>Descriptor</font> определен тип возвращаемого значения как <font face=Courier>void</font>.
* Во входящем стеке операндов допустимо считать типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> и неинициализированный тип <font face=Courier>UninitializedArg</font> и в результате считывания получить <font face=Courier>OperandStack</font>. 
* Исходящее состояние типов поличается их входящего заменой, во-первых, входящего стека операндов на <font face=Courier>OperandStack</font> и, во-вторых, заменой всех экземпляров  <font face=Courier>UninitializedArg</font>  на тип экземпляра, который инициализируется.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokespecial(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(MethodClassName, ' <init> ', Descriptor),
    parseMethodDescriptor(Descriptor, OperandArgList, void),
    reverse(OperandArgList, StackArgList),
    canPop(StackFrame, StackArgList, TempFrame),
    TempFrame = frame(Locals, FullOperandStack, Flags),
    FullOperandStack = [UninitializedArg | OperandStack],
    currentClassLoader(Environment, CurrentLoader),
    rewrittenUninitializedType(UninitializedArg, Environment,
                               class(MethodClassName, CurrentLoader), This),
    rewrittenInitializationFlags(UninitializedArg, Flags, NextFlags),
    substitute(UninitializedArg, This, OperandStack, NextOperandStack),
    substitute(UninitializedArg, This, Locals, NextLocals),
    NextStackFrame = frame(NextLocals, NextOperandStack, NextFlags),
    ExceptionStackFrame = frame(NextLocals, [], Flags),
    passesProtectedCheck(Environment, MethodClassName, ' <init> ',
    Descriptor, NextStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Специальное правило для ''invokespecial'' <font face=Courier><init></font> метода.

Это правило является единственной причиной для возврата явного исключения в стеке фреймов. Предположим что ''invokespecial'' может привести к вызову <font face=Courier><init></font> метода в классе предке и вызов закончиться аварийно, оставляя <font face=Courier>this</font> не инициализированным. Данная ситуация не может быть создана с использованием исходного кода на языке программирования Java, но может быть воссоздана  непосредственно с помощью байт-кода.

Исходный фрейм содержит неинициализированный объект в локальных переменных а также флаг <font face=Courier>uninitializedThis</font>. Нормальное завершение ''invokespecial'' инициализирует  неинициализированный объект и сбрасывает флаг <font face=Courier>uninitializedThis</font>. Но если вызов метода <font face=Courier><init></font> приводит к исключению, то неинициализированный объект может пребывать в частично инициализированном состоянии и требовать того, чтобы его обозначили как не готового к использованию. Это достигается тем, что в фрейм исключения содержит неверный объект (новое значение локальной переменной) и флаг <font face=Courier>uninitializedThis</font> (старый флаг). Поскольку нет возможности получить из частично инициализированного объекта, содержащего флаг <font face=Courier>uninitializedThis</font> полностью инициализированный объект, так что  объект помечается как не готовый к использованию. Для других случаев стековый фрейм исключения может быть таким же, как входящий стековый фрейм. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
rewrittenUninitializedType(uninitializedThis, Environment,
                           _MethodClass, This) :-
    thisClass(Environment, This).

rewrittenUninitializedType(uninitialized(Address), Environment,
                           MethodClass, MethodClass) :-
    allInstructions(Environment, Instructions),
    member(instruction(Address, new(MethodClass)), Instructions).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Вычисляем к какому типу тип неинициализированного аргумента должен быть приведён. Есть два случая:

Первый случай. Если мы инициализируем объект внутри конструктора, то его тип изначально равен <font face=Courier>uninitializedThis</font>. Он будет замене на тип класса, которому принадлежит метод  <font face=Courier><init></font>.

Второй случай. Мы инициализируем объект с помощью операции ''new''. Тогда  тип неинициализированного аргумента должен быть равным <font face=Courier>MethodClass</font> — типу, содержащему метод <font face=Courier><init></font>. Мы также проверяем действительно ли по адресу <font face=Courier>Address</font> находится инструкция ''new''.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
rewrittenInitializationFlags(uninitializedThis, _Flags, []).
rewrittenInitializationFlags(uninitialized(_), Flags, Flags).

substitute(_Old, _New, [], []).
	substitute(Old, New, [Old | FromRest], [New | ToRest]) :
    substitute(Old, New, FromRest, ToRest).
substitute(Old, New, [From1 | FromRest], [From1 | ToRest]) :-
    From1 \= Old,
    substitute(Old, New, FromRest, ToRest).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokestatic'''''
| style="text-align:right;"  | '''''invokestatic'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokestatic'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:

* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего метод с именем <font face=Courier>MethodName</font> и дескриптором <font face=Courier>Descriptor</font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><init></font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><clinit></font>.
* Во входящем стеке операндов допустимо заменить типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokestatic(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(_MethodClassName, MethodName, Descriptor),
    MethodName \= ' <init> ',
    MethodName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    reverse(OperandArgList, StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokevirtual'''''
| style="text-align:right;"  | '''''invokevirtual'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokevirtual'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:

* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего метод с именем <font face=Courier>MethodName</font> и дескриптором <font face=Courier>Descriptor</font>, причем метод принадлежит классу <font face=Courier>MethodClassName</font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><init></font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><clinit></font>.
* Во входящем стеке операндов допустимо заменить тип, соответствующий <font face=Courier>MethodClassName</font> и типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов.
* Если метод является <font face=Courier>protected</font>  использование согласуется с правилами, описывающими доступ к членам данным с модификатором <font face=Courier>protected</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokevirtual(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(MethodClassName, MethodName, Descriptor),
    MethodName \= ' <init> ',
    MethodName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    reverse(OperandArgList, ArgList),
    currentClassLoader(Environment, L),
    reverse([class(MethodClassName, L) | OperandArgList], StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    canPop(StackFrame, ArgList, PoppedFrame),
    passesProtectedCheck(Environment, MethodClassName, MethodName,
    Descriptor, PoppedFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ior'''''
| style="text-align:right;"  | '''''ior'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ior'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ior, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''irem'''''
| style="text-align:right;"  | '''''irem'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''irem'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(irem, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ireturn'''''
| style="text-align:right;"  | '''''ireturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ireturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>int</font>  и допустимо считать тип соответствующий <font face=Courier>int</font> из входящего стека операндов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ireturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, int),
    canPop(StackFrame, [int], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ishl'''''
| style="text-align:right;"  | '''''ishl'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ishl'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ishl, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ishr'''''
| style="text-align:right;"  | '''''ishr'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ishr'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ishr, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''istore'''''
| style="text-align:right;"  | '''''istore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''istore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>int</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(istore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''istore_<n>'''''
| style="text-align:right;"  | '''''istore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''istore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''istore'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(istore_0, istore(0)).
instructionHasEquivalentTypeRule(istore_1, istore(1)).
instructionHasEquivalentTypeRule(istore_2, istore(2)).
instructionHasEquivalentTypeRule(istore_3, istore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''isub'''''
| style="text-align:right;"  | '''''isub'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''isub'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(isub, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iushr'''''
| style="text-align:right;"  | '''''iushr'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iushr'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(iushr, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ixor'''''
| style="text-align:right;"  | '''''ixor'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ixor'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ixor, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2d'''''
| style="text-align:right;"  | '''''l2d'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''l2d''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>long</font>, затем записать туда  <font face=Courier>double</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(l2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2f'''''
| style="text-align:right;"  | '''''l2f'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''l2f''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>long</font>, затем записать туда  <font face=Courier>float</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(l2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2i'''''
| style="text-align:right;"  | '''''l2i'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''l2i''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>long</font>, затем записать туда  <font face=Courier>float</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(l2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ladd'''''
| style="text-align:right;"  | '''''ladd'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ladd'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>long</font> и <font face=Courier>long</font>, на <font face=Courier>long</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ladd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long, long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''laload'''''
| style="text-align:right;"  | '''''laload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''laload'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>long</font>, на <font face=Courier>long</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(laload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(long)], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''land'''''
| style="text-align:right;"  | '''''land'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''land'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(land, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lastore'''''
| style="text-align:right;"  | '''''lastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>long</font>, <font face=Courier>int</font> и массиву типов <font face=Courier>long</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [long, int, arrayOf(long)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lcmp'''''
| style="text-align:right;"  | '''''lcmp'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lcmp'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>long</font> и <font face=Courier>long</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lcmp, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long, long], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lconst_<l>'''''
| style="text-align:right;"  | '''''lconst_<l>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lconst_0''  безопасна по типу тогда и только тогда, когда допустимо записать во входящий стек операндов тип, соответствующий <font face=Courier>long</font>,  и после записи получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lconst_1'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''lconst_0'' также безопасна.

|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lconst_1, lconst_0).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc'''''
| style="text-align:right;"  | '''''ldc'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ldc''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего элемент <font face=Courier>Type</font>, где <font face=Courier>Type</font> это либо <font face=Courier>int</font>, <font face=Courier>float</font>, <font face=Courier>String</font>, <font face=Courier>Class</font>, <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font>, либо <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font> и допустимо записать во входящий стек операндов на тип <font face=Courier>Type</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ldc(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    functor(CP, Tag, _),
    isBootstrapLoader(BL),
    member([Tag, Type], [
       [int, int],
       [float, float],
       [string, class('java/lang/String', BL)],
       [classConst, class('java/lang/Class', BL)],
       [methodTypeConst, class('java/lang/invoke/MethodType', BL)],
       [methodHandleConst, class('java/lang/invoke/MethodHandle', BL)],
    ]),
    validTypeTransition(Environment, [], Type, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc_w'''''
| style="text-align:right;"  | '''''ldc_w'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ldc_w'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ldc'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ldc_w(CP), ldc(CP)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc2_w'''''
| style="text-align:right;"  | '''''ldc2_w'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ldc2_w''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего элемент <font face=Courier>Tag</font>, где <font face=Courier>Tag</font> это либо <font face=Courier>long</font> либо <font face=Courier>double</font> и допустимо записать во входящий стек операндов на тип <font face=Courier>Tag</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ldc2_w(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    functor(CP, Tag, _),
    member(Tag, [long, double]),
    validTypeTransition(Environment, [], Tag, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldiv'''''
| style="text-align:right;"  | '''''ldiv'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ldiv'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ldiv, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lload'''''
| style="text-align:right;"  | '''''lload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>long</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    loadIsTypeSafe(Environment, Index, long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lload_<n>'''''
| style="text-align:right;"  | '''''lload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''lload_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''lload'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lload_0, lload(0)).
instructionHasEquivalentTypeRule(lload_1, lload(1)).
instructionHasEquivalentTypeRule(lload_2, lload(2)).
instructionHasEquivalentTypeRule(lload_3, lload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lmul'''''
| style="text-align:right;"  | '''''lmul'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lmul'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lmul, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lneg'''''
| style="text-align:right;"  | '''''lneg'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lneg'' безопасна по типу тогда и только тогда, когда во входящем стеке операндов находится тип, соответствующий <font face=Courier>long</font>. Инструкция ''lneg'' не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lookupswitch'''''
| style="text-align:right;"  | '''''lookupswitch'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lookupswitch'' безопасна по типу, если её ключи отсортированы, а также допустимо считать <font face=Courier>int</font> из входящего стека операндов, получая при этом новое состояние типов <font face=Courier>BranchStackFrame</font> и все целевые точки переходов инструкций являются действительными точками переходов в предположении, что <font face=Courier>BranchStackFrame</font> их входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lookupswitch(Targets, Keys), Environment, _, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    sort(Keys, Keys),
    canPop(StackFrame, [int], BranchStackFrame),
    checklist(targetIsTypeSafe(Environment, BranchStackFrame), Targets),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lor'''''
| style="text-align:right;"  | '''''lor'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lor'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lor, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lrem'''''
| style="text-align:right;"  | '''''lrem'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lrem'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lrem, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lreturn'''''
| style="text-align:right;"  | '''''lreturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lreturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>long</font>  и допустимо считать тип соответствующий <font face=Courier>long</font> из входящего стека операндов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lreturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, long),
    canPop(StackFrame, [long], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lshl'''''
| style="text-align:right;"  | '''''lshl'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lshl''  безопасна по типу тогда и только тогда, когда допустимо заменить  во входящем стеке операндов типы, соответствующие <font face=Courier>int</font> и <font face=Courier>long</font>  на <font face=Courier>long</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lshl, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lshr'''''
| style="text-align:right;"  | '''''lshr'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lshr'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''lshl'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lshr, lshl).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lstore'''''
| style="text-align:right;"  | '''''lstore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lstore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>long</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lstore_<n>'''''
| style="text-align:right;"  | '''''lstore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''lstore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''lstore'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lstore_0, lstore(0)).
instructionHasEquivalentTypeRule(lstore_1, lstore(1)).
instructionHasEquivalentTypeRule(lstore_2, lstore(2)).
instructionHasEquivalentTypeRule(lstore_3, lstore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lsub'''''
| style="text-align:right;"  | '''''lsub'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lsub'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lsub, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lushr'''''
| style="text-align:right;"  | '''''lushr'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lushr'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''lshl'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lushr, lshl).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lxor'''''
| style="text-align:right;"  | '''''lxor'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lxor'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lxor, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''monitorenter'''''
| style="text-align:right;"  | '''''monitorenter'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''monitorenter''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>reference</font> и  после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(monitorenter, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [reference], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''monitorexit'''''
| style="text-align:right;"  | '''''monitorexit'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''monitorexit'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''monitorenter'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(monitorexit, monitorenter).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''multianewarray'''''
| style="text-align:right;"  | '''''multianewarray'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''multianewarray''  с операндами <font face=Courier>CP</font>  и <font face=Courier>Dim</font> безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего массив, чья размерность больше либо равна  <font face=Courier>Dim</font>,  <font face=Courier>Dim</font> строго больше нуля,  и допустимо заменить во входящем стеке операндов  типы <font face=Courier>Dim</font> <font face=Courier>int</font> на тип обозначенный <font face=Courier>CP</font> и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(multianewarray(CP, Dim), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :-
    CP = arrayOf(_),
    classDimension(CP, Dimension),
    Dimension >= Dim,
    Dim > 0,
    /* Make a list of Dim ints */
    findall(int, between(1, Dim, _), IntList),
    validTypeTransition(Environment, IntList, CP, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Размерность массива, чью компоненты также являются массивами, на один больше чем размерность самих компонентов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
classDimension(arrayOf(X), Dimension) :-
    classDimension(X, Dimension1),
    Dimension is Dimension1 + 1.

classDimension(_, Dimension) :-
    Dimension = 0.
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''new'''''
| style="text-align:right;"  | '''''new'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''new''  с операндом <font face=Courier>CP</font>  и смещением  <font face=Courier>Offset</font> безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего класс, тип  <font face=Courier>uninitialized</font>(<font face=Courier>Offset</font>) не появляется во входящем стеке операндов  и допустимо записать <font face=Courier>uninitialized</font>(<font face=Courier>Offset</font>) во входящий стек операндов и заменить  <font face=Courier>uninitialized</font>(<font face=Courier>Offset</font>) на  <font face=Courier>top</font> во входящих локальных переменных  и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(new(CP), Environment, Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, OperandStack, Flags),
    CP = class(_, _),
    NewItem = uninitialized(Offset),
    notMember(NewItem, OperandStack),
    substitute(NewItem, top, Locals, NewLocals),
    validTypeTransition(Environment, [], NewItem,
                        frame(NewLocals, OperandStack, Flags),
                        NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''newarray'''''
| style="text-align:right;"  | '''''newarray'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''newarray''  с операндом <font face=Courier>TypeCode</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>TypeCode</font> соответствует элементарному типу <font face=Courier>ElementType</font> и допустимо заменить тип <font face=Courier>int</font> во входящем стеке операндов на «массив  <font face=Courier>ElementType</font>»  и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
nstructionIsTypeSafe(newarray(TypeCode), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    primitiveArrayInfo(TypeCode, _TypeChar, ElementType, _VerifierType),
    validTypeTransition(Environment, [int], arrayOf(ElementType),
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Соответствие между кодом типа и самим примитивным типом определено следующими предикатами:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
primitiveArrayInfo(4,  0'Z, boolean, int).
PrimitiveArrayInfo(5,  0'C, char,    int).
PrimitiveArrayInfo(6,  0'F, float,   float).
PrimitiveArrayInfo(7,  0'D, double,  double).
PrimitiveArrayInfo(8,  0'B, byte,    int).
PrimitiveArrayInfo(9,  0'S, short,   int).
primitiveArrayInfo(10, 0'I, int,     int).
primitiveArrayInfo(11, 0'J, long,    long).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''nop'''''
| style="text-align:right;"  | '''''nop'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''nop'' всегда безопасна по типу. Инструкция ''nop'' не влияет на состояние типов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(nop, _Environment, _Offset, StackFrame,
                      StackFrame, ExceptionStackFrame) :-
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''pop'''''
| style="text-align:right;"  | '''''pop'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop''   безопасна по типу тогда и только тогда, когда допустимо считать тип категории 1 из входящего стека операндов и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(pop, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, [Type | Rest], Flags),
    Type \= top,
    sizeOf(Type, 1),
    NextStackFrame = frame(Locals, Rest, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''pop2'''''
| style="text-align:right;"  | '''''pop2'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop2''  безопасна по типу тогда и только тогда, когда она является безопасной по типу формой инструкции ''pop2''.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(pop2, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop2''  является  ''безопасной по типу формой инструкции'' pop2, когда она представляет собой безопасную по типу форму 1 инструкции  ''pop2'' либо  безопасную по типу форму 2 инструкции  ''pop2''.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack) :-
    pop2Form1IsTypeSafe(InputOperandStack, OutputOperandStack).

pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack) :-
    pop2Form2IsTypeSafe(InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop2''  является  ''безопасной по типу формой 1 инструкции'' pop2 тогда и только тогда, когда допустимо считать из входящего стека операндов два типа размера 1 и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
pop2Form1IsTypeSafe([Type1, Type2 | Rest], Rest) :-
    sizeOf(Type1, 1),
    sizeOf(Type2, 1).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop2''  является  ''безопасной по типу формой 2 инструкции'' pop2 тогда и только тогда, когда допустимо считать из входящего стека операндов  тип размера 2 и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
pop2Form2IsTypeSafe([top, Type | Rest], Rest) :- sizeOf(Type, 2).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''putfield'''''
| style="text-align:right;"  | '''''putfield'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''putfield''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего поле, чей объявленный тип это <font face=Courier>FieldType</font>, причём поле находится в классе <font face=Courier>FieldClass</font> и допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>FieldType</font> и <font face=Courier>FieldClass</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(putfield(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = field(FieldClass, FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    canPop(StackFrame, [FieldType], PoppedFrame),
    passesProtectedCheck(Environment, FieldClass, FieldName,
                         FieldDescriptor, PoppedFrame),
    currentClassLoader(Environment, CurrentLoader),
    canPop(StackFrame, [FieldType, class(FieldClass, CurrentLoader)],
           NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''putstatic'''''
| style="text-align:right;"  | '''''putstatic'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''putstatic''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего поле, чей объявленный тип это <font face=Courier>FieldType</font>, и допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>FieldType</font> и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(putstatic(CP), _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = field(_FieldClass, _FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    canPop(StackFrame, [FieldType], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''return'''''
| style="text-align:right;"  | '''''return'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''return''  безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>void</font> и вдобавок либо:


* метод, в котором находится инструкция не является <font face=Courier><init></font> методом либо
* <font face=Courier>this</font> полностью инициализирована в той точке кода, где помещена инструкция.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(return, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, void),
    StackFrame = frame(_Locals, _OperandStack, Flags),
    notMember(flagThisUninit, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''saload'''''
| style="text-align:right;"  | '''''saload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''saload'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>short</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(saload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(short)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''sastore'''''
| style="text-align:right;"  | '''''sastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''sastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font>, <font face=Courier>int</font> и массиву типов <font face=Courier>short</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(sastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int, int, arrayOf(short)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''sipush'''''
| style="text-align:right;"  | '''''sipush'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''sipush''  безопасна по типу тогда и только тогда, когда допустимо записать тип <font face=Courier>int</font> во входящий стек операндов и после записи получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(sipush(_Value), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''swap'''''
| style="text-align:right;"  | '''''swap'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''swap''  безопасна по типу тогда и только тогда, когда допустимо заменить два типа категории 1 <font face=Courier>Type1</font> и <font face=Courier>Type2</font> на типы <font face=Courier>Type2</font> и <font face=Courier>Type1</font> во входящем стеке операндов и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(swap, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(_Locals, [Type1, Type2 | Rest], _Flags),
    sizeOf(Type1, 1),
    sizeOf(Type2, 1),
    NextStackFrame = frame(_Locals, [Type2, Type1 | Rest], _Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''tableswitch'''''
| style="text-align:right;"  | '''''tableswitch'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''tableswitch'' безопасна по типу, если её ключи отсортированы, а также допустимо считать <font face=Courier>int</font> из входящего стека операндов, получая при этом новое состояние типов <font face=Courier>BranchStackFrame</font> и все целевые точки переходов инструкций являются действительными точками переходов в предположении, что <font face=Courier>BranchStackFrame</font> их входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(tableswitch(Targets, Keys), Environment, _Offset,
                      StackFrame, afterGoto, ExceptionStackFrame) :-
    sort(Keys, Keys),
    canPop(StackFrame, [int], BranchStackFrame),
    checklist(targetIsTypeSafe(Environment, BranchStackFrame), Targets),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''wide'''''
| style="text-align:right;"  | '''''wide'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''wide'' подчинена тем же самым правилам, что и инструкция, которую она расширяет.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(wide(WidenedInstruction),
                                 WidenedInstruction).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Состояние типов после того, как инструкция завершиться аварийно такое же как и входящее состояние типов, за исключением того, что стек операндов пуст.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
exceptionStackFrame(StackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, _OperandStack, Flags),
    ExceptionStackFrame = frame(Locals, [], Flags).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Большинство правил для типов в данной спецификации зависят от понимания корректного преобразования типов.

Преобразование типов является корректным, если допустимо считать список ожидаемых типов из входящего состояния типов стека операндов и заменить их на ожидаемые типы и при этом получить новое корректное состояние типов. В частности размер стека операндов в новом состоянии типов не должен превышать объявленный максимально допустимый размер.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
validTypeTransition(Environment, ExpectedTypesOnStack, ResultType,
                    frame(Locals, InputOperandStack, Flags),
                    frame(Locals, NextOperandStack, Flags)) :-
    popMatchingList(InputOperandStack, ExpectedTypesOnStack, InterimOperandStack),
    pushOperandStack(InterimOperandStack, ResultType, NextOperandStack),
    operandStackHasLegalLength(Environment, NextOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Доступ к I-тому элементу стека операндов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
nth1OperandStackIs(I, frame(_Locals, OperandStack, _Flags), Element) :-
    nth1(I, OperandStack, Element).
</syntaxhighlight>
|}
<br>

<br><br><br><br>
==== Проверка по  типам интерфейса ====

<font face=Courier>class</font>-файл, который не содержит атрибута <font face=Courier>StackMapTable</font> (который в этом случае имеет номер версии 49.0 или ниже) должен быть проверен с использованием типов интерфейсов.

<br><br><br><br>
===== Процесс проверки по типам интерфейса =====

Во время сборки верификатор проверяет массив <font face=Courier>code</font> аттрибута <font face=Courier>Code</font> для каждого метода <font face=Courier>class</font>-файла с помощью выполнения анализа потока данных для каждого метода. Верификатор гарантирует, что в любой данной точке программы, не важно каким способом мы достигли этой точки, справедливо следующее:

* Стек операндов всегда одного и того же размера и содержит одни и те же типы значений.
* К локальной переменной не будет предоставлен доступ до тех пор пока не известно, что она содержит значение соответствующего типа.
* Методы вызываются с соответствующими аргументами.
* Полям присваиваются значения только соответствующих типов.
* Все коды операций имеют аргументы соответствующих типов в стеке операндов и в массиве локальных переменных.
* Не существует неинициализированного экземпляра класса в локальных переменных в коде, защищённым обработчиком исключений. Однако неинициализированный экземпляр класса может находится в стеке операндов в коде, защищённым обработчиком исключений. Когда выбрасывается исключение, то содержимое стека операндов игнорируется.

Из соображений эффективности, некоторые проверки, которые в принципе могли бы быть выполнены верификатором, откладываются до момента первого вызова кода метода. Поступая таким образом верификатор избегает преждевременной загрузки  <font face=Courier>class</font>-файлов, откладывая её до тех пор пока она действительно не будет нужна.

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Пример. Если метод вызывает другой метод, который возвращает экземпляр класса <font face=Courier>A</font> и этот экземпляр присваивается только полю того же типа, то верификатор не выполняет проверку, а действительно ли класс <font face=Courier>A</font>  существует. Однако, если экземпляр присваивается полю типа <font face=Courier>B</font>, то определения обоих классов <font face=Courier>A</font> и <font face=Courier>B</font> должны быть загружены для того, чтобы удостовериться, что <font face=Courier>A</font> является наследником <font face=Courier>B</font>.</span> 
|}
<br>

<br><br><br><br>
===== Верификатор байткода ===== 

Код каждого метода проверяется независимо. Во-первых, байты, которые содержаться в методе, разбиваются на последовательности инструкций и индекс начала каждой инструкции в массиве <font face=Courier>code</font> помещается в отдельный массив. Затем верификатор проходит по коду второй раз и производит синтаксический разбор инструкций. Во время этого прохода строится структура данных, которая содержит информацию о каждой инструкции виртуальной машины Java, находящейся в методе. Операнды инструкции, если таковые присутствуют, также проверяются на то, что они являются допустимыми. Например:

* Ветви перехода должны быть в границах массива <font face=Courier>code</font> для данного метода. 
* Целевые точки всех инструкций передачи управления являются началом других инструкций. В случае инструкции ''wide''  сам код инструкции ''wide'' считается началом инструкции, а код той инструкции, которую расширяет ''wide''. Переходы не на начало инструкции запрещены.
* Для инструкций не допустимо получать доступ или изменять локальные переменные, чей индекс больше или равен количеству локальных переменных, содержащихся в методе.
* Ссылка на константный пул должна быть элементом соответствующего типа. (Например, инструкция ''getfield'' должна ссылаться на поле.)
* Код не заканчивается на незавершённой инструкции (без нужных аргументов и так далее.)
* Процесс выполнения не может перейти за пределы конца кода.
* Для каждого обработчика исключения начальная и конечная точка кода, который защищает обработчик, должна быть началом инструкции либо, в случае конечной точки, быть непосредственно после кода инструкции. Начальная точка должна быть перед конечной. Код обработчика исключения должен начинаться с корректной инструкции и не должен начинаться с кода инструкции, которая расширяется предшествующей инструкцией ''wide''.

Для каждой инструкции метода перед её выполнением верификатор записывает содержимое стека операндов и содержимое массива локальных переменных. Для стека операндов необходимо знать размер стека и тип каждого элемента в стеке. Для каждой локальной переменной необходимо знать либо тип содержимого локальной переменной либо знать что её содержимое не используется или имеет неопределённое (не инициализированное) значение. Верификатор байт-кода не обязан делать отличий между объединёнными типами (например <font face=Courier>byte</font>, <font face=Courier>short</font>, <font face=Courier>char</font>) во время определения типов в стеке операндов. 
 
Затем инициализируется анализатор потоков данных. Для первой инструкции метода локальные переменные, представляющие собой параметры содержать значения для типов, обозначенных в дескрипторе типов метода; стек операндов пуст. Все остальные локальные переменные содержат недопустимые (не инициализированные — ''прим. перев.'') значения. Для всех остальных инструкций, которые до сих пор ещё не были рассмотрены, информация относительно стека операндов или локальных переменных отсутствует.

Затем запускается анализатор потоков данных. Для каждой инструкции бит  «изменённого состояния» сообщает нужно ли рассматривать данную инструкцию. Изначально бит  «изменённого состояния» установлен только для первой инструкции. Анализатор потока данных выполняет следующий цикл:

# Выбрать инструкцию виртуальной машины Java, чей бит  «изменённого состояния» установлен. Если нет ни одной инструкции  чей бит «изменённого состояния» установлен, то проверка метода успешно завершена. В противном случае сбросить бит  «изменённого состояния» у выбранной инструкции.
# Провести моделирование запуска инструкции на стеке операндов и массиве локальных переменных, выполнив для этого следующие:
#* Если инструкция использует значения из стека операндов, то убедится что на вершине стека операндов достаточное количество значений и они соответствующего типа. В противном случае завершить проверку аварийно.
#* Если инструкция использует локальную переменную, то убедиться что локальная переменная содержит значение соответствующего типа. В противном случае завершить проверку аварийно.
#* Если инструкция записывает значение в стек операндов то, убедиться в стеке операндов достаточно места для записи новых значений. Добавить обозначенные типы к вершине моделируемого стека операндов.
#* Если инструкция изменяет локальную переменную, то записать что теперь локальная переменная содержит новый тип данных.
# Определить инструкции, которые должны выполняться после текущей инструкции. Допустимые могут быть такие инструкции:
#* Следующая инструкция, если текущая инструкция не является инструкцией безусловного перехода (например, ''goto'', ''return'', либо ''athrow''). Проверка завершается аварийно, если возможно «вывалится» за последнюю инструкцию метода.
#* Целевые точки перехода условного или безусловного ветвления или переключения.
#* Любой обработчик исключения для данной инструкции.
# Объединить состояние стека операндов и массива локальных переменных в конце выполнения текущей инструкции для использования последующими инструкциями. В специальном случае передачи управления обработчику исключения в стек операндов записывается один объект с типом исключения, который задан в обработчике исключения. Должно быть достаточно место в стеке операндов для записи этого одного значения.
#* Если следующая инструкция в последовательности была рассмотрена впервые, то записать, что стек операндов и значения локальных переменных, вычисленные в шагах 2 и 3, являются предшествующими стеком операндов и локальными переменными. Установить   бит  «изменённого состояния» у следующей инструкции.
#* Если следующая инструкция в последовательности уже была рассмотрена ранее, то объединить состояние стека операндов и массива локальных переменных, вычисленные в шагах 2 и 3 со значениями, которые там уже есть.  Установить   бит  «изменённого состояния» у следующей инструкции, если были какие-либо изменения значений.
# Перейти к шагу 1.

Для объединения двух стеков операндов количество значений в каждом из них должно быть одинаково. Типы значений в стеках также должны быть одинаковыми, за исключением того для типа <font face=Courier>reference</font> могут присутствовать для разных по типу значения на соответствующих местах в двух стеках. В этом случае стек операндов после объединения содержит содержит ссылку  <font face=Courier>reference</font> на первого общего предка этих двух типов. Такой предок (и, следовательно, ссылка <font face=Courier>reference</font>) всегда существует тип <font face=Courier>Object</font> является предком для всех классов и интерфейсных типов. Если стеки операндов невозможно объединить, то проверка метода завершается аварийно.

Для объединения двух массивов локальных переменных сравниваются соответствующие пары локальных переменных. Если два типа не являются идентичными (за исключением типов <font face=Courier>reference</font>), то верификатор записывает, что локальная переменная содержит неиспользуемое значение.  Если обе  локальные переменные содержат значения типа <font face=Courier>reference</font>, то объединённое состояние содержит ссылку <font face=Courier>reference</font> на первого общего предка двух данных типов. 

Если анализатор потоков данных прошёл по методу без сообщений об ошибках, то считается то метод успешно проверен <font face=Courier>class</font>-файл верификатором.

Некоторые инструкции и типы данных усложняют работу анализатора потоков данных. Мы рассмотрим каждую из них более детально.

<br><br><br><br>
===== Значения с типами <font face=Courier>long</font> и <font face=Courier>double</font> =====

Значения с типами <font face=Courier>long</font> и <font face=Courier>double</font> обрабатываются по особенному в процессе проверки.

Во всех случаях, когда значение типа  <font face=Courier>long</font> или <font face=Courier>double</font> записывается в локальную переменную с индексом n, индекс n+1 специально помечается, что он зарезервирован для значения по индексу n и более не должен использоваться как индекс локальной переменной. Любое значение, которое хранилось в локальной переменной с индексом n+1, перестаёт быть доступным для использования.

Во всех случаях, когда значение  записывается в локальную переменную с индексом n, индекс  n-1 проверяется на предмет того, не является ли он второй частью переменной типа  <font face=Courier>long</font> или <font face=Courier>double</font>. Если это так, то локальная переменная с индексом n-1 меняется так, чтобы показать, что она содержит значение, не доступное для использования. Поскольку локальная переменная с индексом n была перезаписана, то локальная переменная с индексом n-1 более не может представлять значение типа  <font face=Courier>long</font> или <font face=Courier>double</font>.

Работа со значениями типа <font face=Courier>long</font> или <font face=Courier>double</font> в стеке операндов проще; Верификатор работает с ними как с единичными значениями в стеке. Например, код для проверки инструкции ''dadd'' (сложить два значения типа <font face=Courier>double</font>) проверяет, что верхние два элемента в стеке оба имеют тип <font face=Courier>double</font>. При вычислении размера стека операндов, значения с типами  <font face=Courier>long</font> и <font face=Courier>double</font> имеют размер равный двум.

Инструкции, не привязанные типу и манипулирующие стеком операндов, должны работать с типами <font face=Courier>long</font> и <font face=Courier>double</font> как атомарными (и делать это прозрачно). Например, верификатор сообщает об ошибке, если на вершине стека находится значение типа <font face=Courier>double</font> и верификатор встречает инструкцию ''pop'' или ''dup'' для работы со стеком. Инструкции ''pop2'' или ''dup2'' должны быть использованы в этом случае.

<br><br><br><br>
===== Методы, инициализирующие экземпляр, и только что созданные объекты =====

Сознание нового экземпляра класса — это многошаговый процесс. Этот оператор:

<br>
<syntaxhighlight lang="java">
...
new myClass(i, j, k);
...
</syntaxhighlight>
<br>

может быть реализован следующим образом:

<br>
 ...
 ''new'' #1           // Выделить неинициализированную 
                  // память для объекта myClass
 ''dup''              // Сделать дубликат объекта в стеке операндов
 ''iload_1''          // Записать в стек i
 ''iload_2''          // Записать в стек j 
 ''iload_3''          // Записать в стек k
 ''invokespecial'' #5 // Вызвать myClass.<init>
 ...
<br>

Эта последовательность инструкций помещает на вершину стека операндов только что созданный объект. (Дополнительные примеры компилирования набора инструкций виртуальной машины Java даны в главе 3, «Компиляция в код виртуальной машины Java»)

Инициализирующий метод экземпляра (см. §2.9) класса <font face=Courier>myClass</font> видит новый неинициализированный объект как аргумент <font face=Courier>this</font> в локальной переменной с индексом 0. Единственная операция, которую метод может выполнить перед тем как он вызывает другой инициализирующий метод экземпляра для  <font face=Courier>myClass</font> или его непосредственного предка это присвоение значений полям, объявленным в <font face=Courier>myClass</font>.

При выполнения анализа потока данных в методах, принадлежащих экземпляру, верификатор инициализирует локальную переменную с индексом 0 так, чтобы она содержала экземпляр текущего класса, либо, в случае инициализирующего метода экземпляра,  локальная переменная с индексом 0 содержит специальный тип, сообщающий о том, что объект ещё не инициализирован. После того как был вызван соответствующий метод инициализации экземпляра (из текущего класса или класса предка) для данного объекта, все вхождения специального типа в модели верификатора в стеке операндов и массиве локальных переменных заменяются на текущий класс. Верификатор отклоняет код, который использует новый объект прежде, чем он был инициализирован либо инициализирует объект несколько раз. В дополнение он гарантирует, что каждый нормальный возврат из метода вызвал инициализирующий метод экземпляра либо в классе, которому принадлежит метод либо в непосредственном предке.

Аналогично, специальный тип создаётся и записывается в стек операндов модели верификатора как результат выполнения инструкции ''new'' виртуальной машины Java. Специальный тип указывает на инструкцию, с помощью которой был создан экземпляр класса, и тип неинициализированного экземпляра класса. Когда вызывается инициализирующий метод экземпляра, объявленный в ещё не инициализированном экземпляре, то все вхождения специального типа заменяются на инициализированный экземпляр класса. Это изменение в типе может повлечь за собой изменения в типах и в других инструкциях при последующем анализе потока данных.

Номер инструкции необходимо хранить как часть специального типа, так как могут быть множество пока ещё не инициализированных экземпляров классов в стеке операндов в одно и тоже время. Например, последовательность инструкций виртуальной машины Java, которые реализуют код

<br>
<syntaxhighlight lang="java">
new InputStream(new Foo(), new InputStream("foo"))
</syntaxhighlight>
<br>

могут в одно и тоже время иметь два не инициализированных экземпляра <font face=Courier>InputStream</font> в стеке операндов. Когда в экземпляре класса вызывается инициализирующий метод, то заменяются только те вхождения специального типа в стеке операндов и в массиве локальных переменных, которые являются такими же объектами что и экземпляр класса.

Если специальный тип неинициализированного объекта объединён со специальным типом, отличным от себя самого, то допустимая последовательность инструкций не должна иметь не инициализированных объектов в стеке операндов или локальных переменных при возвратной ветви программы  либо в коде, защищённым обработчиком исключения или блоком <font face=Courier>finally</font>. В противном случае  не благонадёжный кусок кода может «обмануть» верификатор и заставить его думать,  что верификатор произвёл инициализацию экземпляра класса, когда и должен был это сделать, хотя на самом деле инициализированный экземпляр класса был создан в предыдущем проходе цикла.

<br><br><br><br>
===== Исключения и блок <font face=Courier>finally</font> =====

Для реализации конструкции <font face=Courier>try</font>-<font face=Courier>finally</font>, компилятор языка программирования Java с версией 50.0 либо ниже может использовать средства реализации исключений совместно с двумя специальными инструкциями ''jsr'' («переход к подпрограмме») и ''ret'' («возврат из подпрограммы»). Блок  <font face=Courier>finally</font> компилируется в подпрограмму в рамках кода метода виртуальной машины Java, способом похожим на тот, который используется при компиляции кода для обработчика исключения. Когда инструкция ''jsr'', вызывающая подпрограмму, выполняется, она записывает в стек операндов адрес возврата    - адрес инструкции сразу после ''jsr'', в качестве значения с типом <font face=Courier>returnAddress</font>. Код подпрограммы хранит адрес возврата в локальной переменной. В конце выполнения подпрограммы инструкция ''ret'' считывает адрес возврата из локальной переменной и передаёт управление инструкции, находящейся по адресу возврата.

Передача управления блоку <font face=Courier>finally</font> (то есть вызов подпрограммы для <font face=Courier>finally</font>) может быть осуществлён несколькими способами. Если блок <font face=Courier>try</font> завершается успешно, подпрограмма  блока <font face=Courier>finally</font> вызывается с помощью инструкции ''jsr'' прежде вычисления следующего выражения. Операторы <font face=Courier>break</font> или <font face=Courier>continue</font> внутри блока <font face=Courier>try</font>, ссылающиеся на инструкцию вне блока  <font face=Courier>try</font>, выполняют инструкцию ''jsr'' для перехода к коду блока <font face=Courier>finally</font>. Если блок  <font face=Courier>try</font> выполняет ''return'', то скомпилированный код выполняет следующее:

# Сохраняет возвращаемое значение (если таковое имеется) в локальной переменной.
# Выполняет инструкцию ''jsr'' для перехода к коду блока  <font face=Courier>finally</font>.
# После возврата из блока  <font face=Courier>finally</font>, возвращает значение, сохранённое в локальной переменой.

Компилятор устанавливает специальный обработчик исключений, который перехватывает любые исключения в блоке  <font face=Courier>try</font>. Если выброшено исключение в блоке <font face=Courier>try</font>, этот обработчик исключений выполняет следующее:

# Сохраняет исключение в локальной переменной.
# Выполняет инструкцию ''jsr'' для перехода к коду блока  <font face=Courier>finally</font>.
# После возврата из блока  <font face=Courier>finally</font>, повторно выбрасывает это исключение.

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Более подробную информацию по реализации конструкции <font face=Courier>try</font>-<font face=Courier>finally</font> см. §3.13.</span>
|}
<br>

Код блока <font face=Courier>finally</font> представляет собой отдельную проблему для верификатора. Обычно, если к какой-нибудь инструкции можно перейти несколькими путями и при этом некоторая локальная переменная содержит несовместимые значения из-за использования разных путей переход, то локальная переменная становится неиспользуемой. Тем не менее блок <font face=Courier>finally</font> может быть вызван из нескольких разных мест, что приводит к различным особенностям. 

* Вызов из обработчика исключений может привести к тому, что определённая локальная переменная будет содержать исключение.
* Вызов для реализации ''return'' может привести к тому, что определённая локальная переменная будет содержать возвращаемое значение.
* Вызов при завершении блока <font face=Courier>try</font>  может привести к тому, что некоторая локальная переменная будет содержать неопределённое значение.

Сам по себе код блока <font face=Courier>finally</font> может пройти проверку успешно, но после завершения обновления всех последующих элементов инструкции ''ret'', верификатор может заметить, что локальная переменная, в которой обработчик исключения ожидает обнаружить исключение, либо в которой код возврата ожидает обнаружить  возвращаемое значение,  на самом деле содержит неопределённое значение.

Проверка кода, содержащего блок <font face=Courier>finally</font> сложна. Основная идея в следующем:

* Каждая инструкция содержит список точек перехода ''jsr'' которые нужны, чтобы перейти к данной инструкции. Для большинства случаев этот список пуст. Для инструкций внутри блока <font face=Courier>finally</font> его размер равен одному. Для вложенных блоков <font face=Courier>finally</font> (очень редкая ситуация!) его размер может быть более чем один.
* Для каждой инструкции а каждого перехода ''jsr'' хранится битовый вектор, показывающий была ли модифицирована либо выбрана из памяти локальная переменная, соответствующая индексу вектора после выполнения ''jsr''. 
* При выполнении инструкции ''ret'', которая реализует возврат из подпрограммы, должна быть только одна возможная подпрограмма, откуда, собственно, возврат и осуществляется. Две разные подпрограммы не могут «слить воедино» сове выполнение и завершить его одной и той же инструкцией ''ret''.
* Используется специальная процедура для выполнения анализа потока данных инструкции ''ret''. Так как верификатор знает подпрограмму, из которой инструкция должна выполнить возврат, он может найти все инструкции ''jsr'', которые вызывают подпрограмму и объединить состояние стека операндов и массива локальных переменных во время выполнения инструкции  ''ret'' со стеком операндов и массивом локальных переменных инструкций, следующих за ''jsr''. Объединение использует набор специальных значений для локальных переменных:
** Для всех локальных переменных, для которых битовый вектор (созданный ранее) показывает, что к переменной был доступ или её модификация, необходимо использовать тип локальной переменной времени выполнения инструкции ''ret''.
** Для всех остальных локальных переменных использовать тип локальной переменной перед инструкцией ''jsr''.

<br><br><br><br>
=== Ограничения виртуальной машины Java ===

Следующие ограничения виртуальной машины Java являются следствием формата <font face=Courier>class</font> файла.
* Константный пул класса или интерфейса ограничен 65535 элементами из-за размерности 16 бит поля <font face=Courier>constant_pool_count</font> структуры <font face=Courier>ClassFile</font> (см. §4.1). Этот факт выступает в роли внутреннего ограничения сложности класса или интерфейса.
* Количество полей, которые можно объявить в классе или интерфейсе не превосходит 65535 и ограничено размером элемента <font face=Courier>fields_count</font> структуры <font face=Courier>ClassFile</font> (см. §4.1).
: Обратите внимание, что значение элемента <font face=Courier>fields_count</font> структуры <font face=Courier>ClassFile</font> не включает в себя поля, которые были унаследованы от классов предков или классов интерфейсов.
* Количество методов, которые можно объявить в классе или интерфейсе не превосходит 65535 и ограничено размером элемента <font face=Courier>methods_count</font> структуры <font face=Courier>ClassFile</font> (см. §4.1).
: Обратите внимание, что значение элемента <font face=Courier>methods_count</font> структуры <font face=Courier>ClassFile</font> не включает в себя методы, которые были унаследованы от классов предков или классов интерфейсов.
* Количество непосредственных интерфейсов-предков класса или интерфейса не превосходит 65535 и ограничено размером элемента <font face=Courier>interfaces_count</font> структуры <font face=Courier>ClassFile</font> (см. §4.1).
* Максимальное число локальных переменных в массиве локальных переменных фрейма, созданного при вызове метода (см. §2.6) не превышает 65535 и ограничено размером элемента <font face=Courier>max_locals</font> атрибута <font face=Courier>Code</font> (см. §4.7.3), содержащего код метода, а также размером в 16 бит индекса локальных переменных набора инструкций виртуальной машины Java. 
: Обратите внимание, что значения с типами <font face=Courier>long</font> и <font face=Courier>double</font> каждое рассматривается как занимающее две локальных переменных и, следовательно, уменьшающее на два значение <font face=Courier>max_locals</font>, так что использование локальных переменных данных типов, сверх ещё более уменьшает их максимально допустимое количество.
* Размер стека операндов во фрейме (см. §2.6) и ограничен размером элемента <font face=Courier>max_stack</font> атрибута <font face=Courier>Code</font> (см. §4.7.3).
: Обратите внимание, что значения с типами <font face=Courier>long</font> и <font face=Courier>double</font> каждое рассматривается как занимающее два элемента <font face=Courier>max_stack</font>, так что использование локальных переменных данных типов, сверх ещё более уменьшает их максимально допустимое количество.
* Количество параметров метода не превышает 255 и ограничено определением дескриптора метода (см. §4.3.3), причём указанный предел включает в себя один элемент для параметра <font face=Courier>this</font> в случае вызова метода экземпляра или интерфейса.
: Обратите внимание, что дескриптор метода определён с использованием понятий размера переменной для которых параметр типа  <font face=Courier>long</font> или <font face=Courier>double</font> занимает две единицы длинны, так что использование параметров метода данных типов, сверх ещё более уменьшает их максимально допустимое количество.
* Длинна имени поля или метода, дескриптора поля или метода и других строковых констант (включая тех, на которые ссылается атрибут <font face=Courier>ConstantValue</font> (§4.7.2)) не превышает 655535 символов и ограничена размерность 16 бит беззнакового элемента <font face=Courier>length</font> структуры <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7)
: Обратите внимание, что ограничение связано с числом байт в кодируемой строке, а не с числом символов в строке. UTF-8 кодирует некоторые символы используя два или три байта. Поэтому строки, включающие в себя многобайтовые символы ещё более ограничены по размеру.
* Количество измерений многомерного массива не превышает 255 и ограничено размером операнда <font face=Courier>dimensions</font> инструкции ''multianewarray'' и ограничениями, налагаемыми инструкциями ''multianewarray'', ''anewarray'' и ''newarray'' (см. §4.9.1 и §4.9.2).

<br><br><br><br>
== ГЛАВА 5. Загрузка, компоновка и инициализация ==

Виртуальная машина Java динамически загружает, компонует и инициализирует классы и интерфейсы. Загрузка это процесс поиска двоичного представления класса или интерфейсного типа с заданным именем, а также создание класса или интерфейса из этого двоичного представления. Компоновка – это процесс преобразования класса или интерфейса в состояние виртуальной машины Java времени выполнения. Инициализация класса или интерфейса состоит в выполнении инициализирующего метода <font face=Courier><clinit></font> (см. §2.9) класса или интерфейса.

В этой главе в параграфе §5.1 описано как виртуальная машина Java получает символьные ссылки на класс или интерфейс из их двоичного представления. В §5.2 описаны процессы загрузки, компоновки и инициализации, в случае, когда виртуальная машина Java выполняет их в первый раз за время работы программы. В §5.3 описано как двоичное представление классов и интерфейсов загружается загрузчиком классов и как создаются классы и интерфейсы. В §5.4 представлено описание процесса компоновки. В §5.5 описаны подробности инициализации классов и интерфейсов. В §5.6 описаны основные принципы связывания платформенно зависимых методов. Наконец, в §5.7 описаны условия завершения работы виртуальной машины Java.

<br><br><br><br>
=== Константный пул времени выполнения ===

Виртуальная машина Java поддерживает работу типизированного константного пула (см. §2.5.5) – структуры данных времени выполнения, которая используется в общепринятой реализации языка программирования. Константный пул используется как символьная таблица.

Таблица <font face=Courier>constant_pool</font> (см. §4.4) в двоичном представлении класса или интерфейса используется для построения константного пула времени выполнения во время создания класса или интерфейса. Все ссылки в константном пуле времени выполнения – это символьные ссылки. Символьные ссылки константного пула времени выполнения создаются из структур данных двоичного представления класса или интерфейса следующим образом:

* Символьная ссылка на класс или интерфейс создаётся на основе структуры <font face=Courier>CONSTANT_Class_info</font> (см. §4.4.1), содержащейся в двоичном представлении класса или интерфейса. Такая ссылка даёт имя класса или интерфейса в той форме, в которой её возвращает метод <font face=Courier>Class</font>.<font face=Courier>getName</font>, а именно:
** Если класс не является массивом, то имя класса – это двоичное имя (см. §4.2.1)
** Если класс представляет собой массив размерности n, то имя класса начинается с n повторений ASCII символа «[», за которым следует описание типа элементов массива:
*** Если тип элемента является примитивным, то в имени он представлен соответствующим дескриптором (см. §4.3.2).
*** В противном случае, если тип элемента это ссылочный тип, он представлен ASCII символом «L» за которым следует двоичное имя типа элемента и ASCII символ «;».
: Везде в этой главе, где мы ссылаемся на имя класса или интерфейса, данное имя следует понимать как имя, возвращаемое методом <font face=Courier>Class</font>.<font face=Courier>getName</font>.
* Символьная ссылка на поле класса или интерфейса создаётся на основе структуры <font face=Courier>CONSTANT_Fieldref_info</font> (см. §4.4.2), содержащейся в двоичном представлении класса или интерфейса. Такая ссылка даёт имя и дескриптор поля, а также символьную ссылку на класс или интерфейс, в котором данное поле может быть найдено.
* Символьная ссылка на метод класса создаётся на основе структуры <font face=Courier>CONSTANT_Methodref_info</font> (см. §4.4.2), содержащейся в двоичном представлении класса или интерфейса. Такая ссылка даёт имя и дескриптор метода, а также символьную ссылку на класс, в котором данный метод может быть найдено.
* Символьная ссылка на метод интерфейса создаётся на основе структуры <font face=Courier>CONSTANT_InterfaceMethodref_info</font> (см. §4.4.2), содержащейся в двоичном представлении класса или интерфейса. Такая ссылка даёт имя и дескриптор метода, а также символьную ссылку на интерфейс, в котором данный метод может быть найдено.
* Символьная ссылка на обработчик метода создаётся на основе структуры <font face=Courier>CONSTANT_MethodHandle_info</font> (см. §4.4.8), содержащейся в двоичном представлении класса или интерфейса.
* Символьная ссылка на тип метода создаётся на основе структуры <font face=Courier>CONSTANT_MethodType_info</font> (см. §4.4.9), содержащейся в двоичном представлении класса или интерфейса.
* Символьная ссылка на спецификатор узла вызова создаётся на основе структуры <font face=Courier>CONSTANT_InvokeDynamic_info</font> (см. §4.4.10), содержащейся в двоичном представлении класса или интерфейса. Такая ссылка предоставляет:
** символьную ссылку на обработчик метода, который служит начальным методом для инструкции ''invokedynamic'';
** набор символьных ссылок (на классы, типы методов и обработчики методов), строковые литералы, константы времени выполнения (например, значения числовых примитивов), которые служат статическими аргументами загрузочного метода;
** имя метода и дескриптор метода. 
: В дополнение, некоторые величины времени выполнения, не являющиеся символьными ссылками, создаются на основе элементов таблицы <font face=Courier>constant_pool</font>:
* Строковые литералы, представляющие собой ссылки (тип <font face=Courier>reference</font>) на экземпляр класса <font face=Courier>String</font>, создаются на основе структуры  <font face=Courier>CONSTANT_String_info</font> (см. §4.4.3), содержащейся в двоичном представлении класса или интерфейса. Структура <font face=Courier>CONSTANT_String_info</font> представляет собой последовательность символов (кодовых точек) Unicode, составляющую строковый литерал.
: Согласно требованиям языка программирования Java, равные строковые литералы (то есть содержащие одинаковую последовательность символов) должны ссылаться на один и тот же экземпляр класса <font face=Courier>String</font> (JLS §3.10.5). К тому же, если метод <font face=Courier>String</font>.<font face=Courier>intern</font> вызывается для произвольной строки, то результатом должна быть ссылка (тип <font face=Courier>reference</font>)  на экземпляр класса, которая будет возвращена,  если бы исходная строка была единым литералом. Поэтому следующее выражение должно всегда быть истинным:

<br>
{| width="95%" border="0" style="border-collapse:collapse; margin-left: 23px;" |
|
<syntaxhighlight lang="java">
("a" + "b" + "c").intern() == "abc"
</syntaxhighlight>
|}
<br>

: Для создания строкового литерала, виртуальная машина Java проверяет последовательность символов из структуры <font face=Courier>CONSTANT_String_info</font>.
:* Если метод <font face=Courier>String</font>.<font face=Courier>intern</font> уже был вызван ранее для экземпляра класса <font face=Courier>String</font>, содержащего последовательность символов Unicode идентичную последовательности в структуре <font face=Courier>CONSTANT_String_info</font>, то результат создания строкового литерала – ссылка типа <font face=Courier>reference</font> на уже созданный ранее экземпляр класса <font face=Courier>String</font>.
:* В противном случае, создаётся новый экземпляр класса <font face=Courier>String</font>, содержащий последовательность символов Unicode из структуры <font face=Courier>CONSTANT_String_info</font>; результатом создания строкового литерала будет ссылка на экземпляр класса. Затем вызывается метод <font face=Courier>intern</font> у только что созданного экземпляра класса <font face=Courier>String</font>.
* Константы времени выполнения создаются на основе структур <font face=Courier>CONSTANT_Integer_info</font>, <font face=Courier>CONSTANT_Float_info</font>,  <font face=Courier>CONSTANT_Long_info</font> и <font face=Courier>CONSTANT_Double_info</font> (см. §4.4.4, §4.4.5), содержащихся в двоичном представлении класса или интерфейса.
: Обратите внимание, что структура <font face=Courier>CONSTANT_Float_info</font> представляет значения с плавающей точкой одинарной точности согласно стандарту <font face=Courier>IEEE</font> 754, а структура <font face=Courier>CONSTANT_Double_info</font> – двойной точности (см. §4.4.4, §4.4.5). Поэтому константы времени выполнения, созданные из этих структур, должны быть значениями представимыми в стандарте <font face=Courier>IEEE</font> 754 в одинарной и двойной точности соответственно.

Оставшиеся структуры в таблице <font face=Courier>constant_pool</font> в двоичном представлении класса или интерфейса –  <font face=Courier>CONSTANT_NameAndType_info</font> (см. §4.4.6) и <font face=Courier>CONSTANT_Utf8_info</font> (см. §4.4.7) – используются неявным образом при создании символьных ссылок на классы, интерфейсы, методы, поля, типы методов и обработчики методов, а также при создании строковых литералов и спецификаторов узлов вызова.

<br><br><br><br>
=== Запуск виртуальной машины ===

Запуск виртуальной машины происходит с созданием инициализирующего класса, определённого в начальном загрузчике классов (см. §5.3.1) способом, зависящим от платформы. Затем виртуальная машина Java компонует инициализирующий класс, инициализирует его и вызывает публичный метод <font face=Courier>public</font> <font face=Courier>void</font> <font face=Courier>main</font>(<font face=Courier>String</font>[]). С вызова этого метода начинается выполнение всех последующих методов. Выполнение инструкций виртуальной машины Java, содержащихся в методе <font face=Courier>main</font>, может привести к компоновке (и, следовательно, созданию) дополнительных классов и интерфейсов, а также вызову дополнительных методов.

В реализации виртуальной машины Java инициализирующий класс может быть задан как аргумент командой строки. В качестве альтернативы, реализация виртуальной машины может предоставить инициализирующий класс, который запускает загрузчик классов, который в свою очередь загружает приложение. Также допустимы и другие варианты определения инициализирующего класса, если они не противоречат спецификации, данной в предыдущем параграфе.

