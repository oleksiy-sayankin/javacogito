__TOC__


'''Предисловие к первому изданию'''

-----

Данная спецификация виртуальной машины Java написана для полного документирования архитектуры виртуальной машины Java. Она важна для разработчиков компиляторов, которые проектируют виртуальную машину Java и для программистов, реализующих совместимую виртуальную машину Java.

Виртуальная машина Java является абстрактной машиной. ''Ссылки на виртуальную машину Java'' в данной спецификации обращены к абстрактной машине, а не к реализации от компании Oracle либо любой другой конкретной реализации. Данная спецификация служит документом для конкретной реализации виртуальной машины Java только как чертёж, служащий документом для постройки дома. Реализация виртуальной машины Java (также известная как интерпретатор времени выполнения) должна воплощать в себе данную спецификацию, но ограничения на реализацию накладываются только там, где это действительно необходимо.  

Виртуальная машина  Java, описанная здесь совместима с Java Platform<sup>TM</sup>,
Standard Edition 7 и поддерживает язык программирования Java, описанный в ''Спецификации языка  Java, Java SE 7 Edition''.

Мы намеревались так написать эту спецификацию, чтобы предоставить полную информацию о виртуальной машине Java и сделать возможным появление других полностью совместимых между собой реализаций. Если вы задумали создать свою собственную реализацию виртуальной машины Java, без колебаний обращайтесь к авторам спецификации за дополнительной информацией, чтобы получить на 100% совместимую реализацию. 

Виртуальная машина, ставшая затем виртуальной машиной Java первоначально была разработана Джеймсом Гослингом  (James Gosling) в 1992 году для поддержки языка программирования Oak. В развитии проекта к его существующему состоянию прямо или косвенно принимали участие множество людей, будучи в самых различных проектах и группах: проект Green компании Sun, проект FirstPerson, Inc., проект LiveOak, группа Java Products Group, группа JavaSoft и в настоящее время Java Platform Group компании Oracle. Авторы благодарны многим разработчикам, писавшим код и оказывавшим техническую поддержку.

Эта книга берет своё начало в качестве внутреннего проекта по документации. Кейти Волрат (Kathy Walrath) выполнила редактирование начального черновика, помогая тем самым миру увидеть первое описание внутренней реализации языка программирования Java. В то же время Марией Кемпион (Mary Campione) описание было переведено в формат HTML  и опубликовано на нашем веб-сайте, прежде чем оно было расширено до размеров книги.

Создание ''Спецификации виртуальной машины Java'' во многом обязано поддержке группы  Java Products Group, руководимой главным менеджером Рутом Хеннигаром (Ruth Hennigar), а также усилиям редакторов Лизи Френдли (Lisa Friendly) и Майка Хендриксона (Mike Hendrickson) и его группы из Addison-Wesley. Безмерно помогли поднять качество издания  множественные замечания и предложения, полученные как от редакторов  рукописи так и читтателей уже опубликованной книги. Мы особенно благодарим Ричарда Така (Richard Tuck) за его тщательное прочтение и правку рукописи. Отдельное спасибо Билу Джою (Bill Joy), чьи комментарии, правки и помощь во многом способствовали целостности и точности данной книги.  

<div align="right">
Тим Лидхольм (Tim Lindholm)

Френк Йеллин (Frank Yellin)
</div>



'''Предисловие ко второму изданию'''
-----

Во второй редакции спецификации виртуальной машины Java добавлены изменения касающиеся выхода платформы Java® 2, версии 1.2. Вторая редакция также включает в себя множественные правки и разъяснения касательно изложения спецификации, оставив при этом логическую часть спецификации без изменения. Мы попытались исправить опечатки а также откорректировать список опечаток (надеемся без привнесения новых опечаток) и добавить больше деталей в описании в случаях неясности или двусмысленности. В частности, мы исправили определённое число несоответствий между ''Спецификацией виртуальной машины Java'' и ''Спецификацией языка Java''.

Мы благодарны многим читателям, которые с усиленным вниманием прочли  первую редакцию данной книги и высветили для нас ряд проблем. Некоторые лица и группы заслуживают отдельной благодарности за то, что обратили наше внимание на проблемные места в спецификации либо непосредственно способствовали написанию нового материала:

Клара Шроер (Carla Schroer) и её команда тестировщиков совместимости в Купертино, Калифорния и Новосибирске, Россия (с особенной благодарностью Леониду Арбузову и Алексею Кайгородову) с особым усердием написали тесты совместимости для каждого тестируемого утверждения в первой редакции. В процессе работы они нашили множество мест, где исходная спецификация была либо не ясна либо неполна. 

Джероин Вермулен (Jeroen Vermeulen), Дженис Шеперд (Janice Shepherd), Роли Перера (Roly Perera), Джо Дарси (Joe Darcy) и Сандра Лузмор (Sandra Loosemore) добавили множество комментариев и ценных замечаний, которые улучшили данное издание.

Мэрилин Рэш (Marilyn Rash) и Хилари Селби Полк (Hilary Selby Polk) из редакции Addison Wesley Longman помогли нам улучшить читаемость и макет страниц в данном издании, в то время как мы были заняты технической частью спецификации. 

Особую благодарность мы направляем Гиладу Брача (Gilad Bracha), выведшему строгость изложения на принципиально новый уровень и добавившему большой объем нового материала, особенно в главах 4 и 5. Его преданность «компьютерной теологии» и несгибаемое чувство долга в отношении устранения несоответствий между ''Спецификацией виртуальной машины Java'' и ''Спецификацией языка Java'' позволили невообразимо улучшить качество данной книги.

<div align="right">
Тим Лидхольм (Tim Lindholm)

Френк Йеллин (Frank Yellin)
</div>


'''Предисловие к изданию Java SE 7'''
-----

Издание Java SE 7 ''Спецификации виртуальной машины Java'' включает в себя все изменения, сделанные со времени выхода второго издания в 1999 году. В дополнение к этому было сделано множество правок и разъяснений, согласовывающих спецификацию со многими известными реализациями виртуальной машины Java, а также с принципами, общими для виртуальной машины Java и языка программирования Java.

Разработка платформы Java SE 5.0 в 2004 году привела к множественным изменениям в языке программирования  Java, но имела относительно не большое влияние на архитектуру виртуальной машины  Java. Изменения были выполнены в формате <code>class</code> файла для поддержки нового функционала  в языке программирования  Java, такого как обобщённые типы и методы с переменным числом параметров.

Появление платформы Java SE 6 в 2006 году не повлияло непосредственно на язык программирования Java, но привело к созданию нового подхода в проверке байткода виртуальной машины Java. Ева Роуз (Eva Rose) в своей кандидатской диссертации выполнила радикальный пересмотр верификации байткода JVM в контексте платформы Java Card<sup>TM</sup>. Это, во-первых, привело к реализации Java ME CLDC и в конце концов пересмотру процесса проверки для Java SE, описанного в главе 4.

Шень Лиань (Sheng Liang) выполнила реализацию верификатора для Java ME CLDC. Антеро Тайвалсаари (Antero Taivalsaari) руководил разработкой спецификации Java ME CLDC в целом, а Гилад Брача (Gilad Bracha) был ответственен за документацию по верификатору.  Анализ проверки байткода JVM, выполненный Алессандро Коглио (Alessandro Coglio), был самой трудоёмкой, наиболее соответствующей действительности и счерпывающей тему новой частью, добавленной в спецификацию. Вей Тао (Wei Tao) совместно с Фрэнком Йеллиным (Frank Yellin), Тимом Линдхольмом (Tim Lindholm) и Гиладом Брача написали Пролог верификатор, лёгшим в основу как спецификации Java ME так и Java SE. Затем Вей реализовал спецификацию в реальном коде «для настоящей» HotSpot JVM. Затем Мингайо Янг (Mingyao Yang) улучшил архитектуру и саму спецификацию и реализовал итоговую версию, которая превратилась в реализацию ссылок в Java SE 6. Спецификация во многом была улучшена благодаря усилиям группы JSR 202 Expert Group: Питера Бурки (Peter Burka), Алессандро Коглио (Alessandro Coglio), Сеньхун Джина (Sanghoon Jin), Кристиана Кемпера (Christian Kemper), Лэри Ро (Larry Rau), Эви Роуз (Eva Rose), Марка Штольца (Mark Stolz).

Вышедшая в 2011 году платформа Java SE 7 реализовала, данное в 1997 году в ''Спецификации виртуальной машины Java'', обещание: «В будущем, мы добавим в виртуальную машину Java новые расширения  для того чтобы представить улучшенную поддержку других языков». Гилад Брача в своей работе по динамической замене типов предвидел трудности реализации статической системы типов виртуальной машины Java в динамически типизированных языках. В результате джоном Роузом (John Rose) и экспертной группой JSR 292 Expert Group (Оля Бини (Ola Bini), Реми Форакс (Rémi Forax), Дэн Хейдинга (Dan Heidinga), Фредрик Орштром (Fredrik Öhrström), Джочен Теодору (Jochen Theodorou), а также Чарли Наттер (Charlie Nutter) и Кристиан Тайлингер (Christian Thalinger)) была разработана инструкция ''invokedynamic'' и вся необходимая инфрастуктура.

Множество людей, которых мы не упомянули в данном предисловии, внесли свою лепту в архитектуру и реализацию виртуальной машины Java. Превосходная производительность JVM, которую мы видим сегодня, была бы не достижима без технологического фундамента, заложенного Девидом Унгаром (David Ungar) и его коллегами из проекта Self компании Sun Labs. Эта технология пришла извилистый путь из проекта Self через проект Animorphic Smalltalk VM и затем, в конце концов, стала Oracle HotSpot JVM. Ларс Бак (Lars Bak) и Урс Хёльзль (Urs Hölzle) присутствовали при всех перипетиях технологии и более чем кто-либо другой ответственны за высокую производительность присущую JVM в наши дни. 

Эта спецификация был значительно улучшена благодаря усилиям следующих людей: Мартин Бакхольц (Martin Buchholz), Брайан Гоэц (Brian Goetz), Пол Хоэнси (Paul Hohensee), Девид Холмс (David Holmes), Карен Киннер (Karen Kinnear), Кейт МакГайген (Keith McGuigan), Джефф Найзвонгер (Jeff Nisewanger), Марк Рейнхольд (Mark Reinhold), Наото Сато (Naoto Sato), Билл Паф (Bill Pugh), а также Уди Даниконда (Uday Dhanikonda), Дженет Коэниг (Janet Koenig), Адам Месингер (Adam Messinger), Джон Пэмпач (John Pampuch), Джоржд Сааб (Georges Saab) и Бернард Траверсет (Bernard Traversat). Джон Картни (Jon Courtney) и Роджер Ригз (Roger Riggs) помогли гарантировать, что данная спецификация применима как к Java ME так и к Java SE. Леонид Арбузов, Станислав Авзан, Юрий Гаевский, Илья Мухин, Сергей Резник и Кирилл Широков выполнили потрясающий объем работ в Java Compatibility Kit  (набор тестов по проверки совместимости версий) для того чтобы гарантировать корректность данной спецификации.


<div align="right">
Гилад Брача (Gilad Bracha)

Алекс Бакли (Alex Buckley)

''Java Platform Group, Oracle''
</div>

== ГЛАВА 1. Введение ==

=== Немного истории ===

Язык программирования Java это многоцелевой, многопоточный объектно-ориентированный язык. Его синтаксис похож на C и C++ но исключает некоторые особенности, которые делают на C и C++ сложным, запутанным и небезопасным. Первоначально платформа Java была разработана для решения проблем построения программного обеспечения для сетевых устройств. Она была спроектирована для архитектур, включающих в себя множество серверов, при этом позволяя безопасно обновлять компоненты ПО. Чтобы удовлетворить этим требованиям, скомпилированный код должен быть выполняемым на любом клиенте, а также гарантировать безопасность своей работы.  
Развитие мировой паутины сделало эти требования более значимыми. Современные веб-браузеры позволяют миллионам людей путешествовать по сети и легко получать доступ  практически к любым данным. В конце концов, была создана медиа среда, в которой то, что видит и слышит пользователь, совершенно не зависит ни от типа компьютера, который он использует, ни от скорости сетевого соединения: быстрого либо медленного.

Однако активные пользователи сети вскоре обнаружили, что формат документов HTML слишком ограничен. HTML расширения, такие как формы, только подчеркнули существующие ограничения; стало ясно, что ни один браузер не в состоянии предоставить все инструменты, которые пользователи желают видеть. Выход из тупика был в расширяемости.
Первый браузер HotJava компании Sun продемонстрировал некоторые интересные свойства языка программирования  и платформы Java, дав возможность внедрять программы внутрь HTML страниц. Программы загружались непосредственно в браузер параллельно с HTML страницами, в которых они появлялись. Прежде чем браузер давал возможность выполнить программу, они проходили тщательную проверку на безопасность. Также как и HTML страницы, скомпилированные программы не зависят от протоколов сети и типов машин, на которых они выполняются. Программы ведут себя одинаково вне зависимости от того, где они были созданы и куда загружены.
 
Веб-браузер, поддерживающий платформу Java, теперь не был ограничен заранее определенным набором возможностей. Посетители веб страниц, имеющих динамическое содержимое, могли быть уверены, что их система надёжно защищена. В тоже время программисты получили возможность, однажды написав программу, запускать её на любом компьютере, поддерживающем платформу Java.


=== Виртуальная машина Java ===

Виртуальная машина Java является ключевым аспектом платформы Java. Это компонент технологии, который отвечает за независимость от программного обеспечения и операционной системы, небольшой размер скомпилированного кода и возможность защитить пользователей от вредоносных программ.
 
Виртуальная машина Java это абстрактная вычислительная машина. Как и реальная вычислительная машина, она имеет набор инструкций и манипулирует разными участками памяти во время своей работы. Вообще говоря, это достаточно общий подход -  реализовать язык программирования, используя виртуальную машину; наиболее известная среди таких машин – машина P-Code, реализованная в Университете Калифорнии, в Сан Диего.

Первый прототип реализации виртуальной машины Java был сделан компанией Sun Microsystems, Inc. на ручном устройстве, которое напоминало современный персональный цифровой помощник (миникомпьютер с записной книжкой, календарём и местом для хранения информации. В данный момент полностью вытеснены смартфонами - ''прим. перев.''). В настоящее время компания Oracle создала виртуальные машины Java для мобильных устройств, настольных компьютеров и серверных систем, однако сама виртуальная машина не подразумевает привязки к конкретному оборудованию, операционной системе или способу ее реализации. Виртуальная машина Java может быть реализована как компилированием ее инструкций в набор команд конкретного процессора, так и непосредственно в процессоре.

Непосредственно виртуальная машина  Java «не знает» ничего о языке программирования Java, ей лишь известен заданный формат двоичных файлов –  файлов, имеющих расширение <code>class</code>. Эти файлы содержат инструкции виртуальной машины (байткод), таблицы символов и другую вспомогательную информацию.
Из соображений безопасности виртуальная машина Java предъявляет строгие синтаксические и структурные требования на код, расположенный в <code>class</code> файле. Тем не менее, любой язык, функциональность которого может быть выражена в средствами корректного <code>class</code> файла,  может быть интерпретирован для виртуальной машины Java. Привлечённые общедоступностью и платформенной независимостью, разработчики компиляторов других языков могут использовать виртуальную машину как удобную платформу для своих реализаций.

=== Краткое содержание глав ===

Эта книга структурирована следующим образом:

* Глава 2 содержит обзор архитектуры виртуальной машины Java.
* Глава 3 описывает принципы компиляции кода, написанного на языке программирования Java в набор инструкций виртуальной машины Java.
* Глава 4 содержит описание формата <code>class</code> файла – формата, не зависящего от аппаратного обеспечения и операционной системы – который используется для хранения скомпилированных классов и интерфейсов.
* Глава 5 описывает запуск виртуальной машины Java, а также загрузку, компоновку и инициализацию классов и интерфейсов.
* Глава 6 определяет набор инструкций виртуальной машины Java. Инструкции расположены в алфавитном порядке их мнемонических записей.
* Глава 7 содержит таблицу инструкций виртуальной машины Java, расположенных по возрастанию их байт-кодов.  

Глава 2 ''Спецификации виртуальной машины Java (второе издание)'' содержит обзор языка программирования Java; этот обзор выполнен для описания работы виртуальной машины Java и не является частью спецификации. В ''Спецификации виртуальной машины Java (второе издание)'' читатель отсылается к Спецификации языка программирования Java SE 7 Edition за более подробной информацией о языке программирования Java. Такая ссылка имеет вид: (см. JLS §x.y).

Глава 8 ''Спецификации виртуальной машины Java (второе издание)'' посвящена низкоуровневым операциям взаимодействия потоков виртуальной машины Java с основной разделяемой памятью. Эта глава была переделана из главы 17 первой редакции ''Спецификации языка программирования Java''. Глава 17 ''Спецификации языка программирования Java SE 7 Edition'' отражает Спецификацию модели памяти и потоков, составленную экспертной группой JSR-133. За информацией о блокировках и потоках читатель отсылается к соответствующим главам Спецификации модели памяти и потоков.

=== Принятые обозначения ===

Везде в этой книге мы имеет дело только с классами и интерфейсами из Java SE API. Везде, где мы ссылаемся на класс или интерфейс с помощью идентификатора ''N'', на самом деле мы подразумеваем следующую ссылку <code>java.lang.''N''</code>. Для классов не из пакета <code>java.lang</code> мы используем полное имя (имя пакета и имя класса). 
Везде, где мы ссылаемся на класс или интерфейс, объявленный в пакете <code>java</code> или любом из его подпакетов, мы имеем в виду, что класс или интерфейс загружен загрузчиком классов (см. §5.3.1).

Везде, где мы ссылаемся на подпакет объявленный в пакете <code>java</code>, мы имеем в виду, что класс или интерфейс загружен загрузчиком классов.
В спецификации используются следующие  виды шрифтов:

* <code>Моноширинный шрифт</code> используется для примеров исходного кода на языке программирования Java, типов данных виртуальной машины Java, исключений и ошибок.
* ''Курси''в используется для обозначения «языка ассемблера» виртуальной машины Java: операторов, операндов и элементов данный в области данный времени выполнения виртуальной машины Java. Курсив также используется для введения новых терминов и для обозначения акцента в предложении.

== ГЛАВА 2. Структура виртуальной машины Java ==

Этот документ посвящён абстрактной виртуальной машине, он не описывает конкретную реализацию виртуальной машины.
Для корректной реализации виртуальной машины Java, разработчику необходимо только правильно прочесть <code>class</code> файл и правильно выполнить операции, определённые там. Детали имплементации не являются частью спецификации виртуальной машины Java, и приведение их неоправданно ограничило бы свободу разработчика. Например, распределение памяти во время работы программы, алгоритм сборщика мусора и внутренняя оптимизация инструкций виртуальной машины Java (например, перевод их в машинный код) оставлены на усмотрение разработчика. 

Все ссылки относительно кодовой таблицы Unicode в этом документе приведены в соответствии со стандартом Unicode версии 6.0.0 доступной по адресу http://www.unicode.org/

=== Формат <code>class</code> файла ===

Скомпилированный для выполнения виртуальной машиной Java код, представляет собой набор данных двоичного формата независимого от операционной системы и аппаратного обеспечения, обычно (но не всегда) хранимый в файле, известном как <code>class</code> файл. Формат <code>class</code> файла точно определяет представление класса или интерфейса, включая такие особенности как порядок байтов при работе с двоичными данными в платформенно зависимом файле.

В главе 4, «Формат class файла» приведено подробное описание формата.

=== Типы данных ===

Так же как и язык программирования Java виртуальная машина  Java оперирует двумя разновидностями типов данных: примитивные типы и ссылочные типы. Соответственно существует две разновидности значений, которые могут храниться в переменных, быть переданы как аргументы, возвращены методами и использованными в операторах: примитивные значения и ссылочные значения.

Виртуальная машина Java полагает, что почти все проверки соответствия типов будут выполнены до запуска кода (обычно компилятором) и поэтому такую проверку типов не делает. Нет необходимости помечать значения примитивных типов или как-нибудь иначе наблюдать за ними во время выполнения программы, также нет необходимости отличать примитивные типы от ссылочных типов. Вместо этого,  виртуальная машина Java, содержит наборы инструкций предназначенных для выполнения операций со строго определёнными типами данных. Например, следующие команды ''iadd'', ''ladd'', ''fadd'', и  ''dadd'' представляют собой весь спектр команд для сложения двух числовых значений и получения одного результата, однако каждая предназначена для операндов строго определённого типа: <code>int</code>, <code>long</code>, <code>float</code>, и <code>double</code>  соответственно. Более подробно описание поддерживаемых типов изложено в § 2.11.1.

Виртуальная машина Java содержит явную поддержку объектов. Объектом мы называем динамически создаваемый экземпляр класса или массив. Ссылка на объект представлена в виртуальной машине Java типом <code>reference</code>. Значения типа <code>reference</code> могут быть рассмотрены как указатели на объекты. На один и тот же объкт может существовать множество ссылок. Передача объектов, операции над объектами, проверка объектов происходит всегда посредством типа <code>reference</code>.


=== Примитивные типы и значения ===

Виртуальная машина Java поддерживает следующие примитивные типы: числовые типы, <code>boolean</code> тип (см. § 2.3.4) и <code>returnAddress</code> тип (см. § 2.3.3).
Числовые типы содержат в себе целые типы (см. § 2.3.1) и типы с плавающей точкой (см. § 2.3.2)
Целые типы:

* <code>byte</code>, содержит 8-битовые знаковые целые. Значение по умолчанию - ноль. 
* <code>short</code>, содержит 16-битовые знаковые целые. Значение по умолчанию - ноль.
* <code>int</code>, содержит 32-битовые знаковые целые. Значение по умолчанию - ноль.
* <code>long</code>, содержит 64-битовые знаковые целые. Значение по умолчанию - ноль.
* <code>char</code>, содержит 16-битовые беззнаковые целые, представляющие собой кодовые точки таблицы символов Unicode в базовой странице UTF-16. Значение по умолчанию - нулевая кодовая точка ('\u0000')

Типы с плавающей точкой:

* <code>float</code>, содержит числа с плавающей точкой одинарной точности. Значение по умолчанию - положительный ноль.
* <code>double</code>, содержит числа с плавающей точкой двойной точности. Значение по умолчанию - положительный ноль.

Значение <code>boolean</code> типа может быть <code>true</code> или <code>false</code>, значение по умолчанию <code>false</code>.
<br><br>
:: Примечание. В первой редакции спецификации виртуальной машины Java тип данных <code>boolean</code> не рассматривался как машинный тип. Однако <code>boolean</code>  значения частично поддерживались виртуальной машиной. Во второй редакции эта неясность была устранена, и тип данных <code>boolean</code> стал машинным типом.

:: Тип данных <code>returnAddress</code> представляет собой указатель на код инструкции виртуальной машины. Из всех примитивных типов только <code>returnAddress</code>  не ассоциируется с типом данных из языка Java.


==== Целочисленные типы и их значения ====

Существуют следующие диапазоны для целочисленных значений:

* для типа <code>byte</code> от -128 до 127 (-2<sup>7</sup> до 2<sup>7</sup> - 1) включительно;
* для типа <code>short</code> от -32768 до 32767 (-2<sup>15</sup> до 2<sup>15</sup> - 1) включительно;
* для типа <code>int</code> от  -2147483648 до 2147483647 (-2<sup>31</sup> до 2<sup>31</sup> - 1) включительно;
* для типа <code>long</code> от  -9223372036854775808 до 9223372036854775807 (-2<sup>63</sup> до 2<sup>63</sup> - 1) включительно;
* для типа <code>char</code> от 0 до 65535 включительно;

==== Типы данных с плавающей точкой, множества значений и значения ====

Типами данных с плавающей точкой являются типы <code>float</code> и <code>double</code> соответственно 32-х битые значения одинарной точности и 64-х битные значения двойной точности. Формат чисел и операции над ними соответствуют спецификации ''IEEE Standard for Binary Floating-Point Arithmetic'' (ANSI/IEEE Std. 754-1985, New York).

Стандарт IEEE 754 включает в себя не только положительные и отрицательные значения мантиссы, но также и положительные и отрицательные нули, положительные и отрицательные ''бесконечности'', и специальное не числовое значение NaN (Not-a-Number – ''прим. перев.''). NaN используется в качестве результата некоторых неверных операций, таких как деление нуля на нуль.

Каждая реализация виртуальной машины Java должна поддерживать два стандартных набора значений, называемых ''набор значений одинарной точности''  и  ''набор значений двойной точности''. В дополнение к этому виртуальная машина Java может поддерживать ''набор значений одинарной точности с расширенной экспонентой'' и ''набор значений двойной точности с расширенной экспонентой''. При определённых условиях наборы значений с расширенной экспонентой могут быть использованы для типов <code>float</code> и <code>double</code>.

Конечное не нулевое значение любого из типов данных с плавающей точкой может быть представлено в виде ''s'' ⋅ ''m'' ⋅2<sup>(''e'' – ''N'' + 1)</sup>, где ''s'' равно -1 либо 1, ''m'' – положительное целое меньше чем 2''N'', ''e'' – целое число в пределах ''E<sub>min</sub>'' = -(2<sup>''K''-1</sup>-2) и  ''E<sub>max</sub>'' = 2<sup>''K''-1</sup>-1 включительно, ''N'' и ''K'' – параметры, зависящие от набора значений. Одно и то же числовое значение можно представить несколькими способами. Например, предположим, что ''v'' – значение из набора, представимого в указанной выше форме при определённых  ''s'',  ''m'' и ''e''; тогда, если ''m''  - чётно и ''e'' – меньше чем 2<sup>''K''-1</sup>, то чтобы получить новое представление значения ''v'', можно ''m'' разделить на два, одновременно увеличив ''e'' на единицу. Представление ''s'' ⋅ ''m'' ⋅2<sup>(''e'' – ''N'' + 1)</sup> значения ''v'' называется нормализованным, если ''m''  ≥ 2<sup>''N''-1</sup>; в противном случае говорят, что представление денормализованное. Если значение из множества значений не может быть представлено так, чтобы было справедливо неравенство ''m''  ≥ 2<sup>''N''-1</sup>,  то такое значение называют денормализованным значением, поскольку оно не имеет нормализованного представления. 

В таблице 2.1 приведены ограничения для параметров ''N'' и ''K'' (а также производных параметров ''E<sub>min</sub>'' и ''E<sub>max</sub>'') для двух обязательных и двух не обязательных наборов значений чисел с плавающей точкой.

'''Таблица 2.1 – Параметры для множества чисел с плавающей точкой'''
{| class="wikitable"
!Параметр
!Одинарная точность
!Одинарная точность с расширенной экспонентой
!Двойная точность
!Двойная точность с расширенной экспонентой 
|-
|''N''
|24
|24
|53
|53
|-
|''K''
|8
|≥ 11
|11
|≥ 15
|-
|''E<sub>min</sub>''
| +127
| ≥ + 1023
| + 1023
| ≥ + 16383
|-
|''E<sub>max</sub>''
| -126
| ≤ - 1022
| -1022
| ≤ -16383
|}


Значение константы ''K''  зависит от реализации виртуальной машины там, где наборы значений с расширенной экспонентой вообще поддерживаются (в любом случае ''K'' принадлежит пределам, указанным в таблице); в свою очередь константы ''E<sub>min</sub>'' и ''E<sub>max</sub>'' определяются в зависимости от значения ''K''. 

Каждый из четырёх наборов значений содержит не только конечные ненулевые значения, описанные выше, но также пять дополнительных значений: положительный ноль, отрицательный ноль, положительная бесконечность, отрицательная бесконечность, и не-число (NaN).

Обратите внимание, что ограничения в таблице 2.1 разработаны таким образом, что каждый элемент множества значений одинарной точности также принадлежит множеству значений одинарной точности с расширенной экспонентой, множеству значений с двойной точностью и множеству значений с двойной точностью с расширенной экспонентой. Каждый набор значений с расширенной экспонентой имеет более широкие пределы значений экспоненты по сравнению со стандартным набором, но точность чисел при этом одинаковая.
 
Элементы множества значений чисел с плавающей точкой одинарной точности соответствует значениям, определённым в стандарте IEEE 754, за исключением того, что в этом множестве только одно значение есть не-число NaN (стандарт IEEE 754 предусматривает 2<sup>24</sup>-2 различных не-чисел NaN). Элементы множества значений чисел с плавающей точкой двойной точности соответствует значениям, определённым в стандарте IEEE 754, за исключением того, что в этом множестве только одно значение есть не-число NaN (стандарт IEEE 754 предусматривает 2<sup>53</sup>-2 различных не-чисел NaN). Однако, обратите внимание, что элементы множества значений чисел с плавающей точкой с расширенной экспонентой с одинарной и двойной точностью  ''не соответствуют'' значениям представленным в стандарте IEEE 754 расширенным форматом одинарной точности и расширенным форматом двойной точности соответственно. Данная спецификация не регламентирует внутренне представление чисел с плавающей точкой; единственное место, где должен быть соблюдён формат чисел с плавающей точкой – это формат <code>class</code> файла. 

Набор значений одинарной точности, набор значений двойной точности, набор значений одинарной точности с расширенной экспонентой и набор значений двойной точности с расширенной экспонентой не являются типами данных. В реализации виртуальной машины Java всегда допустимо использовать набор значений одинарной точности для представления значения типа <code>float</code>; однако, в определённом контексте также допустимо использовать набор значений одинарной точности с расширенной экспонентой.  Аналогично всегда допустимо использовать набор значений двойной точности для  представления значения типа <code>double</code>; однако, в определённом контексте также допустимо использовать набор значений двойной точности с расширенной экспонентой.

Все значения (кроме не-чисел NaN) множества чисел с плавающей точкой ''упорядочены''. Если числа упорядочить по возрастанию, то они образуют такую последовательность: отрицательная бесконечность, отрицательные конечные значения, отрицательный ноль, положительный ноль, положительные значения и положительная бесконечность.

Сравнивая положительный и отрицательный ноль, мы получим верное равенство, однако существуют операции, в которых их можно отличить; например, деля <code>1.0</code> на <code>0.0</code>, мы получим положительную бесконечность, но деля <code>1.0</code> на <code>-0.0</code> мы получим отрицательную бесконечность. 

Не-числа NaN  ''не упорядочены'', так что сравнение и проверка на равенство вернёт ''ложь'', если хотя бы один из операндов не-число NaN. В частности проверка на равенство значения самому себе вернёт ''ложь'' тогда и только тогда, кода операнд не-число NaN. Проверка на неравенство вернёт ''истину'', когда хотя бы из операндов не-число NaN.

==== Тип <code>returnAddress</code> и его значения ====

Тип <code>returnAddress</code> используется виртуальной машиной Java в инструкциях ''jsr'',  ''ret'',  ''jsr_w''. Значения типа <code>returnAddress</code> представляют собой указатель на инструкции (адрес инструкции) в виртуальной машине Java. В отличие от примитивных типов тип <code>returnAddress</code> не имеет соответствия в языке программирования Java и его значения не могут быть изменены непосредственно в программном коде.

==== Тип <code>boolean</code> ====

Не смотря на то, что виртуальная машина Java поддерживает тип данных <code>boolean</code>, поддержка этого типа весьма ограничена. Нет никаких инструкций виртуальной машины Java непосредственно относящихся к работе со значениями типа <code>boolean</code>. Вместо этого все выражения, содержащие тип данных <code>boolean</code>, сводятся к эквивалентным операциям с типом данных <code>int</code>.

Тем не менее, виртуальная машина Java поддерживает хранения массивов с булевским типом данных. Операция ''newarray'' позволяет создавать массивы с булевым типом элементов. Доступ и модификация таких массивов осуществляется инструкциями, предназначенными для работы с типом данных <code>byte</code>, а именно: ''baload'' и ''bastore''.
<br> <br>
:: Примечание. В реализации виртуальной машины Java компании Oracle, булевы значения массивов кодируются массивом значений с типом <code>byte</code>, 8 бит на один элемент массива типа <code>boolean</code>.
<br>
В виртуальной машине Java используется значение 1 для кодирования логического <code>true</code> и 0 для <code>false</code>. Везде, где компилятор преобразовывает булевы типы в тип <code>int</code>, он придерживается указанного выше соглашения.

=== Ссылочные типы и их значения ===

Существуют три разновидности ссылочных (<code>reference</code>) типов: тип класса, тип массива и тип интерфейса. Значения этих типов представляют собой ссылки на экземпляр класса, ссылки на массив и ссылки на имплементацию интерфейса соответственно.  

Тип массива представляет собой  ''составной тип''  единичной размерности (длина которого не определена типом). Каждый элемент составного типа сам по себе может также быть массивом. Последовательно рассматривая иерархию составных типов в глубину, (тип, из которого состоит составной тип, из которого состоит составной тип и т.д.) мы придём к типу, который не является массивом; он называется ''элементарным типом'' типа массив. Элементарный тип всегда либо примитивный тип, либо тип класса, либо тип интерфейса.

Тип <code>reference</code> может принимать специальное нулевое значение, так называемая ссылка на не существующий объект, которое обозначается как <code>null</code>. Значение <code>null</code> изначально не принадлежит ни к одному из ссылочных типов и может быть преобразовано к любому.

Спецификация виртуальной машины Java допускает использование произвольной константы для кодирования значения <code>null</code>.


=== Области данных времени выполнения ===

Во время выполнения программы виртуальная машина Java использует разные области для хранения данных. Некоторые из этих областей хранения данных создаются при запуске виртуальной машины Java и освобождаются при завершении работы виртуальной машины. Другие области хранения данных принадлежат потоку. Связанные с потоком области данных создаются при создании потока и освобождаются при завершении работы потока.

==== Регистр <code>pc</code> ====

Виртуальная машина Java может поддерживать множество потоков, выполняющихся одновременно. Каждый поток виртуальной машины Java имеет свой регистр <code>pc</code> (program counter (англ.) – программный счётчик. – ''прим. перев.''). В каждый момент времени каждый поток виртуальной машины исполняет код только одного метода, который называется текущим методом для данного потока. Если метод платформенно независимый (т.е. в объявлении метода не использовано ключевое слово <code>native</code>) регистр <code>pc</code> содержит адрес выполняющейся в данный момент инструкции виртуальной машины Java. Если метод платформенно зависимый (<code>native</code> метод) значение регистра <code>pc</code> не определено. Разрядность регистра <code>pc</code> достаточная, чтобы хранить значения типа <code>returnAddress</code>, а также значения платформенно зависимого адреса инструкций.

==== Стек виртуальной машины Java ====

Каждый поток виртуальной машины имеет свой собственный ''стек виртуальной машины Java'', создаваемый одновременно с потоком. Стек виртуальной машины хранит фреймы. Стек виртуальной машины Java аналогичен стеку в традиционных языках программирования: он хранит локальные переменные и промежуточные результаты и играет свою роль при вызове методов и при возврате управления из методов. Поскольку работать напрямую со стеком виртуальной машины Java запрещено (кроме операций push и pop для фреймов), фреймы могут быть также расположены в куче. Участок памяти для стека виртуальной машины Java не обязательно должен быть непрерывным. 
<br><br>
::Примечание. В первой редакции данной спецификации стек виртуальной машины Java назывался просто ''стеком Java''.
<br>
Спецификация позволяет реализовать стек виртуальной машины Java фиксированного размера либо динамического размера: расширяемого и сужаемого по мере работы. Если стек виртуальной машины Java фиксированного размера, то размер стека для каждого потока может быть выбран независимо в момент создания стека.
<br><br>
::Примечание. Реализация виртуальной машины Java может позволить разработчику или пользователю управлять тачальным размером стека виртуальной машины, так же как и в случае динамически изменяемого размера, виртуальная машина позволяет задать минимальное и максимальное значение размера стека. 
<br>
В следующих случаях виртуальная машина Java формирует исключение при работе со стеком:

* Если вычисления в потоке требуют памяти более чем позволено размером стека, виртуальная машина Java формирует исключение <code>StackOverflowError</code>. 
* Если стек виртуальной машины Java допускает динамическое увеличение размера и попытка такого увеличения была выполнена, однако вследствие нехватки памяти не завершена успешно либо не достаточно памяти при инициализации стека при создании потока, то виртуальная машина Java формирует исключение <code>OutOfMemoryError</code>.

==== Куча ====

Виртуальная машина Java содержит область памяти, называемую ''кучей'', которая находится в пользовании всех потоков виртуальной машины. Куча – это область памяти времени выполнения, содержащая массивы и экземпляры всех классов.

Куча создаётся при запуске виртуальной машины Java. Удаление неиспользуемых объектов в куче производится системой автоматического управления памятью (известной как ''сборщик мусора''); объекты никогда не удаляются явно. Виртуальная машина Java не предполагает какого-либо одного алгоритма для системы автоматического управления памятью; алгоритм может быть произвольно задан разработчиком виртуальной машины в зависимости от системных требований. Куча может быть фиксированного размера, либо динамически расширяться и сужаться при удалении объектов. Участок памяти для кучи виртуальной машины Java не обязательно должен быть непрерывным.
<br><br>
::Примечание. Реализация виртуальной машины Java  позволяет разработчику или пользователю управлять начальным размером кучи, так же как и в случае динамически изменяемого размера, виртуальная машина позволяет задать минимальное и максимальное значение размера кучи.
<br>
В следующих случаях виртуальная машина Java формирует исключение при работе с кучей:

* Если вычисления требуют памяти более, чем может выделить автоматическая система управления памятью, виртуальная машина Java формирует исключение <code>OutOfMemoryError</code>.

==== Область методов ====

Виртуальная машина Java содержит область памяти, называемую ''областью методов'', которая находится в пользовании всех потоков виртуальной машины. Область методов аналогична хранилищу скомпилированного кода в традиционных языках программирования или области памяти «текстовый сегмент» в процессе операционной системы. Область методов хранит принадлежащие классам структуры, такие как хранилище констант (константный пул), данные полей и методов, код методов и конструктор включая специальные методы, а также код инициализации экземпляров и интерфейсов.  

Область методов создаётся при запуске виртуальной машины. Хотя область методов логически принадлежит куче, в простых реализациях виртуальной машины допустимо не сокращать область методов и не использовать для нее сборщик мусора. Эта спецификация виртуальной машины Java не задаёт однозначного расположения или политики управления памятью для скомпилированного кода. Область методов может быть фиксированного размера, либо динамически расширяться и сужаться при необходимости. Участок памяти для области методов виртуальной машины Java не обязательно должен быть непрерывным.
<br><br>
::Примечание. Реализация виртуальной машины Java может позволить разработчику или пользователю управлять начальным размером области методов, так же как и в случае динамически изменяемого размера, виртуальная машина позволяет задать минимальное и максимальное значение размера области методов.
<br>
В следующих случаях виртуальная машина Java формирует исключение при работе с областью методов:

* Если работа программы требуют памяти более, чем может выделить автоматическая система управления памятью, виртуальная машина Java формирует исключение <code>OutOfMemoryError</code>.

==== Хранилище констант времени выполнения (константный пул) ====

Хранилище констант времени выполнения это связанное с классом или интерфейсом представления времени выполнения  таблицы <code>constant_pool</code> файла <code>class</code>. Представление содержит несколько разновидностей констант, начиная от числовых литералов, известных на этапе компиляции до ссылок в членах-данных класса и методах, разрешить которые необходимо во время выполнения. Хранилище констант времени выполнения выполняет ту же функцию, что и таблица символов в традиционных языках программирования, хотя хранилище и содержит данные в гораздо более широком диапазоне, чем просто символьная таблица.

Каждое хранилище констант времени выполнения расположено в области методов виртуальной машины Java. Хранилище констант времени выполнения класса или интерфейса создаётся, когда класс или интерфейс создаётся виртуальной машиной Java.

В следующих случаях виртуальная машина Java формирует исключение при работе с хранилище констант времени выполнения:

* Если при создании класса или интерфейса хранилище констант времени выполнения требуют памяти более, чем доступно для виртуальной машины Java, виртуальная машина Java формирует исключение <code>OutOfMemoryError</code>.
<br>
::Примечание. Более подробную информацию по созданию хранилища констант времени выполнения см. в главе 5.
<br>

==== Стеки Native методов ====

Реализация виртуальной машины Java позволяет использовать традиционные стеки, коротко называемые "С стеками" (от англ. conventional - традиционный - ''прим. перев.'') для поддержки <code>native</code> методов (методов, написанных на языках, отличных от Java). Те реализации виртуальной машины Java, которые не могут загружать <code>native</code> методы и таким образом не используют традиционные стеки, не нуждаются также и в поддержке стеков  <code>native</code> методов.
 
Эта спецификация позволяет стекам <code>native</code> методов быть фиксированного размера, либо динамически расширяться и сужаться при необходимости. Если стеки <code>native</code> методов фиксированного размера, то их размер задаётся в момент создания стека и не зависит от размеров других стеков.
<br><br>
::Примечание. Реализация виртуальной машины Java  позволяет разработчику или пользователю управлять начальным размером стеков <code>native</code> методов в случае их фиксированного размера так же, как и в случае динамически изменяемого размера, виртуальная машина позволяет задать минимальное и максимальное значение размера стеков <code>native</code> методов.
<br>
В следующих случаях виртуальная машина Java формирует исключение при работе со стеками <code>native</code> методов:

*Если вычисления в потоке требуют памяти более чем позволено размером стека <code>native</code> методов, виртуальная машина Java формирует исключение <code>StackOverflowError</code>. 
*Если стек виртуальной машины Java допускает динамическое увеличение размера и попытка такого увеличения была выполнена, однако вследствие нехватки памяти не завершена успешно либо не достаточно памяти при инициализации стека native методов при создании потока, то виртуальная машина Java формирует исключение <code>OutOfMemoryError</code>.

=== Фреймы ===

''Фреймы'' используются как хранения данных и промежуточных результатов  так и для организации динамического связывания, возвращения значений из методов, управления исключениями. 

Новый фрейм создаётся, когда происходит вызов метода. Фрейм уничтожается, когда вызов метода завершён вне зависимости от того было или завершение метода успешным или аварийным (метод выбросил не перехваченное исключение). Фреймы хранятся в стеке потока виртуальной машины Java, создающего эти фреймы. Каждый фрейм содержит свой массив локальных переменных (см. §2.5.2), свой стек операндов (см. §2.6.2), ссылку на хранилище констант времени выполнения (см. §2.5.5) текущего класса текущего метода.
<br><br>
::Примечание. Дополнительно во фрейме может храниться информация специфическая для каждой реализации виртуальной машины, например, отладочная информация.
<br>
Размер массива локальных переменных и стека операндов определяется во время компиляции и хранится вместе с кодом метода, связанного с фреймом. Поэтому размер структур данных, хранящихся во фрейме, зависит только от реализации виртуальной машины Java; память для этих структур выделяется одновременно с вызовом метода.

Только один фрейм активен в каждый момент времени для каждого потока - фрейм, исполняемого в данный момент метода. Такой фрейм называется ''текущим фреймом'', а метод - ''текущим методом''. Класс, которому принадлежит текущий метод, называется ''текущим классом''.
 
Операции над локальными переменными и операнды в стеке обычно ссылаются на текущий фрейм. 
Фрейм перестаёт быть текущим, если связанный с ним метод вызывает другой метод или текущий метод завершает своё выполнение. Когда метод вызывается, то создаётся новый фрейм, который становится текущим при передаче управления вызываемому методу. Когда метод завершает своё выполнение, текущий фрейм передаёт результаты выполнения (если таковые имеются) предыдущему фрейму. После этого текущий фрейм уничтожается, а предыдущий фрейм становится текущим. 

Обратите внимание, что фрейм, созданный потоком, виден только потоку-владельцу и для других потоков не доступен.


==== Локальные переменные ====

Каждый фрейм содержит массив переменных, известных как ''локальные переменные''. Длина массива локальных переменных каждого фрейма определяется на этапе компиляции; массив хранится в двоичном представлении класса или интерфейса совместно с кодом метода, связанного с фреймом. 

Каждая локальная переменная может содержать значения следующих типов: <code>boolean</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>reference</code>, или <code>returnAddress</code>. Пара локальных переменных может содержать значение типа <code>long</code> или <code>double</code>.

Доступ к локальным переменным осуществляется по индексу. Индекс первой локальной переменной равен нулю. Целое число является индексом локальной переменной тогда и только тогда, когда это число находится в пределах от нуля до строго меньше размера массива переменных. 

Переменные типа <code>long</code> или  <code>double</code> хранятся в двух следующих друг за другом локальных переменных. Получить доступ к такому значению, можно используя индекс младшей переменной. Например, значение типа <code>double</code> хранящееся в локальной переменной с индексом ''n'', на самом деле занимает локальные переменные с индексами ''n'' и ''n'' +1; однако значение локальной переменной с индексом ''n'' +1 не может быть загружено отдельно. Оно используется только для хранения. Также не может быть использовано отдельно значения локальной переменной с индексом ''n''.

Виртуальная машина Java не требует, чтобы ''n'' было чётным. Говоря переносно, значения переменных с типами <code>long</code> и <code>double</code> не обязательно должны начинаться в памяти с адресов, кратных 64-м битам. Разработчик самостоятельно выбирает способ размещения таких значений в двух локальных переменных, зарезервированных для этого.
 
Виртуальная машина Java использует локальные переменные для передачи параметров при вызове метода. При вызове метода принадлежащего классу все параметры передаются последовательно, начиная с локальной переменной с индексом ''0''.  При вызове метода экземпляра локальная переменная ''0'' всегда используется для передачи ссылки на объект, чей метод вызывается в данный момент. (<code>this</code>  в языке программирования Java). Остальные параметры передаются в локальные переменные, начиная с переменной ''1''.

==== Стек операндов ====

Каждый фрейм содержит стек операндов, организованный по принципу «последним пришёл, первым ушёл» (анг. LIFO, last-in-first-out – ''прим. перев.'') Максимальная глубина стека операндов определяется во время компиляции; значение глубины хранится совместно с кодом, связанным с фреймом (см. §4.7.3).
Там где это ясно из контекста, мы иногда будем называть стек операндов текущего фрейма просто стеком операндов.

Сразу после создания фрейма стек операндов советующего фрейма пуст. Виртуальная машина Java предоставляет инструкции загрузки констант или значений из локальных переменных или полей в стек операндов. Другие инструкции виртуальной машины Java получают операнды из стека, обрабатывают их, и записывают результат обратно в стек операндов. Стек операндов также используется для подготовки параметров для передачи в методы и получения результатов выполнения метода.

Например, инструкция ''iadd'' складывает два значения типа <code>int</code>. Для ее работы необходимо, чтобы два значения типа <code>int</code>, записанные предыдущими инструкциями,   были на вершине стека операндов. Два значения типа <code>int</code> считываются из стека операндов. Они складываются, и их сумма записывается обратно в стек операндов. Промежуточные вычисления могут храниться в стеке операндов и использоваться в последующих вычислений. 

Каждый элемент стека операндов может хранить все значения из списка поддерживаемых виртуальной машиной Java типов, включая <code>long</code> и <code>double</code>. 

Все операции со значениями стека операндов нужно проводить в соответствии с их типом. Невозможно, к примеру, поместить два значения типа <code>int</code> работать с ними как с типом <code>long</code> или поместить два значения типа <code>float</code> и сложить их инструкцией ''iadd''. Небольшое количество инструкций виртуальной машины Java (таких как ''dup'' или ''swap'') работают с данными времени выполнения как с «сырыми» значениями без учета их типов; эти инструкции разработаны так, что они не могут повредить или модифицировать значения. Эти ограничения на манипуляции со стеком операндов вызваны проверками в <code>class</code> файле.  

В любой момент времени стек операндов имеет определенною глубину, причем значения с типами <code>long</code> и <code>double</code> занимают две единицы памяти стека, остальные типы занимают по одной единице памяти стека.

==== Динамическое связывание ====

Чтобы реализовать ''динамическое связывание'' кода метода,  каждый фрейм (см. §2.6)  содержит ссылку на тип текущего метода в хранилище констант времени выполнения (см. §2.5.5). Код в <code>class</code> файле метода ссылается на те методы, которые необходимо будет вызвать и те переменные, доступ к которым нужно получить по символьным ссылкам. Динамическое связывание преобразует ссылки на методы в виде символов исходного кода на Java в реальные ссылки, при необходимости загружая классы для тех ссылок, которые еще не определены; переменные исходного кода преобразуются в соответствующие ссылки  в структурах данных, связанных с этими переменными. 

Позднее связывание методов и переменных позволяет писать код более устойчивый к изменениям.

==== Нормальное завершение вызова метода ====


Вызов метода ''завершается нормально'', если вызов не приводит к возникновению исключения (см. §2.10), причём, неважно будет ли исключение вызвано непосредственно из виртуальной машины Java либо явным вызовом оператора <code>throw</code>. Если вызов метода завершается нормально, в вызывающий метод может быть передано значение. Это происходит, когда вызываемый метод выполняет одну из инструкций возврата (см. §2.11.8); какую именно – зависит от типа возвращаемого значения (если вообще таковое имеется).

Текущий фрейм (см. §2.6) в этом случае используется для восстановления вызывающего метода, включая состояние локальных переменных и стека операндов; программный счётчик вызывающего метода соответственно увеличивается, чтобы избежать повторного вызова метода, который только что был вызван. Управление успешно передается в код фрейма вызывающего метода; результат выполнения (если таковой имеется) записывается в стек операндов вызывающего метода.

==== Аварийное завершение вызова метода ====

Вызов метода ''завершается аварийно'', если выполнение инструкций виртуальной машины Java находящихся в теле метода приводит к тому, что виртуальная машина формирует исключение и это исключение не перехвачено в методе. Выполнение любой инструкции ''athrow'' (см. ''athrow'') также приводит к явному формированию исключения, и если исключение не перехвачено текущим методом, то метод завершается аварийно. Метод, завершившийся аварийно никогда не возвращает значения в вызывающий метод.

=== Представление объектов ===

Виртуальная машина Java не обязывает разработчика к какой-либо определённой внутренней структуре объектов. 
<br><br>
::Примечание. В некоторых реализациях виртуальной машины Java выполненных компанией Oracle, ссылка на класс представляет собой ссылку на ''обработчик'', который сам по себе состоит из пары ссылок: одна указывает на таблицу методов объекта, содержащую также ссылку на объект <code>Class</code> представляющий тип объекта, а другая на область данных в куче, содержащую члены-данные объекта. 
<br>

=== Арифметика чисел с плавающей точкой ===

Виртуальная машина Java реализует множество правил арифметики чисел с плавающей точкой, которое является подмножеством правил стандарта ''IEEE Standard for Binary Floating-Point Arithmetic'' (ANSI/IEEE Std. 754-1985, New York)

==== Арифметика чисел с плавающей точкой виртуальной машины Java и стандарт IEEE 754 ====

Ключевыми отличиями Арифметики чисел с плавающей точкой виртуальной машины Java и стандарта IEEE 754 являются:

* Операции с плавающей точкой виртуальной машины Java не формируют исключений, захватов или других сигналов определённых стандартом IEEE 754 сообщающих об исключительной ситуации: неверная операция, деление на ноль, переполнение, исчезновение значащих разрядов, потеря точности. Виртуальная машина Java не сигнализирует специальным образом о том, что в ходе вычислений получено NaN значение. 
* Виртуальная машина Java не использует механизм сигнализирования при сравнении чисел с плавающей точкой.
* Операции округления в виртуальной машине Java  всегда используют режим округления к ближайшему числу стандарта IEEE 754. Неточные результаты вычислений округляются к ближайшему представимому значению, путём сложения старшего бита остатка с младшим значащим битом неокругленного целого. Это стандартный режим округления IEEE 754. Но инструкции виртуальной машины Java преобразующие типы с плавающей точкой к целочисленным типам всегда округляют в направлении нуля. Виртуальная машина Java не предоставляет никаких средств управления режимом округления чисел с плавающей точкой.
* Виртуальная машина Java не поддерживает ни расширенного формата одинарной точности, ни расширенного формата двойной точности определяемых стандартом IEEE 754 за исключением того,  что насколько это допустимо наборы значений двойной точности и двойной точности с расширенной экспонентой могут рассматриваться как реализация расширенного формата одинарной точности. Элементы множества значений чисел с плавающей точкой с расширенной экспонентой с одинарной и двойной точностью  ''не соответствуют'' значениям, представленным в стандарте IEEE 754 расширенным форматом одинарной точности и расширенным форматом двойной точности соответственно: стандарт IEEE 754 требует не только увеличения пределов значения экспоненты, но увеличения точности (увеличения числа значащих битов мантиссы – ''прим. перев.'')

==== Режимы работы с плавающей точкой ====

Для  каждого метода каждого класса определён ''режим работы с плавающей точкой'', который может быть ''FP-strict'' или  ''не FP-strict''.  Режим работы с плавающей точкой задается установкой флага <code>ACC_STRICT</code> набора <code>access_flags</code> структуры <code>method_info</code> (см §4.6) определяющей метод. Метод, для которого это флаг установлен, использует режим FP-strict; иначе использует режим не FP-strict.
<br><br>
::Примечание. Обратите внимание, что эта трактовка значений флага <code>ACC_STRICT</code> подразумевает, что методы скомпилированные в JDK release 1.1 или ранее фактически не FP-strict.
<br>
Мы ссылаемся на стек операндов, считая, что режим работы с плавающей точкой  уже задан;  стек операндов  содержится во фрейме, созданном при вызове метода, а структура метода (<code>method_info</code> – ''прим. перев.'') содержит определение режима. Точно также мы говорим об инструкции виртуальной машины Java, имеющей определённый режим работы с плавающей точкой, поскольку инструкция принадлежит методу, а для метода задан такой режим.

Если числа с плавающей точкой с расширенной экспонентой с одинарной точностью поддерживаются (см. §2.3.2), значения типа <code>float</code> в стеке операндов, не являющиеся FP-strict могут превосходить значения с режимом FP-strict, кроме случаев запрещённых правилами преобразования множества значений (см. §2.8.3). Если числа с плавающей точкой с расширенной экспонентой с двойной точностью поддерживаются (см. §2.3.2), значения типа <code>double</code> в стеке операндов, не являющиеся FP-strict могут превосходить значения с режимом FP-strict, кроме случаев запрещённых правилами преобразования множества значений.

==== Правила преобразования множества значений ====

Для реализации виртуальной машины Java, которая поддерживает числа с расширенной экспонентой, допустимо или необходимо, в зависимости от обстоятельств, преобразовывать значения чисел с расширенной экспонентой к значениям чисел со стандартной экспонентой. Такое ''преобразование множества значений'' не является преобразованием типов, но лишь преобразование значений в пределах одного и того же типа.

Когда необходимо выполнить преобразование множеств значений, допустимо выполнять следующие операции над значениями:

* Если значение типа <code>float</code> и не принадлежит стандартному набору значений, оно округляется до ближайшего из элементов стандартного набора. 
* Если значение типа <code>double</code> и не принадлежит стандартному набору значений, оно округляется до ближайшего из элементов стандартного набора.

В дополнение к выше сказанному при необходимости выполнить преобразование множеств значений, выполняются следующие операции:

* Предположим выполнение инструкции виртуальной машины Java, являющейся не FP-strict, привело к тому, что значения типа <code>float</code> помещено в стек операндов, который является FP-strict либо как параметр метода, либо как локальная переменная, поле класса или элементе массива.  Если значение  не принадлежит стандартному набору значений, оно округляется до ближайшего из элементов стандартного набора.
* Предположим выполнение инструкции виртуальной машины Java, являющейся не FP-strict, привело к тому, что значения типа <code>double</code> помещено в стек операндов, который является FP-strict либо как параметр метода, либо как локальная переменная, поле класса или элементе массива.  Если значение  не принадлежит стандартному набору значений, оно округляется до ближайшего из элементов стандартного набора.

Не все значения с расширенной экспонентой могут быть точно преобразованы стандартные значения. Если значение, которое нужно преобразовать, слишком велико, чтобы быть представленным точно (его экспонента больше чем может храниться в стандартном наборе), то оно преобразовывается в бесконечность (положительную или отрицательную) соответствующего типа. Если значение, которое нужно преобразовать, слишком мало, чтобы быть представленным точно (его экспонента меньше чем может храниться в стандартном наборе), то оно округляется к ближайшему допустимому денормализованному значению или нулю того же знака.

Правила преобразования множества значений сохраняют бесконечности и не-числа (NaN) и не могут изменить знак преобразуемого значения. Правила преобразования множества значений относятся к значениям, только принадлежащим типам с плавающей точкой.

=== Специальные методы ===

На уровне виртуальной машины Java, каждый конструктор, написанный на языке программирования Java, представляет собой ''инициализирующий метод экземпляра'', у которого есть специальное имя <code><init></code>. Это имя формирует компилятор.  Поскольку имя <code><init></code> не является действительным идентификатором, его невозможно непосредственно использовать в языке программирования Java. Инициализирующий метод экземпляра может быть вызван только виртуальной машиной Java с помощью инструкции ''invokespecial'', и этот метод может быть вызван только для уже инициализированного экземпляра класса. Инициализирующий метод экземпляра имеет те же права доступа, что и конструктор, от которого он был произведён.

Класс или интерфейс имеет как минимум один  ''инициализирующий метод класса или экземпляра'' соответственно; инициализация класса или интерфейса происходит путём вызова инициализирующего метода. Такой метод имеет специальное имя <code><clinit></code>, не имеет аргументов и является <code>void</code> (см. §4.3.3). 
<br><br>
::Примечание. Если в <code>class</code> файле есть несколько методов с именем <code><clinit></code>, то действителен только один – другие не имеют смысла. Их нельзя вызвать ни одной из инструкций виртуальной машины Java и сама виртуальная машина Java их никогда не вызывает.
<br>
В <code>class</code> файле с версией 51.0 или выше метода должен иметь флаг <code>ACC_STATIC</code> с установленным значением, для того чтобы метод был инициализирующим методом класса или интерфейса.
<br><br>
::Примечание. Это требование введено в Java SE 7. В <code>class</code> файле, чья версия 50.0 или ниже метод с именем <code><clinit></code>, имеющий тип <code>void</code> и не имеющий аргументов, рассматривается как инициализирующий метод класса или интерфейса вне зависимости от установленного флага <code>ACC_STATIC</code>. 
<br>
Имя <code><clinit></code> формирует компилятор.  Поскольку имя <code><init></code> не является действительным идентификатором, его невозможно непосредственно использовать в языке программирования Java. Инициализирующий метод класса или интерфейса неявным образом вызывается виртуальной машиной Java; его невозможно вызвать непосредственно по инструкции виртуальной машины Java, но он неявно вызывается в процессе инициализации класса.

Метод считается ''сигнатурно полиморфным'', тогда и только тогда, когда выполнены следующие условия:

* Метод объявлен в классе <code>java.lang.invoke.MethodHandle</code>.
* Метод имеет только один формальный параметр типа <code>Object[]</code>.
* Метод возвращает значения типа <code>Object</code>.
* Для метода установлены флаги <code>ACC_VARARGS</code> и <code>ACC_NATIVE</code>. 

<br>
::Примечание. В Java SE 7 сигнатурно полиморфными методами являются методы <code>invoke</code> и <code>invokeExact</code> класса <code>java.lang.invoke.MethodHandle</code>. 
<br>
Виртуальная машина Java по-особому выполняет сигнатурно полиморфные методы с помощью инструкции ''invokevirtual'' для того чтобы обеспечить вызов ''обработчика методов''. Обработчик методов – это типизированная, непосредственно исполняемая ссылка на связанный метод, конструктор, поле или на подобную низкоуровневую операцию (см. §5.4.3.5); опционально обработчик методов позволяет преобразовывать входные параметры или возвращаемые значения. Эти преобразования достаточно общие и включают такие шаблоны как преобразование типов, вставка, удаление и замещение. Более подробную информацию см. в документации пакета <code>java.lang.invoke</code>.

=== Исключения ===

Исключения в виртуальной машине Java представлены экземплярами класса <code>Throwable</code> или одного из его наследников. Выброс исключения в программном коде приводит к немедленной нелокальной передаче управления из точки, в которой исключение было сформировано. 

Большинство исключений синхронные, т.е. выбрасываются сразу после определённой операции в потоке выполнения. В отличие от асинхронных исключений, которые могут возникнуть в любой момент времени в ходе выполнения программы. Виртуальная машина Java выбрасывает исключение в трех случаях:

* Выполнена инструкция ''athrow''.
* В ходе выполнения инструкций виртуальная машина Java обнаружила условия, приводящие к аварийной ситуации. Этот тип исключений не возникает в произвольной точке кода, а формируется сразу после обнаружения аварийной ситуации и имеет строгую привязку к инструкциям, которые либо:
** Определяют исключение в качестве возможного результата выполнения:
*** Когда инструкция представляет собой операцию, нарушающую семантику языка программирования, например выход индекса за границы массива.
*** Когда возникает ошибка при загрузке или связывании частей программы.
** Приводят к нарушению ограничений, накладываемых на ресурсы, например, использование слишком большого количества памяти.
* Возникло асинхронное исключение по следующим причинам:
** Вызван метод <code>stop</code> класса <code>Thread</code> или <code>ThreadGroup</code>.
** Возникла внутренняя ошибка, связанная с реализацией виртуальной машины Java. 

Метод <code>stop</code> может быть вызван одним потоком, чтобы остановить другой поток или все потоки в определённой группе потоков. Эти исключения асинхронны, поскольку могут произойти в любой момент выполнения потока или потоков. Внутренняя ошибка Java машины также считается асинхронной (см. §6.3).

Виртуальная машина Java позволяет выполнять небольшое число дополнительных операций, перед тем как асинхронное исключение будет выброшено. Задержка, вызванная выполнением дополнительных операций, оправдана тем, что  оптимизированный код может обнаружить и выбросить эти исключения в точках, где целесообразно обработать их в соответствии с правилами семантики языка программирования Java. 
<br><br>
::Примечание. Простая реализация виртуальной машины последовательно проверяет условия для всех асинхронных исключений для каждой инструкции передачи управления. Поскольку программа имеет конечный размер, это определяет верхнюю границу интервала времени общей задержки, вызванной проверкой возникновения асинхронных исключений. Поскольку асинхронные исключения не возникают между инструкциями передачи управления, для генераторов кода допустима гибкость в изменении порядка операций между инструкциями передачи управления для улучшения производительности кода. Для более подробного ознакомления с вопросом рекомендуем статью Марка Фили ''Polling Efficiently on Stock Hardware by Marc Feeley,  Proc. 1993 Conference on Functional Programming and Computer Architecture'', Copenhagen, Denmark, pp. 179–187.
<br>
Исключения, выбрасываемые виртуальной машиной Java, сохраняют целостность данных в следующем смысле: когда происходит передача управления вследствие формирования исключения, то результаты выполнения всех инструкций вплоть до точки возникновения исключения доступны виртуальной машине. Инструкции, находящиеся после точки возникновения исключения не выполняются и не влияют на результат вычислений. Если оптимизатор кода неявно вычислил инструкции, которые следуют после точки возникновения исключения, он должен позаботиться о том, чтобы отменить их влияние на текущее состояние программы. 

С каждым методом в виртуальной машине Java может быть связано от нуля и более ''обработчиков исключений''. Обработчик исключения определяет величину смещения в машинном коде, указывая на тот метод, которому принадлежит исключения, описывает тип исключений, которые обработчик может обработать, и определяет положение  первой инструкции кода метода для обработки исключений. Исключение соответствует обработчику исключений, если смещение инструкции, которая вызвала исключение, находится в пределах смещений обработчика исключений и тип исключения является классом или наследником класса исключения, которое может обрабатывать обработчик. Когда выбрасывается исключение, то виртуальная машина Java ищет соответствующий обработчик исключения в текущем методе. Если подходящий обработчик найден, то система переходит к выполнению кода, указанного в обработчике исключений.

Если в текущем методе не найдено подходящего обработчика исключений, выполнение текущего метода завершается аварийно (см. §2.6.5). При аварийном завершении работы метода стек операндов, и локальные переменные теряются, текущий фрейм удаляется из стека фреймов, затем текущим фреймом становится фрейм вызывающего метода. После этого исключение выбрасывается повторно, но уже в контексте фрейма вызывающего метода и так далее, по цепи вызовов методов. Если подходящего обработчика исключений так и не было найдено, прежде чем достигнута вершина цепи вызовов методов, то поток, в котором было выброшено исключение прекращает свою работу.  

Порядок, в котором производится поиск обработчиков исключений, имеет значение. Внутри  <code>class</code> файла обработчики исключений для каждого метода хранятся в таблице (см. §4.7.3). Во время работы программы, когда выброшено исключение, виртуальная машина Java производит поиск обработчиков исключений в текущем методе в порядке, в котором они записаны в соответствующей таблице в <code>class</code> файле, начиная с начала таблицы.  

Обратите внимание, что виртуальная машина Java не накладывает ограничений на порядок следования обработчиков исключений в таблице. Соответствие порядка следования обработчиков исключений семантике языка Java обеспечивается только компилятором (см. §3.12). В случае, если <code>class</code> файл генерируется не компилятором, а другими средствами, процедура поиска гарантирует, что все реализации виртуальной машины будут одинаково обрабатывать таблицу обработчиков исключений.

=== Обзор инструкций ===

Набор инструкций виртуальной машины Java состоит из ''кода операции'', за которым следует ноль или более ''операндов'', аргументы операции или данные, используемые операцией. Большое количество инструкций вообще не имеют операндов и состоят только из кода операции.

Без учёта исключений внутренний цикл интерпретатора виртуальной машины Java работает следующим образом:

 do {
 автоматически вычислить значение регистра pc  и извлечь код операции по адресу pc;
 if (есть операнды у операции?) извлечь операнды;
 выполнить операцию с извлечённым кодом и операндами;
 } while (есть еще операции?);

Количество и размер операндов определяется кодом операции. Если размер операнда превышает один байт, то он хранится в ''обратном порядке'': сначала старший байт, затем младший. Например, беззнаковый 16-ти битный индекс локальной переменной хранится как два беззнаковых байта, ''байт1'' и ''байт2'', так что значение адреса вычисляется следующим образом: (''байт1'' << 8)| ''байт2''.
 
Коды инструкций (байт-код) выровнены побайтово. Есть два исключения из этого правила: инструкции ''lookupswitch'' и  ''tableswitch'', которые дополнительно требуют 4-х байтового выравнивания своих операндов. 
<br><br>
::Примечание. Решение ограничить размер кода операции одним байтом и отказаться от выравнивания данных скомпилированного кода отражает желание сделать код более компактным, возможно за счёт скорости его работы в командах реального процессора. Размер кода операции в один байт также ограничивает количество операций. Отказ от выравнивания большего, чем один байт, означает, что данные размером больше байта конструируются из байтов во время выполнения программы.
<br>

==== Типы данных и виртуальная машина Java ====

Большинство инструкций виртуальной машины Java содержат в своём названии описание типа данных, с которым они работают. Например, инструкция ''iload'' загружает содержимое локальной переменной, которая должна быть типа <code>int</code> в стек операндов. Инструкция ''fload'' делает то же самое для значения типа <code>float</code>. Эти две инструкции делают одно и то же (отличие лишь в типах данных), но имеют разные коды операций.

Для большинства типизированных инструкций, её тип можно узнать по букве в мнемоническом обозначении кода операции: ''i'' для операций  над типом <code>int</code>, ''l'' для <code>long</code>, ''s'' для  <code>short</code>, ''b'' для  <code>byte</code>,  ''c'' для  <code>char</code>,  ''f'' для  <code>float</code>,  ''d'' для  <code>double</code>, и  ''a'' для  <code>reference</code>. Некоторые инструкции, тип которых определяется однозначно из самой инструкции, не имеют буквы указателя типа в своём мнемоническом обозначении. На пример ''arraylength'' всегда  оперирует с массивами и ничем иным. Некоторые инструкции, такие как ''goto'' – безусловная передача управления – вообще не требуют типизированных операндов.

Существующее в виртуальной машине Java ограничение на размер кода операции в один байт существенно влияет на содержимое набора команд. Если каждая типизированная инструкция будет поддерживать все типы данных времени выполнения виртуальной машины Java, то количество инструкций превысит то, которое можно хранить в одном байте. Вместо этого набор инструкций виртуальной машины Java ограничивает число операций для каждого типа. Другими словами набор инструкций был умышленно сделан не ортогональным по отношению к существующим типам. Существует класс инструкций для перевода одних типов в другие используемый для выполнения операций над неподдерживаемыми типами. 

В таблице 2.2 приведены инструкции и типы данных, которые они поддерживают. Конкретную инструкцию с информацию о типе операнда можно получить, заменяя символ ''T''  в шаблоне мнемонического обозначения операции (см.  колонку операционных кодов)  на тип из колонки типов. Например,  существует инструкция ''iload'' загрузки значений типа <code>int</code>, но нет аналогичной инструкции для типа <code>byte</code>.

Обратите внимание, что для целочисленных типов <code>byte</code>, <code>char</code> и <code>short</code> большинство инструкций в таблице 2.2 отсутствует. А операций с типом <code>boolean</code> вообще нет. Компилятор осуществляет загрузку данных с типами <code>byte</code> и <code>short</code>, используя инструкции виртуальной машины Java, которые расширяют с учетом знака значения указанных типов к типу <code>int</code> во время компиляции или выполнения программы. Загрузка литералов с типами <code>boolean</code> и <code>char</code> выполняется с использованием инструкций виртуальной машины Java, которые расширяют значения указанных типов (предварительно обнулив знак в значении типа <code>int</code>, т.н. нулевое расширение – ''прим. перев.'') к типу <code>int</code> во время компиляции или выполнения программы. Точно также загрузка значений из массивов с типами <code>boolean</code>, <code>byte</code>, <code>short</code>, и <code>char</code> осуществляется посредством знакового или нулевого расширения указанных типов к <code>int</code> и последующей работе этим типом. Поэтому большинство операций над значениями с типами <code>boolean</code>,  <code>byte</code>, <code>char</code> и <code>short</code> выполняется через преобразование к типу <code>int</code> и дальнейшее выполнение соответствующей операции.

'''Таблица 2.2 Поддержка типов в операциях виртуальной машине Java'''
{| class="wikitable"
! Код операции
! byte
! short
! int
! long
! float
! double
! char
! reference
|-
| ''Tipush''
| ''bipush''
| ''sipush''
| 
| 
| 
| 
| 
| 
|-
| ''Tconst''
| 
| 
| ''iconst''
| ''lconst''
| ''fconst''
| ''dconst''
| 
| ''aconst''
|-
| ''Tload''
| 
| 
| ''iload''
| ''lload''
| ''fload''
| ''dload''
| 
| ''aload''
|-
| ''Tstore''
| 
| 
| ''istore''
| ''lstore''
| ''fstore''
| ''dstore''
| 
| ''astore''
|-
| ''Tinc''
| 
| 
| ''iinc''
| 
| 
| 
| 
| 
|-
| ''Taload''
| ''baload''
| ''saload''
| ''iaload''
| ''laload''
| ''faload''
| ''daload''
| ''caload''
| ''aaload''
|-
| ''Tastore''
| ''bastore''
| ''sastore''
| ''iastore''
| ''lastore''
| ''fastore''
| ''dastore''
| ''castore''
| ''aastore''
|-
| ''Tadd''
| 
| 
| ''iadd''
| ''ladd''
| ''fadd''
| ''dadd''
| 
| 
|-
| ''Tsub''
| 
| 
| ''isub''
| ''lsub''
| ''fsub''
| ''dsub''
| 
| 
|-
| ''Tmul''
| 
| 
| ''imul''
| ''lmul''
| ''fmul''
| ''dmul''
| 
| 
|-
| ''Tdiv''
| 
| 
| ''idiv''
| ''ldiv''
| ''fdiv''
| ''ddiv''
| 
| 
|-
| ''Trem''
| 
| 
| ''irem''
| ''lrem''
| ''frem''
| ''drem''
| 
| 
|-
| ''Tneg''
| 
| 
| ''ineg''
| ''lneg''
| ''fneg''
| ''dneg''
| 
| 
|-
| ''Tshl''
| 
| 
| ''ishl''
| ''lshl''
| 
| 
| 
| 
|-
| ''Tshr''
| 
| 
| ''ishr''
| ''lshr''
| 
| 
| 
| 
|-
| ''Tushr''
| 
| 
| ''iushr''
| ''lushr''
| 
| 
| 
| 
|-
| ''Tand''
| 
| 
| ''iand''
| ''land''
| 
| 
| 
| 
|-
| ''Tor''
| 
| 
| ''ior''
| ''lor''
| 
| 
| 
| 
|-
| ''Txor''
| 
| 
| ''ixor''
| ''lxor''
| 
| 
| 
| 
|-
| ''i2T''
| ''i2b''
| ''i2s''
| 
| ''i2l''
| ''i2f''
| ''i2d''
| 
| 
|-
| ''l2T''
| 
| 
| ''l2i''
| 
| ''l2f''
| ''l2d''
| 
| 
|-
| ''f2T''
| 
| 
| ''f2i''
| ''f2l''
| 
| ''f2d''
| 
| 
|-
| ''d2T''
| 
| 
| ''d2i''
| ''d2l''
| ''d2f''
| 
| 
| 
|-
| ''Tcmp''
| 
| 
| 
| ''lcmp''
| 
| 
| 
| 
|-
| ''Tcmpl''
| 
| 
| 
| 
| ''fcmpl''
| ''dcmpl''
| 
| 
|-
| ''Tcmpg''
| 
| 
| 
| 
| ''fcmpg''
| ''dcmpg''
| 
| 
|-
| ''if_TcmpOP''
| 
| 
| ''if_icmpOP''
| 
| 
| 
| 
| ''if_acmpOP''
|-
| ''Treturn''
| 
| 
| ''ireturn''
| ''lreturn''
| ''freturn''
| ''dreturn''
| 
| ''areturn''
|}


Соответствие между действительными типами виртуальной машины Java и типами, используемыми для вычислений, приведено в таблице 2.3.

Определённые инструкции виртуальной машины Java, такие как ''pop'' и  ''swap'' работают со стеком операндов безотносительно к типам операндов; однако такие инструкции ограничены в применении только значениями определённых категорий вычислимых типов, что так же приведено в таблице 2.3.

'''Таблица 2.3 Реальные типы и типы, используемые для вычислений в виртуальной машине Java'''
{| class="wikitable"
! Реальный тип
! Тип для вычислений
! Категория
|-
| <code>boolean</code>
| <code>int</code>
| категория 1
|-
| <code>byte</code>
| <code>int</code>
| категория 1
|-
| <code>char</code>
| <code>int</code>
| категория 1
|-
| <code>short</code>
| <code>int</code>
| категория 1
|-
| <code>int</code>
| <code>int</code>
| категория 1
|-
| <code>float</code>
| <code>float</code>
| категория 1
|-
| <code>reference</code>
| <code>reference</code>
| категория 1
|-
| <code>returnAddress</code>
| <code>returnAddress</code>
| категория 1
|-
| <code>long</code>
| <code>long</code>
| категория 2
|-
| <code>double</code>
| <code>double</code>
| категория 2
|}

==== Инструкции загрузки и считывания ====

Инструкции загрузки и считывания перемещают значения переменных между локальными переменными (см. §2.6.1) стеком операндов (см. §2.6.2) фрейма виртуальной машины Java:

* Загрузить локальную переменную в стек операндов: ''iload'',  ''iload_<n>'',  ''lload'', ''lload_<n>'', ''fload'', ''fload_<n>'', ''dload'', ''dload_<n>'', ''aload, aload_<n>''.
* Считать значение из стека операндов в локальную переменную: ''istore'',  ''istore_<n>'', ''lstore'',  ''lstore_<n>'',  ''fstore'',  ''fstore_<n>'',  ''dstore'',  ''dstore_<n>'',  ''astore'',  ''astore_<n>''.
* Загрузить константу в стек операндов: ''bipush'',  ''sipush'',  ''ldc'',  ''ldc_w'',  ''ldc2_w'', ''aconst_null'', ''iconst_m1'', ''<nowiki>iconst_<i></nowiki>'', ''lconst_<l>'', ''fconst_<f>'', ''dconst_<d>''.
* Получения доступа к новым локальным переменным через расширение количества байт в индексе: ''wide''. 

Инструкции доступа к полям объекта и элементам массива (см. §2.11.5) также перемещают данные в и из стека операндов. 

Для обозначения семейства инструкций, в  мнемонической записи, приведенных выше команд, между угловыми скобками добавлены  спецсимволы; например ''iload_<n>'' означает набор ''iload_0'', ''iload_1'',  ''iload_2'' и ''iload_3''. Такие семейства инструкций (без аргументов) являются частными случаями инструкции ''iload'', у которой только один операнд. Для инструкций, являющихся частным случаем, операнд задан не явно и нет необходимости хранить его где-либо. В остальном смысл инструкций полностью совпадает (например, ''iload_0'' означает то же что и ''iload'' с нулевым операндом). Буква между угловыми скобками определяет тип неявного операнда для семейства инструкций: ''<n>'' - неотрицательное целое, ''<nowiki><i></nowiki>'' для <code>int</code>, ''<l>'' для <code>long</code>, ''<f>'', a <code>float</code> и ''<d>'' для <code>double</code>. Инструкции для типа <code>int</code> часто используются для работы со значениями типа <code>byte</code>, <code>char</code> и <code>short</code> (см. §2.11.1).

Указанная выше нотация для семейств инструкций используется повсеместно в данной спецификации.

==== Арифметические инструкции ====

Арифметическая инструкция, вычисляющая некоторый результат, обычно считывает два значения расположенных на вершине стека операндов, и помещает результат снова в стек. Существуют две основные разновидности арифметических инструкций: оперирующие целыми значениями и оперирующие значениями с плавающей точкой. Нет арифметических операций, работающих непосредственно со значениями типа <code>byte</code>, <code>short</code> и <code>char</code> (см. §2.11.1) или типа <code>boolean</code>; для работы с данными типами используются инструкции, работающие с типом <code>int</code>. 

Целочисленные инструкции и инструкции для работы с числами с плавающей точкой так же отличаются своим поведением при переполнении и делении на ноль. Существуют следующие арифметические инструкции:
* Сложение: ''iadd'', ''ladd'', ''fadd'', ''dadd''.
* Вычитание: ''isub'', ''lsub'', ''fsub'', ''dsub''.
* Умножение: ''imul'', ''lmul'', ''fmul'', ''dmul''.
* Деление: ''idiv'', ''ldiv'', ''fdiv'', ''ddiv''.
* Остаток от деления: ''irem'', ''lrem'', ''frem'', ''drem''.
* Отрицание: ''ineg'', ''lneg'', ''fneg'', ''dneg''.
* Сдвиг: ''ishl'', ''ishr'', ''iushr'', ''lshl'', ''lshr'', ''lushr''.
* Битовое ИЛИ: ''ior'', ''lor''.
* Битовое И: ''iand'', ''land''.
* Битовое исключающее ИЛИ: ''ixor'', ''lxor''.
* Увеличение локальной переменной на единицу: ''iinc''.
* Сравнение: ''dcmpg'', ''dcmpl'', ''fcmpg'', ''fcmpl'', ''lcmp''.

Семантика операторов языка программирования Java над целыми числами и числами с плавающей точкой полностью поддерживается набором инструкций виртуальной машины Java.

Виртуальная машина Java не сообщает о переполнении во время операции над целыми типами данных. Единственные целочисленные операции, которые могут вызвать исключение – это целочисленное деление (''idiv'' и ''ldiv'') и целочисленное вычисление остатка (''irem'' и ''lrem''); они выбрасывают исключение <code>ArithmeticException</code> при делении на ноль. 

Работа инструкций виртуальной машины Java, оперирующих с числами с плавающей точкой, соответствует спецификации IEEE 754. В частности, виртуальная машина Java требует согласно IEEE 754 полной поддержки денормализованных чисел с плавающей точкой и постепенной потери значащих разрядов, что позволяет получить желаемые свойства некоторых численных алгоритмов.

Виртуальная машина Java требует, чтобы арифметические операции с плавающей точкой округляли результат согласно точности, заданной для этого результата. Неточные результаты должны быть округлены к представимому значению, ближайшему к точному результату; если существуют два одинаково близких представимых значения, то выбирается то, которое имеет, по крайней мере, один нулевой значащий бит. Это режим округления по умолчанию в стандарте IEEE 754, известный как режим округления к ближайшему. 

Виртуальная машина Java использует режим округления к нулю стандарта IEEE 754 при преобразовании типов с плавающей точкой к целочисленным типам. Происходит отбрасывание дробной части; все значащие биты дробной части операнда теряются. Режим округления к нулю в качестве результата предоставляет значение ближайшее к абсолютно точному, но не большее по модулю, чем абсолютно точное значение. 

Операции над числами с плавающей точкой виртуальной машины Java не вызывают исключений (не путать с исключениями стандарта IEEE 754 для чисел с плавающей точкой). При переполнении возвращается бесконечность с соответствующим знаком; при потере точности возвращается денормализованное значение или знаковый ноль, а при операциях не определенных с математической точки зрения возвращается не-число (NaN). Все числовые операции с не-числами (NaN) в качестве хотя бы одного операнда возвращают не-число.

Сравнение значений с типом <code>long</code> (''lcmp'') является знаковым сравнением. Сравнение значений для типов с плавающей точкой (''dcmpg'',  ''dcmpl'',  ''fcmpg'',  ''fcmpl'') выполняются как не сигнализирующие сравнения стандарта IEEE 754.

==== Инструкции преобразования типов ====

Инструкции преобразования типов позволяют выполнить преобразования между числовыми типами виртуальной машины Java. Они используются для выполнения явного преобразования типов в пользовательском коде и в качестве компенсации отсутствия ортогональности набора инструкций, имеющихся в  виртуальной машине Java.

Виртуальная машина Java непосредственно поддерживает следующий набор расширяющих числовых преобразований:

* <code>int</code> в <code>long</code>, <code>float</code> или <code>double</code>
* <code>long</code> в <code>float</code> или <code>double</code>
* <code>float</code> в <code>double</code>

Инструкции для расширяющих числовых преобразований следующие: ''i2l'', ''i2f'', ''i2d'',  ''l2f'', ''l2d'' и  ''f2d''. Мнемоническое описание кодов операций состоит из аббревиатуры типа и символа 2, который означает предлог «к» (английский предлог to («к») и числительные two («два») имеют схожее произношение – ''прим. перев.''). Расширяющие числовые преобразования не приводят к потере точности на всем диапазоне числовых величин. На самом деле, расширение от <code>int</code> к <code>long</code> и от <code>int</code> к <code>double</code> вообще не приводит к потере информации; числовые значения полностью сохраняются. Преобразования расширения от <code>float</code> к <code>double</code> для режима работы с плавающей точкой FP-strict (см. §2.8.2) также полностью сохраняют числовые величины; однако преобразования для режима работы с плавающей точкой не FP-strict могут приводить к потере информации для любых числовых величин.

Преобразования от <code>int</code> или <code>long</code> значений к <code>float</code>, либо от <code>long</code> к <code>double</code> могут приводить к потере точности, а именно: потеря младших значащих битов величины; результирующее число с плавающей точкой представляет собой результат округления при использовании режима округления к ближайшему, определённого в IEEE 754. 

Расширяющее числовое преобразования от <code>int</code> к <code>long</code> представляют собой просто знаковое расширение представленного в дополнительном коде значения <code>int</code> к более широкому формату. Расширяющее числовое преобразования от <code>char</code> к целым типам представляет собой беззнаковое расширение (нуль-расширение) типа <code>char</code> к более широким форматам. 

Несмотря на возможную потерю точности, расширяющие числовые преобразования никогда не приводят к исключениям виртуальной машины Java (не путать с исключениями стандарта IEEE 754 для чисел с плавающей точкой)

Обратите внимание, что не существует расширяющих числовых преобразований от целых типов <code>byte</code>, <code>char</code> и <code>short</code> к типу <code>int</code>. Как указано ранее (см. §2.11.1) значения типов  <code>byte</code>, <code>char</code> и <code>short</code> и так хранятся с использованием типа <code>int</code>, так что эти преобразования выполняются неявно и так.

Виртуальная машина Java непосредственно поддерживает следующий набор сужающих числовых преобразований:

* <code>int</code> в <code>byte</code>, <code>short</code> или <code>char</code>
* <code>long</code> в <code>int</code>
* <code>float</code> в <code>int</code> или <code>long</code>
* <code>double</code> в <code>int</code>, <code>long</code> или <code>float</code>

Инструкции для  сужающих числовых преобразований следующие: ''i2b'', ''i2c'', ''i2s'', ''l2i'',  ''f2i'', ''f2l'', ''d2i'', ''d2l'' и ''d2f''. Сужающие числовые преобразования могут вернуть в качестве результата значение с другим знаком, другим порядком величины или то и другое одновременно; поэтому возможна потеря точности.

Сужающее числовое преобразование <code>int</code> или <code>long</code> в некоторый целый тип ''T'' производится путём отбрасывания всех кроме ''N'' старших битов, где ''N'' – число битов, используемых в типе ''T''. Это может привести к тому, что результирующее значение может иметь знак отличный от знака исходного значения. 

При сужающем числовом преобразовании чисел с плавающей точкой в некоторый целый тип ''T'', где ''T'' - <code>int</code> или <code>long</code> выполняется следующее:

* Если значение  с плавающей точкой является не-числом (NaN), то результат преобразования есть 0 с типом <code>int</code> или  <code>long</code>.
* В противном случае, значение  с плавающей точкой не является бесконечностью, оно округляется к целому числу ''V'', используя режим округления к нулю стандарта IEEE 754. При этом возможны два случая:
** Если ''T''  <code>long</code> и данное целое значение ''V'' представимо в типе <code>long</code>, то результат преобразования - целое значение ''V'' типа <code>long</code>.
** Если ''T''  <code>int</code> и данное целое значение ''V'' представимо в типе <code>int</code>, то результат преобразования - целое значение ''V'' типа <code>int</code>.
* Иначе:
** Значение ''V'' слишком мало (отрицательное число, очень большое по модулю или отрицательная бесконечность); в этом случае результатом сужения типа будет наименьшее допустимое значение типа <code>int</code> или  <code>long</code>.
** Значение ''V'' слишком велико (положительное число, с большим значением или положительная бесконечность); в этом случае результатом сужения типа будет наибольшее допустимое значение типа <code>int</code> или  <code>long</code>.

Сужающее числовое преобразование от <code>double</code>  к  <code>float</code> выполняется согласно правилам стандарта IEEE 754. Результатом является корректно округленное значение; режим округления – округление к ближайшему по стандарту IEEE 754. Если значение слишком мало, чтобы быть представленным в типе <code>float</code>, то результатом преобразования будет положительный или отрицательный ноль типа <code>float</code>; если значение слишком велико, чтобы быть представленным в типе <code>float</code>, то результатом преобразования будет положительная или отрицательная бесконечность. Не-число (NaN) типа <code>double</code>  всегда преобразовывается типу не-числу (NaN) типа <code>float</code>.

Несмотря на переполнение, потерю значащих разрядов, потерю точности сужающие числовые преобразования никогда не приводят к исключениям виртуальной машины Java (не путать с исключениями стандарта IEEE 754 для чисел с плавающей точкой).

==== Создание и работа с объектами ====

Не смотря на то, что и классы, и массивы являются объектами, виртуальная машина Java создаёт и работает с классами и объектами по-разному, используя различные наборы инструкций:

* Создание нового экземпляра класса: ''new''.
* Создание нового массива: ''newarray'', ''anewarray'', ''multianewarray''.
* Доступ к полям класса (статические поля (<code>static</code>) известные как переменные класса) и полям экземпляра (не статические поля, известные как переменные экземпляра): ''getfield'', ''putfield'', ''getstatic'', ''putstatic''.
* Загрузить компонент массива в стек операндов: ''baload'',  ''caload'',  ''saload'',  ''iaload'', ''laload'', ''faload'', ''daload'', ''aaload''.
* Выгрузить значение из стека операндов в массив: ''bastore'', ''castore'', ''sastore'', ''iastore'', ''lastore'', ''fastore'', ''dastore'', ''aastore''.
* Получить длину массива: ''arraylength''.
* Проверить свойства экземпляра класса или массива: ''instanceof'', ''checkcast''.

==== Инструкции для работы со стеком операндов ====

Существует набор инструкций для непосредственной работы со стеком операндов: ''pop'', ''pop2'', ''dup'', ''dup2'', ''dup_x1'', ''dup2_x1'', ''dup_x2'', ''dup2_x2'', ''swap''.

==== Инструкции передачи управления ====

Выполнение инструкций передачи управления (условных или безусловных) приводит к тому, что виртуальная машина Java продолжает выполнение операции отличной от той, которая следует непосредственно после инструкции передачи управления. Доступны следующие операции:

* Условный переход: ''ifeq'',  ''ifne'',  ''iflt'',  ''ifle'',  ''ifgt'',  ''ifge'',  ''ifnull'',  ''ifnonnull'',  ''if_icmpeq'', ''if_icmpne'', ''if_icmplt'', ''if_icmple'', ''if_icmpgt'', ''if_icmpge'', ''if_acmpeq'', ''if_acmpne''. 
* Составные операторы условного перехода: ''tableswitch'', ''lookupswitch''.
* Операторы безусловного перехода: ''goto'', ''goto''_w, ''jsr'', ''jsr''_w, ''ret''.

Виртуальная машина Java имеет различные наборы инструкций условного перехода для работы с типами данных <code>int</code> и <code>reference</code>. Также виртуальная машина наборы инструкций условного перехода для проверки нулевых ссылок, поэтому нет требований, чтобы <code>null</code> значение было строго определённым: его можно выбрать произвольно.

Инструкции условного перехода, использующие для сравнения данные с типами<code>boolean</code>, <code>byte</code>, <code>char</code> и <code>short</code> выполняются с помощью инструкций, работающих с типом<code>int</code>(см. §2.11.1). Вместо инструкций условного перехода сравнивающих значения с типами данных<code>long</code><code>float</code> или <code>double</code> выполняется следующее: используется команда сравнения двух чисел с типами данных <code>long</code>, <code>float</code> или <code>double</code>; результат сравнения в виде значения с типом <code>int</code> помещается в стек операндов.  Затем переход для перехода используется инструкция, работающая с типом <code>int</code>. Из-за активного использования сравнений с типом данных <code>int</code> виртуальная машина Java имеет расширенной набор инструкций условного перехода, использующих для сравнения данные с типом <code>int</code>.

Все инструкций условного перехода, использующих для сравнения данные с типом<code>int</code> выполняют знаковое сравнение.

==== Вызов методов и инструкции возврата ====

Существуют пять инструкций вызова методов:

* ''invokevirtual'' вызывает метод экземпляра с учётом типа объекта (полиморфный вызов – прим. перев.). Это нормальная диспетчеризация методов в языке программирования Java.
* ''invokeinterface'' вызывает метод интерфейса, проводя поиск методов реализованных в экземпляре во время выполнения программы.
* ''invokespecial'' вызывает методы экземпляра, требующие специальной обработки, будь то метод инициализации экземпляра (см. §2.9), приватный метод или метод родительского класса.
* ''invokestatic'' вызывает статические методы класса.
* ''invokedynamic'' вызывает метод, который связан с узловым объектом вызова. Перед первым выполнением метода вызывается инициализирующий метод и в качестве результата узловой объект вызова связывается виртуальной машиной Java  со специфическим лексическим включением инструкции ''invokedynamic''. Поэтому каждое появление инструкции * ''invokedynamic'' имеет уникальное состояние связывания, в отличие от других инструкций вызова методов.

Существуют следующие инструкции возврата из метода, различаемые по возвращаемому значению: ''ireturn'' (используется для возвращения значений с типами   <code>boolean</code>,  <code>byte</code>,  <code>char</code>,  <code>short</code> или  <code>int</code>),  ''lreturn'',  ''freturn'', ''dreturn'' и  ''areturn''. Инструкция ''return'' используется для возврата из методов, объявленных как <code>void</code>, возврата из инициализирующих экземпляр методов или методов инициализации класса или интерфейса.

==== Формирование исключений ====

Программно вызов исключения можно выполнить с помощью инструкции ''athrow''. Исключения также могут быть вызваны виртуальной машиной Java при соответствующих условиях.


==== Синхронизация ====

Виртуальная машина Java поддерживает синхронизацию, как целых методов, так и набора инструкций с помощью единой конструкции для синхронизации: ''монитора''.

Синхронизация на уровне методов выполняется неявно как часть вызова методов и возврата из методов (см. §2.11.8). Метод, объявленный как <code>synchronized</code>, отличается от других методов тем, что в структуре данных времени выполнения <code>method_info</code> (см. §4.6) установлен флаг <code>ACC_SYNCHRONIZED</code>, который проверяется инструкцией вызова метода. Если для вызываемого метода флаг <code>ACC_SYNCHRONIZED</code> установлен, то при вызове метода, поток сначала входит в монитор, затем собственно исполняет тело метода и выходит из монитора вне зависимости от того завершилось ли выполнение метода нормально  или аварийно. Все время пока поток владеет монитором, никакой другой поток не может захватить этот монитор. Если происходит выброс исключения во время исполнения метода, объявленного как <code>synchronized</code>, и синхронизированный метод не перехватывает это исключение,  то поток автоматически выходит из монитора (освобождает монитор) перед тем как не перехваченное исключение будет повторно выброшено вне синхронизированного метода.

Для реализации блоков синхронизации языка программирования Java используется синхронизация набора инструкций. Для поддержки таких языковых конструкций виртуальная машина Java имеет инструкции ''monitorenter'' и  ''monitorexit''. Правильная реализация блоков синхронизации требует совместной работы, как компилятора, так и виртуальной машины Java (см. §3.14). 

''Структурное связывание'' – это такая ситуация, когда при вызове метода каждый выход из монитора соответствует предыдущему входу в тот же монитор. Так как нет никаких гарантий, что любой код, выполняемый виртуальной машиной Java, поддерживает структурное связывание,  то для реализации виртуальной машины Java допустимо, но не обязательно выполнение двух следующих правил, гарантирующих структурное связывание. Обозначим через ''T'' поток, а через M монитор. Тогда:

# Число входов в монитор ''M'' выполненных потоком ''T'' должно равняться числу выходов из монитора ''M'' выполненных потоком ''T'' вне зависимости от того завершился ли вызов метода нормально или аварийно.
# Никогда во время работы с методом число выходов из монитора ''M'' выполненных потоком ''T'' не должно превышать число входов в монитор ''M'' выполненных потоком ''T''.

Обратите внимание, что вход и выход в монитор автоматически выполняется виртуальной машиной Java при вызове синхронизированного метода.

=== Библиотека классов ===

Виртуальная машина Java, реализованная на конкретной платформе, должна предоставить достаточную поддержку для реализации библиотеки классов. Некоторые классы в этих библиотеках не могут быть реализованы без тесного взаимодействия с виртуальной машиной Java. 

Классы, которые могут потребовать специальной поддержки со стороны виртуальной машины Java, включают в себя  следующие:

* Реализацию рефлексии; классы в пакете <code>java.lang.reflect</code> и класс <code>Class</code>.
* Загрузку и создание классов и интерфейсов. Простейший пример – класс <code>ClassLoader</code>.
* Компоновку и инициализацию классов или интерфейсов. Приведённые выше примеры также подходят и для этой категории.
* Реализацию политик безопасности; классы в пакете <code>java.security</code> и другие классы, такие как <code>SecurityManager</code>. 
* Реализацию многопоточности; класс <code>Thread</code>.
* Реализацию слабых ссылок; классы пакета <code>java.lang.ref</code>.

Приведённый выше список является скорее иллюстративным и не претендует на полноту. Исчерпывающий список классов и их функциональности выходит за рамки данной спецификации. Подробная информация предоставлена в спецификации библиотеки классов платформы Java SE.

=== Открытый дизайн, закрытая реализация ===

На данный момент в этой спецификации мы выполнили лишь общий набросок виртуальной машины Java: формат <code>class</code> файла и набор инструкций. Эти компоненты жизненно важны для реализации независимости виртуальной машины Java от аппаратного обеспечения, операционной системы, и конкретной реализации самой виртуальной машины Java. Разработчику следует рассматривать эти компоненты скорее как средства обеспечения безопасного взаимодействия реализаций виртуальных машин Java на разных платформах, чем как заданные раз и навсегда правила.

Важно понимать, где проходит черта между открытым дизайном и закрытой реализацией. Реализация виртуальной машины Java должна быть способной читать <code>class</code> файлы и точно реализовывать семантику кода виртуальной машины Java. Один из способов сделать – это взять данный документ и реализовать все описанное здесь от точки до точки. Однако для разработчика также допустимо  изменять и оптимизировать реализацию в рамках ограничений данной спецификации, конечно. До тех пор, пока <code>class</code> файл может быть прочтён и семантика его кода соблюдена, разработчик может произвольно реализовывать данную семантику. То, что происходит внутри «чёрного ящика» касается только разработчика, до тех пор, пока тщательно соблюдены все внешние интерфейсы.
<br><br>
::Примечание. Из этого правила есть некоторые исключения: отладчики, модули протоколирования (профайлеры), генераторы кода для динамической компиляции (JIT компиляторы) требуют доступа к элементам виртуальной машины Java, которые находятся обычно внутри «чёрного ящика». Где это целесообразно, компания Oracle сотрудничает со сторонними разработчиками виртуальных машин Java и поставщиками инструментальных библиотек для разработки и распространения описания общих интерфейсов виртуальной машины Java.
<br>
Разработчики могут использовать предоставляемую гибкость, чтобы адаптировать виртуальную машину Java для повышения производительности, уменьшения использования памяти или переносимости. Приоритеты в данной конкретной реализации виртуальной машины зависят от целей, которые ставит перед собой разработчик. Цели могут также включать в себя следующее:

* Перевод кода виртуальной машины Java (во время загрузки или во время работы) в набор инструкций другой виртуальной машины.
* Перевод кода виртуальной машины Java (во время загрузки или во время работы) в набор инструкций центрально процессора, на котором запущена виртуальная машина (иногда называемый динамической (JIT) компиляцией).

Существование точно специфицированной виртуальной машины и формата файла объектов не обязательно приводит к ограничению полёта мысли разработчика. Виртуальная машина Java разработана для поддержки многих реализаций, что даёт новые и интересные решения при полном сохранении совместимости между реализациями.

== ГЛАВА 3. Компиляция программ в код виртуальной машины Java  ==

Виртуальная машина Java разработана для поддержки языка программирования Java. Библиотека Oracle JDK содержит компилятор, преобразующий исходный код на языке программирования Java в набор инструкций виртуальной машины Java и систему, реализующую непосредственно виртуальную машину Java. Для будущих разработчиков компиляторов полезно знать на примере как компилятор использует виртуальную машину Java так же, как и полезно понимать собственно устройство виртуальной машины. Некоторые из разделов в этой главе не являются обязательными для исполнения.

Обратите внимание, что под термином «компилятор» иногда понимается транслятор из набора инструкций виртуальной машины Java в набор инструкций конкретного центрального процессора. Один из примеров такого транслятора – это динамический генератор кода (JIT компилятор), который генерирует платформенно зависимые инструкции только после загрузки кода виртуальной машины Java. Эта глава не касается генерации платформенно зависимого кода, а посвящена только компиляции исходного кода на языке программирования Java в набор инструкций виртуальной машины Java.

=== Формат примеров ===

Эта глава в основном состоит из примеров исходного кода комментированными листингами кода виртуальной машины Java, который генерирует компилятор <code>javac</code> в составе Oracle JDK версии 1.0.2. Код виртуальной машины Java написан на так называемом «ассемблере виртуальной машины», который был сформирован утилитой <code>javap</code> в составе Oracle JDK. Вы можете использовать <code>javap</code>, чтобы получить собственные дополнительные примеры к приведённым в этой главе.

Формат примеров должен быть знаком для любого разработчика, имевшего дело с ассемблером. Каждая инструкция имеет формат:

 ''<индекс> <код> [ <операнд1> [ <операнд2>... ]] [<комментарий>]''

Здесь ''<индекс>'' - индекс операции  в массиве байт-кодов соответствующего метода. Также индекс можно рассматривать как байтовое смещение операции относительно начала метода. ''<код>'' - мнемоническое обозначение кода инструкции; ''<операндN>'' - операнды инструкции (могут отсутствовать); ''[<комментарий>]'' -  необязательный комментарий в конце строки:

 ''8  bipush 100          // записать в стек константу 100 с типом int''

Некоторые комментарии генерирует утилитой <code>javap</code>; остальные комментарии написаны авторами. ''<индекс>'', предшествующий каждой инструкции может быть использован в инструкциях передачи управления. Например, инструкция ''goto 8'' передает управление инструкции с индексом ''8''.  Обратите внимание, что фактическим операндами инструкций передачи управления являются абсолютные адресные смещения, однако для удобства чтения (мы также используем это в данной главе) утилита <code>javap</code> преобразует их в смещения внутри метода.

Операнды, представляющие собой индексы значений в константном пуле, мы снабжаем символом решетки и комментарием, описывающем значение константы, на которую ссылается индекс, например:

 ''10  ldc #1      // Записать в стек константу 100.0 с типом float'' 

или

 ''9  invokevirtual #4   // Метод Example.addTwo(II)I''

В рамках данной главы мы опускаем некоторые детали, такие как размер операндов и другие.

=== Использование констант, локальных переменных и управляющих структур ===

Код виртуальной машины Java содержит некоторые особенности, продиктованные архитектурой виртуальной машины Java и её типами данных. В первом примере мы обнаружим их в большом количестве и рассмотрим их более подробно.
Метод <code>spin</code> выполняет пустой цикл 100 раз:

<syntaxhighlight lang="java">
void spin() {
    int i;
    for (i = 0; i < 100; i++) {
        ; // Тело цикла пустое
    }
}
</syntaxhighlight>

Компилятор преобразует <code>spin</code> в следующий байт-код:

 0  ''iconst_0''	// Записать в стек 0 с типом int
 1  ''istore_1''	// Загрузить в локальную переменную с именем 1 (i=0)
 2  ''goto'' 8	// При первом проходе не увеличивать счетчик
 5  ''iinc'' 1 1	// Увеличить локальную переменную с именем 1 на 1 (i++)
 8  ''iload_1''	// Записать локальную переменную с именем 1 в стек (i)
 9  ''bipush'' 100	// Записать в стек константу 100 типа int 
 11 ''if_icmplt'' 5	// Сравнить и повторить цикл если результат меньше (i < 100)
 14 ''return''	// Вернуть пустой тип после завершения

Виртуальная машина Java является стек-ориентированной; большинство операций загружает из стека или записывает в стек виртуальной машины Java, который расположен в текущем фрейме, один или более операндов. Новый фрейм создаётся каждый раз при вызове метода и вместе с ним создаётся новый стек операндов множество локальных переменных, которые использует метод (см. §2.6). В каждый момент работы программы, скорее всего, будет создано много фреймов и соответственно стеков операндов для текущего управляющего потока; количество фреймов соответствует глубине вложенности вызовов методов. Активным является стек операндов только текущего метода.
 
Набор инструкций виртуальной машины Java спроектирован таким образом, что позволяет отличать типы операндов той или иной инструкции по разному байт-коду инструкции. Метод spin работает только с типами значений <code>int</code>. Поэтому все инструкции скомпилированного байт-кода (''iconst_0'', ''istore_1'', ''iinc'', ''iload_1'', ''if_icmplt'') также оперируют только с типами данных <code>int</code>. 

Две константы <code>0</code> и <code>100</code> в методе <code>spin</code> записаны в стек операндов с использованием двух различных инструкций. <code>0</code> записан в стек с помощью инструкции ''iconst_0'', одной из семейства инструкций  ''<nowiki>iconst_<i></nowiki>''. <code>100</code> записано с помощью инструкции ''bipush'', которая записывает следующие за ее байт-кодом значение непосредственно в стек. 

Виртуальная машина Java использует преимущество набора команд, неявно заменяя, где это возможно, инструкции с часто используемыми операндами (константы типа <code>int</code>   ''-1'',  ''0'',  ''1'',  ''2'',  ''3'',  ''4'' и  ''5'' в случае инструкции  ''<nowiki>iconst_<i></nowiki>'') на их эквивалентные, но более короткие версии. Поскольку для инструкции ''iconst_0'' известно, что она записывает в стек значение <code>int</code> 0,  нет необходимости дополнительно хранить операнд, так же как и нет необходимости извлекать и декодировать операнд. Если скомпилировать запись в стек нуля в инструкцию ''bipush 0'', то это будет корректно, но приведёт к увеличению на один байт размера скомпилированного метода <code>spin</code>. Это также приведёт к тому, что виртуальная машина потратит время на извлечение и декодирование явно заданного операнда каждый раз при проходе цикла. Использование неявных операндов позволяет сделать код более компактным и эффективным. 

Переменная <code>int</code> ''i'' в методе <code>spin</code> хранится в локальной переменной виртуальной машины Java с именем ''1''. Поскольку большинство инструкций виртуальной машины Java чаще оперируют со значениями, считанными из стека операндов чем с локальными переменными, то для скомпилированного кода характерно наличие инструкций записывающих данные из локальных переменных в стек и обратно. Для таких операций разработаны специальные инструкции в наборе команд. В методе <code>spin</code>, запись и считывание значений локальных переменных происходит с помощью инструкций ''istore_1'' и ''iload_1'', неявно работающих с локальной переменой ''1''. Инструкция ''istore_1'' считывает значение типа <code>int</code> из стека операндов и сохраняет в локальной переменной ''1''. Инструкция ''iload_1'' записывает в стек операндов значение локальной переменной ''1''.

Способы использования локальных переменных находятся в пределах ответственности разработчика компилятора. Разработчик должен стремиться использовать инструкции для работы с локальными переменными везде, где это только возможно. В этом случае результирующий код будет работать быстрее, иметь меньший размер и использовать фреймы меньшего размера. 

Виртуальная машина Java имеет набор инструкций для наиболее частых операций с локальными переменными. Инструкция ''iinc'' увеличивает значение локальной переменной на однобайтовое знаковое значение. В методе <code>spin</code> инструкция ''iinc'' увеличивает первую локальную переменную (первый операнд инструкции) на ''1'' (второй операнд инструкции). Инструкция ''iinc'' очень удобна для использования в циклических конструкциях.
 
Цикл <code>for</code> в методе <code>spin</code> реализован в основном следующими инструкциями:

 5  ''iinc'' 1 1	// Увеличить локальную переменную с именем 1 на 1 (i++)
 8  ''iload_1''	// Записать локальную переменную с именем 1 в стек (i)
 9  ''bipush'' 100	// Записать в стек константу 100 типа int
 11 ''if_icmplt'' 5	// Сравнить и повторить цикл если результат меньше (i < 100)

Инструкция ''bipush'' записывает в стек значение ''100'' с типом <code>int</code>, затем инструкция ''if_icmplt'' считывает из стека операндов значение 100 и сравнивает его с переменной i. Если результат сравнения «истина» (переменная i  меньше чем 100), происходит передача управления к индексу 5 и начинается следующая итерация цикла <code>for</code>. В противном случае управление передаётся инструкции следующей за ''if_icmplt''.

Если бы в примере с методом spin использовался для счётчика тип, отличный от <code>int</code>, то скомпилированный код был бы другим и отражал изменения в типе данных счётчика. Например, если бы вместо типа <code>int</code> был бы тип <code>double</code> как показано ниже:

<syntaxhighlight lang="java">
void dspin() {
double i;
for (i = 0.0; i < 100.0; i++) {
    ; // Цикл пустой
    }
}
</syntaxhighlight>

то в результате компиляции был бы следующий код:

 Метод void dspin()
 0  ''dconst_0''	// Записать в стек 0.0 с типом double
 1  ''dstore_1''	// Загрузить в локальные переменные с именами 1 и 2
 2  ''goto'' 9	// При первом проходе не увеличивать счётчик
 5  ''dload_1''	// Записать в стек локальные переменные 1 и 2
 6  ''dconst_1''	// Записать в стек 1.0 с типом double
 7  ''dadd''		// Сложить; инструкции dinc нет
 8  ''dstore_1''	// Загрузить в локальные переменные с именами 1 и 2
 9  ''dload_1''	// Записать в стек локальные переменные 1 и 2
 10 ''ldc2_w'' #4	// Записать в стек 100.0 с типом double
 13 ''dcmpg''	// Инструкции if_dcmplt нет
 14 ''iflt'' 5	// Сравнить и повторить цикл, если результат «меньше» (i < 100.0)
 17 ''return''	// Вернуть пустой тип после завершения

Инструкции, которые работают с типизированными данными, заменены для типа <code>double</code>. (Инструкция ''ldc2_w'' будет описана далее в этой главе.)

Вспомните, что значения типа <code>double</code> хранятся в двух локальных переменных, однако доступ к ним осуществляется через младший индекс одной из двух локальных переменных. Аналогично для типа данных <code>long</code>. Ещё пример:

<syntaxhighlight lang="java">
double doubleLocals(double d1, double d2) {
return d1 + d2;
} 
</syntaxhighlight>

компилируется в 

 Метод double doubleLocals(double,double)
 0  ''dload_1''	// Первый аргумент в локальных переменных 1 и 2
 1  ''dload_3''	// Второй аргумент в локальных переменных 3 и 4
 2  ''dadd''
 3  ''dreturn''

Обратите внимание, что пара локальных переменных, хранящих значение типа <code>double</code> в <code>doubleLocals</code> никогда не должны рассматриваться отдельно.

Поскольку код операции в виртуальной машине Java занимает один байт, результирующий код получается очень компактным. Как следствие, это означает, что набор инструкций виртуальной машины Java очень мал. Поэтому виртуальная машина Java не поддерживает одинаковый набор операций для всех типов: набор операций не полностью ортогонален (см. таблицу 2.2). 

Например, сравнение двух значений типа <code>int</code> в цикле <code>for</code> в примере метода spin может быть реализовано с помощью одной инструкции ''if_icmplt''; тем не менее, не существует одной инструкции в наборе виртуальной машины Java, которая реализовывала условный переход по результату сравнения значений типа <code>double</code>. Поэтому в <code>dspin</code> использовано сравнение значений <code>double</code> (инструкция ''dcmpg'') и условный переход по результату сравнения (инструкция ''iflt'').

Операции с типом  <code>int</code> наиболее полно представлены в наборе инструкций виртуальной машины Java. С одной стороны это сделано для более эффективной реализации стека операндов и массивов локальных переменных. С другой стороны то, что тип <code>int</code> наиболее части используется в программах, также сыграло свое значение. Поддержка других целочисленных типов реализована в меньшем объеме. Например, для типов <code>byte</code>,  <code>char</code> и  <code>short</code> нет инструкций хранения, загрузки или сложения. Вот пример функции <code>spin</code> для типа <code>short</code>:

<syntaxhighlight lang="java">
void sspin() {
short i;
for (i = 0; i < 100; i++) {
    ; // Тело цикла пустое
    }
}
</syntaxhighlight>

Этот исходный код должен быть скомпилирован для виртуальной машины Java следующим образом: в качестве основного типа данных выбирается <code>int</code>, там, где это необходимо выполняется преобразование между <code>short</code> и <code>int</code>, гарантирующее, что значения типа <code>short</code> будут в соответствующих пределах:

 Метод void sspin()
 0  ''iconst_0''
 1  ''istore_1''
 2  ''goto'' 10
 5  ''iload_1''		// Значение short рассматривается как int
 6  ''iconst_1''
 7  ''iadd''
 8  ''i2s''			// Усечение  int к short
 9  ''istore_1''
 10 ''iload_1''
 11 ''bipush'' 100
 13 ''if_icmplt'' 5
 16 ''return''

То, что непосредственная поддержка типов  <code>byte</code>,  <code>char</code> и  <code>short</code> ограничена в виртуальной машине Java, не является серьёзным недостатком, поскольку значения этих типов все равно преобразуются к типу <code>int</code> (<code>byte</code> и  <code>short</code> расширяются знаково к <code>int</code>, для <code>char</code> используется беззнаковое расширение). Таким образом, операции над типами <code>byte</code>,  <code>char</code> и  <code>short</code> могут быть выполнены с использованием инструкций для типа <code>int</code>. Единственные дополнительные затраты связаны с преобразованием значений типа <code>int</code> к нужным пределам.
 
Тип данных <code>long</code> и типы с плавающей точкой имеют среднюю поддержку в наборе инструкций виртуальной машины Java; единственное, что отсутствует для них – инструкции условной передачи управления.

=== Арифметика ===

Виртуальная машина Java обычно выполняет арифметические операции над операндами в стеке. (Исключение составляет инструкция ''iinc'', которая непосредственно увеличивает значение локальной переменной.) Например, метод <code>align2grain</code> выравнивает значение типа <code>int</code> по степеням двойки:


<syntaxhighlight lang="java">
int align2grain(int i, int grain) {
return ((i + grain-1) & ~(grain-1));
}
</syntaxhighlight>

Операнды арифметических операций считываются из стека операндов, а результат выполнения операции записывается обратно в стек. Таким образом, результаты промежуточных арифметических вычислений могут быть использованы в качестве операндов в последующих вычислениях. Например, вычисление выражения <code>~(grain-1)</code> выполняется посредством следующих инструкций:

 5  ''iload_2''	// Записать grain в стек
 6  ''iconst_1''	// Записать константу 1 типа int в стек
 7  ''isub''		// Вычесть; записать результат в стек
 8  ''iconst_m1''	// Записать константу -1 типа int в стек
 9  ''ixor''		// Выполнить XOR; записать результат в стек

Вначале вычисляется значение <code>grain-1</code> с использованием локальной переменной ''2'' и константы <code>1</code> типа <code>int</code>. Эти операнды считываются из стека операндов, и их разность записывается обратно в стек.  Таким образом, значение разности непосредственно доступно в качестве операнда для инструкции ''ixor''. (Напомним что <code>~x == -1^x</code>.) Точно также результат выполнения инструкции ''ixor'' становится операндом последующей инструкции ''iand''.

Полностью скомпилированный код метода выглядит так:

 Метод int align2grain(int,int)
 0  ''iload_1''
 1  ''iload_2''
 2  ''iadd''
 3  ''iconst_1''
 4  ''isub''
 5  ''iload_2''
 6  ''iconst_1''
 7  ''isub''
 8  ''iconst_m1''
 9  ''ixor''
 10 ''iand''
 11 ''ireturn''

=== Доступ к константному пулу времени выполнения ===

Доступ к большинству численных констант, объектов, полей и методов можно получить через константный пул времени выполнения текущего класса. Доступ к объектам будет рассмотрен позже (см. §3.8). Доступ к типам данных <code>int</code>,  <code>long</code>,  <code>float</code> и  <code>double</code>  и ссылкам на экземпляр класса <code>String</code> можно получить с помощью инструкций ''ldc'',  ''ldc''_w и  ''ldc''2_w.

Инструкции ''ldc'' и ''ldc''_w используются для доступа к значениям (включая экземпляры класса <code>String</code>) в константном пуле времени выполнения (кроме значений типа <code>double</code> и <code>long</code>). Инструкция  ''ldc''_w используется вместо ''ldc'' в случае большого числа элементов в константном пуле, что в свою очередь требует индекса большей размерности для доступа к ним. Инструкция ''ldc''2_w предназначена для доступа к значениям типа <code>double</code> и <code>long</code>; варианта этой инструкции с однобайтовым индексом не существует.

Целочисленные константы типов <code>byte</code>,  <code>char</code> и  <code>short</code>, равно как и некоторые значения типа <code>int</code> могут быть созданы с помощью инструкций ''bipush'',  ''sipush'' и  ''<nowiki>iconst_<i></nowiki>'' (см. §3.2). Некоторые константы с плавающей точкой могут быть также созданы с помощью инструкций ''fconst_<f>'' и ''dconst_<d>''.

Для всех случаев указанных выше компиляция выполняется непосредственно в байт-код без дополнительных преобразований. Например, для следующих констант:

<syntaxhighlight lang="java">
void useManyNumeric() {
int i = 100;
int j = 1000000;
long l1 = 1;
long l2 = 0xffffffff;
double d = 2.2;
... выполнить вычисления...
}
</syntaxhighlight>

Будет скомпилирован байт-код:

 Метод void useManyNumeric()
 0  ''bipush'' 100  // Записать в стек 100 типа int
                // с помощью ''bipush'' (небольшое целое).
 2  ''istore_1''
 3  ''ldc'' #1      // Записать в стек 1000000 типа int;
                // для больших целочисленных значений используется ''ldc''
 5  ''istore_2''
 6  ''lconst_1''    // Для совсем маленьких целых используется ''lconst_1''
 7  ''lstore_3''
 8  ''ldc2_w'' #6   // Записать в стек  0xffffffff  типа long (-1 для типа int);
                // любая константа типа long может быть
                // записана в стек с помощью ''ldc2_w''
 11  ''lstore'' 5
 13  ''ldc2_w'' #8  // Записать в стек  константу 2.200000 типа double;
                // нестандартные double значения
                // записываются в стек с помощью ''ldc2_w''
 16  ''dstore'' 7
 ...выполнить вычисления...

=== Передача управления ===

Компиляция операторов <code>for</code> была показана нами выше (см. §3.2). Большинство конструкций передачи управления языка Java (<code>if</code>-<code>then</code>-<code>else</code>, <code>do</code>, <code>while</code>, <code>break</code> и <code>continue</code>) компилируется в байт-код тривиальным образом. Компиляция оператора <code>switch</code> описана в отдельном разделе (см. §3.10), компиляция исключений – в разделе §3.12, операторов <code>finally</code> – в §3.13.

В качестве дальнейшего примера рассмотрим цикл <code>while</code>; его компиляция достаточно тривиальна; однако есть некоторые нюансы при компиляции разных типов данных используемых в операции сравнения в цикле. Как обычно тип <code>int</code> наиболее поддерживаемый из всех типов, например: 

<syntaxhighlight lang="java">
void whileInt() {
    int i = 0;
    while (i < 100) {
    i++;
    }
}
</syntaxhighlight>

Будет скомпилировано в:

 Метод void whileInt()
 0  	''iconst_0''
 1  	''istore_1''
 2  	''goto'' 8
 5  	''iinc'' 1 1
 8  	''iload_1''
 9  	''bipush'' 100
 11  	''if_icmplt'' 5
 14  	''return''

Обратите внимание, что проверка в цикле <code>while</code> (реализованная с помощью инструкции ''if_icmplt'') расположена в конце цикла в скомпилированном байт-коде виртуальной машины Java. (Тоже самое читатель мог видеть в методе <code>spin</code> выше.)  Поскольку проверка расположена в конце цикла, необходимо использовать инструкцию ''goto'', чтобы она была выполнена до самой первой итерации цикла. Если первая проверка условия в цикле вернет «ложь» и тело цикла никогда не будет выполнено, то в этом случае инструкция ''goto'' лишь увеличивает размер скомпилированного байт-кода. Тем не менее, <code>while</code> обычно проектируют таким образом, чтобы их тело выполнялось и достаточно большое число раз. Располагая проверку в конце цикла, мы тем самым экономим одну инструкцию при каждом выполнении итерации цикла: если бы проверка была в начале цикла, необходимо было бы поместить инструкцию ''goto'' в конце тела цикла и выполнять ее каждый раз по завершению тела, чтобы снова перейти к проверке условия.

Управляющие конструкции для других типов данных компилируются похожим образом, с учётом доступных для данных типов команд. Это приводит к менее эффективному коду, поскольку необходимо использовать большее число инструкций виртуальной машины Java, например:

<syntaxhighlight lang="java">
void whileDouble() {
double i = 0.0;
while (i < 100.1) {
    i++;
    }
}
</syntaxhighlight>

компилируется в:

 Метод void whileDouble()
 0  	''dconst_0''
 1  	''dstore_1''
 2  	''goto'' 9
 5  	''dload_1''
 6  	''dconst_1''
 7  	''dadd''
 8  	''dstore_1''
 9  	''dload_1''
 10  	''ldc2_w'' #4       // Записать в стек константу 100.1 типа double
 13  	''dcmpg''           // Для выполнения сравнения и перехода
                        // необходимо использовать...
 14  	''iflt'' 5          // ...две инструкции
 17  	''return''

Каждый тип с плавающей точкой имеет по две инструкции сравнения:  ''fcmpl'' и  ''fcmpg'' для типа <code>float</code> а также ''dcmpl'' и ''dcmpg'' для типа <code>double</code>. Они отличаются между собой только тем, как реагируют на NaN значения. Поскольку NaN не упорядочено (см. §2.3.2), то все сравнения для чисел с плавающей точкой, когда один из операндов NaN, всегда возвращают «ложь». Компилятор выбирает тот вариант инструкции для соответствующего типа вне зависимости от того вернёт ли сравнение «ложь» из-за сравнения числовых операндов или не чисел NaN. Например:

<syntaxhighlight lang="java">
int lessThan100(double d) {
if (d < 100.0) {
    return 1; 
    } else {
    return -1; 
    }
}
</syntaxhighlight>

будет скомпилировано в:

 Метод int lessThan100(double)
 0   ''dload_1''
 1   ''ldc2_w'' #4  // Записать в стек константу 100.0 типа double
 4   ''dcmpg''      // Записать в стек 1 если d не число NaN или d > 100.0;
                // Записать в стек 0 если d == 100.0
 5   ''ifge'' 10    // Выполнить переход в зависимости от значения в стеке: 0 или 1
 8   ''iconst_1''
 9   ''ireturn''
 10  ''iconst_m1''
 11  ''ireturn''

Если d не является NaN и меньше чем 100.0, то инструкция ''dcmpg'' помещает значение -1 типа <code>int</code> в стек операндов; в этом случае ''ifge'' не выполняет переход. Если <code>d</code> больше чем <code>100.0</code> или является NaN, то  инструкция ''dcmpg'' помещает значение 1 типа <code>int</code> в стек операндов; в этом случае ''ifge'' выполняет переход. Если <code>d</code> равняется <code>100.0</code>, то инструкция ''dcmpg'' помещает значение 0 типа <code>int</code> в стек операндов; ''ifge'' также выполняет переход.

Инструкция ''dcmpl'' используется при компиляции, если знак в условии цикла поменять на обратный:


<syntaxhighlight lang="java">
int greaterThan100(double d) {
if (d > 100.0) {
    return 1; 
    } else {
    return -1; 
    }
}
</syntaxhighlight>

становится: 

 Метод int greaterThan100(double)
 0   ''dload_1''
 1   ''ldc2_w'' #4  // Записать в стек константу 100.0 типа double
 4   ''dcmpl''      // Записать в стек -1 если d не число NaN или d < 100.0;
                // Записать в стек 0 если d == 100.0
 5   ''ifle'' 10    // Выполнить переход в зависимости от значения в стеке: 0 или -1
 8   ''iconst_1''
 9   ''ireturn''
 10  ''iconst_m1''
 11  ''ireturn''

Повторим ещё раз: вне зависимости от того, будет ли значение логического выражения «ложь» в результате сравнения с числом или вследствие того, что один из операндов не число NaN, инструкция ''dcmpl'' запишет в стек значение типа  <code>int</code>, которое приведёт к тому, что ''ifle'' выполнит переход. Если бы не было обоих видов инструкции ''dcmp'', в рассмотренных выше примерах необходимо было бы выполнять дополнительные действия для обработки значений NaN.

=== Получение аргументов ===


Если n переменных передаются в метод экземпляра, то они записываются согласно правилу в локальные переменные с номерами от ''1'' до ''n'' того фрейма, который был создан для вызова указанного выше метода. Аргументы поступают в метод в том порядке, в котором они передаются. Например:

<syntaxhighlight lang="java"> 
int addTwo(int i, int j) {
return i + j;
}  
</syntaxhighlight>

компилируется в:

 Метод int addTwo(int,int)
 0  ''iload_1'' // Записать в стек значение локальной переменной 1 (i)
 1  ''iload_2'' // Записать в стек значение локальной переменной 2 (j)
 2  ''iadd''    // Сложить; записать результат сложения в стек с типом int
 3  ''ireturn'' // вернуть результат с типом int

По соглашению в метод экземпляра также передаётся значение типа <code>reference</code> –  ссылка на сам экземпляр – в локальную переменную ''0''. В языке программирования Java эта ссылка доступна через ключевое слово <code>this</code>.

Методы, принадлежащие классу (<code>static</code>), не принадлежат ни одному  экземпляру, поэтому необходимости в локальной переменной ''0'' нет.

Методы, принадлежащие классу, для хранения входных параметров используют локальные переменные, начиная с ''0''. Если бы метод <code>addTwo</code> был бы статическим (принадлежал классу), то его параметры передавались бы похожим образом, но с единственным различием: индекс локальных переменных начинался бы с ''0'',  а не с ''1''. Пример:

<syntaxhighlight lang="java">
static int addTwoStatic(int i, int j) {
    return i + j;
}   
</syntaxhighlight>

компилируется в:

 Метод int addTwoStatic(int,int)
 0  ''iload_0''
 1  ''iload_1''
 2  ''iadd''
 3  ''ireturn''

Обратите внимание, индекс начинается с ''0'', а не с ''1''.

=== Вызов методов ===

Обычный вызов методов осуществляется с помощью диспетчеризации времени выполнения. (Если методы – виртуальные в терминах C++.) Такой вызов осуществляется с помощью инструкции ''invokevirtual'', которая в качестве аргументов принимает индекс в константном пуле времени выполнения, указывающий на внутреннее двоичное имя класса объекта и имя вызываемого метода. Совместно двоичное имя класса и имя метода называется дескриптором метода (см. §4.3.3). Для вызова метода <code>addTwo</code> определённого выше в качестве метода экземпляра, нам следует написать:

<syntaxhighlight lang="java">
int add12and13() {
    return addTwo(12, 13);
}   
</syntaxhighlight>

Этот код будет скомпилирован в:

 Метод int add12and13()
 0  ''aload_0''                 // Записать в стек локальную переменную 0 (ссылка this)
 1  ''bipush'' 12               // Записать в стек значение 12 типа int
 3  ''bipush'' 13               // Записать в стек значение 13 типа int
 5  ''invokevirtual'' #4        // Метод Example.addtwo(II)I
 8  ''ireturn''                 // Записать в стек значение типа int
                                // – результат выполения addTwo();


Перед вызовом метода необходимо записать в стек значение типа <code>reference</code> – ссылку на текущий экземпляр, <code>this</code>. Затем в стек записываются аргументы метода – значения <code>12</code> и <code>13</code> типа  <code>int</code>. После того, как будет создан фрейм для метода <code>addTwo</code>, аргументы, переданные в метод, будут присвоены в качестве начальных значений локальным переменным. Аргумент типа <code>reference</code> и два других аргумента, записанные в стек вызывающим методом, станут значениями локальных переменных с именами ''0'', ''1'' и ''2'' вызываемого метода.

Затем вызывается метод <code>addTwo</code>.  Когда метод <code>addTwo</code> завершит выполнение, на вершину стека операндов вызывающего метода будет записано значение типа <code>int</code> – результат выполнения <code>add12and13</code>.

Возврат из метода <code>add12and13</code> выполняется посредством инструкции ''ireturn''. Инструкция ''ireturn'' считывает из стека операндов текущего фрейма значение типа <code>int</code> – результат выполнения <code>addTwo</code> –  и записывает его в стек фрейма вызывающего метода. Затем ''ireturn'' передаёт управление вызывающему методу, при этом фрейм вызывающего метода становится текущим. Набор инструкций виртуальной машины Java содержит различные варианты инструкции возврата в зависимости от типа возвращаемого методом значения – числового типа либо типа <code>reference</code>; инструкция ''return'' используется для методов, не возвращающих значений. Один и тот же набор инструкций возврата из методов используется для всех инструкций вызова методов.

Операнд инструкции ''invokevirtual'' (в примере выше это индекс #4 в константном пуле времени выполнения) не является смещением метода в экземпляре класса. Компилятор не имеет информации о внутренней структуре экземпляра класса. Вместо этого он генерирует символьную ссылку на метод экземпляра, которая хранится в константном пуле времени выполнения. Разрешение ссылок константного пула происходит во время выполнения программы: символьные ссылки на экземпляры заменяются указателями на методы. Это  справедливо и для других инструкций виртуальной машины Java, требующих доступа к объектам.

Вызов статической реализации <code>addTwoStatic</code> похож на вызов <code>addTwo</code>:

<syntaxhighlight lang="java">   
int add12and13() {
    return addTwoStatic(12, 13);
}
</syntaxhighlight>

хотя для вызова метода используется другая инструкция виртуальной машины Java:

 Метод int add12and13()
 0  ''bipush'' 12
 2  ''bipush'' 13
 4  ''invokestatic'' #3// Метод Example.addTwoStatic(II)I
 7  ''ireturn''

Компиляция вызова статического метода напоминает компиляцию вызова метода экземпляра за исключением того, что параметр <code>this</code> не передаётся вызывающим методом в вызываемый. Фактические параметры метода будут записаны в локальные переменные, начиная с переменной с именем ''0'' (см. §3.6). Инструкция ''invokestatic'' всегда используется при вызове методов класса (<code>static</code> методов).

Инструкция ''invokespecial'' используется для вызова методов, инициализирующих экземпляр (см. §3.8). Она также используется для вызова методов класса-предка (<code>super</code>) и для вызова <code>private</code> методов. Рассмотрим классы <code>Near</code> и <code>Far</code>, объявленные следующим образом:

<syntaxhighlight lang="java">   
class Near {
  int it;
  public int getItNear() {
     return getIt();
  }
  private int getIt() {
     return it;
  }
}
class Far extends Near {
  int getItFar() {
    return super.getItNear();
  }
}
</syntaxhighlight>

Метод <code>Near.getItNear</code>, вызывающий <code>private</code> метод компилируется следующим образом:

 Метод int getItNear()
 0  ''aload_0''
 1  ''invokespecial'' #5// Метод Near.getIt()I
 4  ''ireturn''

Метод <code>Far.getItFar</code>, вызывающий метод суперкласса, компилируется в:

 Метод int getItFar()
 0  ''aload_0''
 1  ''invokespecial'' #4// Метод Near.getItNear()I
 4  ''ireturn''

Обратите внимание, при использовании инструкции ''invokespecial'' всегда передается параметр <code>this</code> в качестве первого аргумента. Как обычно, этот аргумент записывается в локальную переменную ''0''.

Для вызова методов компилятор создаёт дескриптор методов, который содержит описания аргументов и возвращаемого типа. Компилятор не должен выполнять преобразования типов, необходимые для вызова метода; вместо этого он обязан записать значения аргументов в стек в соответствии с их исходными типами. Компилятор также записывает в стек значение <code>this</code>  с типом <code>reference</code> перед всеми аргументами, как  это описано выше. Компилятор формирует вызов инструкции ''invokevirtual'', которая ссылается на дескриптор, описывающий аргументы и возвращаемые типы. Согласно соглашению о разрешении методов (см. §5.4.3.3), инструкция ''invokevirtual'', которая вызывает метод <code>invokeExact</code> либо  <code>invoke</code> класса <code>java.lang.invoke.MethodHandle</code> всегда выполнит связывание методов, при условии, что дескриптор сформирован корректно, и типы, упомянутые в дескрипторе, могут быть разрешены.

=== Работа с экземплярами класса ===

Экземпляры классов виртуальной машины Java сознаются с помощью инструкции ''new'' виртуальной машины Java. Напомним, что на уровне виртуальной машины Java конструктор представляет собой метод с именем <code><init></code>, присвоенным компилятором. Этот специально созданный метод известен как инициализирующий метод экземпляра (см. §2.9). Для данного класса могут существовать несколько инициализирующих методов экземпляра, соответственно числу конструкторов. Когда экземпляр класса был создан и переменным класса присвоены начальные значения (включая экземпляры их переменные всех предков данного класса), вызывается инициализирующий метод экземпляра. Например,

<syntaxhighlight lang="java">
Object create() {
  return new Object();
}   
</syntaxhighlight>

будет скомпилировано в:

 Метод java.lang.Object create()
 0  ''new'' #1		// Класс java.lang.Object
 3  ''dup''
 4  ''invokespecial'' #4	// Метод java.lang.Object.<init>()V
 7  ''areturn''

Ссылка на экземпляр класса (тип данных <code>reference</code>) считывается и записывается в стек также как и числовые значения, кроме того для типа <code>reference</code> существует свой набор инструкций, например,

<syntaxhighlight lang="java">   
 int i; // Переменная экземпляра
MyObj example() {
  MyObj o = new MyObj();
  return silly(o);
}
MyObj silly(MyObj o) {
  if (o != null) {
  return o;
  } else {
  return o;
  }
}
</syntaxhighlight>

компилируется в

 Метод MyObj example()
 0  ''new'' #2		// Class MyObj
 3  ''dup''
 4  ''invokespecial'' #5	// Метод MyObj.<init>()V
 7  ''astore_1''
 8  ''aload_0''
 9  ''aload_1''
 10  ''invokevirtual'' #4	// Метод Example.silly(LMyObj;)LMyObj;
 13  ''areturn''

 Метод MyObj silly(MyObj)
 0  ''aload_1''
 1  ''ifnull'' 6
 4  ''aload_1''
 5  ''areturn''
 6  ''aload_1''
 7  ''areturn''

Доступ полям экземпляра (переменным экземпляра), осуществляется с помощью инструкций ''getfield'' и ''putfield''. Если <code>i</code> – переменная экземпляра типа <code>int</code> и методы <code>setIt</code> и <code>getIt</code> определены как

<syntaxhighlight lang="java">
void setIt(int value) {
  i = value;
}
int getIt() {
  return i;
}   
</syntaxhighlight>

то, код будет скомпилирован следующим образом:

 Метод void setIt(int)
 0  ''aload_0''
 1  ''iload_1''
 2  ''putfield'' #4	// Поле Example.i I
 5  ''return''

 Метод int getIt()
 0  ''aload_0''
 1  ''getfield'' #4	// Поле Example.i I
 4  ''ireturn''

Также как и для операндов инструкции вызова методов, для операндов операций ''putfield'' и ''getfield'' справедливо следующее: эти операнды не являются смещениями полей в структуре экземпляра класса, а представляют собой индекс в константном пуле (индекс #4 в примере выше) времени выполнения. Компилятор генерирует символьные ссылки на поля экземпляра; ссылки хранятся в константном пуле времени выполнения. Во время выполнения программы эти ссылки разрешаются для определения поля в объекте.

=== Массивы ===

Массивы также являются объектами. Массивы создаются и обрабатываются определенным набором инструкций. Инструкция ''newarray'' используется для создания массива из числовых элементов. Исходный код

<syntaxhighlight lang="java"> 
void createBuffer() {
    int buffer[];
    int bufsz = 100;
    int value = 12;
    buffer = new int[bufsz];
    buffer[10] = value;
    value = buffer[11];
}  
</syntaxhighlight>

будет скомпилирован в

 Метод void createBuffer()
 0  ''bipush'' 100              // Записать в стек значение 100 (bufsz) с типом int
 2  ''istore_2''                // Считать из стека bufsz в локальную переменную 2
 3  ''bipush'' 12               // Записать в стек значение 12 с типом int
 5  ''istore_3''                // Считать из стека значение в локальную переменную 3
 6  ''iload_2''                 // Записать в стек значение и локальной переменной 2 (bufsz)...
 7  ''newarray'' int            // ...и создать массив с типами int и длиной bufsz
 9  ''astore_1''                // Считать из стека значение ссылки и записать в локальную переменную 1
 10  ''aload_1''                // Записать в стек ссылку на массив из локальной переменной 1
 11  ''bipush'' 10              // Записать в стек значение 10 типа int
 13  ''iload_3''                // Записать в стек значение локальной переменной 3 типа int
 14  ''iastore''                // Загрузить значения типа int из стека в массив buffer[10]
 15  ''aload_1''                // Загрузить ссылку из локальной  переменной 1 в стек
 16  ''bipush'' 11              // Записать в стек значение 11 типа int
 18  ''iaload''                 // Записывать в стек значение из массива buffer[11]...
 19  ''istore_3''               // ... и считать из стека значение в локальную переменную 3
 20  ''return''

Инструкция ''anewarray'' используется для создания одномерного массива ссылок на объекты, например:

<syntaxhighlight lang="java">   
void createThreadArray() {
    Thread threads[];
    int count = 10;
    threads = new Thread[count];
    threads[0] = new Thread();
}
</syntaxhighlight>

становится:

 Метод void createThreadArray()
 0  ''bipush'' 10         // Записать в стек значение 10 с типом int
 2  ''istore_2''          // Считать из стека значение в локальную переменную 2, инициализировав тем самым переменную count
 3  ''iload_2''           // Записать в стек значение и локальной переменной 2 (count)
 4  ''anewarray'' class #1// Создать массив ссылок на объекты класса Thread
 7  ''astore_1''          // Считать из стека значение ссылки на массив и записать в локальную переменную 1
 8  ''aload_1''           // Загрузить ссылку из локальной  переменной 1 в стек
 9  ''iconst_0''          // Записать в стек значение 0 с типом int
 10  ''new'' #1           // Создать экземпляр класса Thread
 13  ''dup''              // Сделать дубликат ссылки на вершине стека...
 14  ''invokespecial'' #5 // ...для передачи его в инициализирующий метод экземпляра Method java.lang.Thread.<init>()V 
 17  ''aastore''          // Сохранить ссылку из стека в массиве в ячейке с индексом 0
 18  ''return''

Инструкция ''anewarray'' может быть использована также для создания первого измерения многомерного массива. Аналогично инструкция ''multianewarray'' может быть использована для создания массива с несколькими измерениями сразу. Например, трёхмерный массив:

<syntaxhighlight lang="java">   
int[][][] create3DArray() {
    int grid[][][];
    grid = new int[10][5][];
    return grid;
}
</syntaxhighlight>

компилируется в

 Метод int create3DArray()[][][]
 0  ''bipush'' 10               // Записать в стек 10 (первое измерение)
 2  ''iconst_5''                // Записать в стек 5 (второе измерение)
 3  ''multianewarray'' #1 dim #2// Class [[[I, трёхмерный целочисленный массив
                            // Необходимо создать только первые два измерения, хранящие ссылки на другие массивы. 
                            // Величина третьего измерения не задана 
 7  ''astore_1''                // Считать из стека значение ссылки на массив и записать в локальную переменную 1
 8  ''aload_1''                 // затем загрузить ссылку из локальной  переменной 1 в стек
 9  ''areturn''

Первый операнд инструкции ''multianewarray'' представляет собой индекс в константном пуле на код типа создаваемого массива. Второй аргумент – количество размерностей, которые фактически необходимо создать.  Инструкция ''multianewarray'', как показывает приведённый выше пример компиляции метода <code>create3DArray</code>, может быть использована для создания массивов всех типов. Обратите внимание, что многомерный массив также как и одномерный представляет собой объект; ссылка на него загружается в локальную переменную и возвращается из метода инструкциями ''aload_1'' и ''areturn'' соответственно. Информацию об именах классов массивов см. в §4.4.1.

Все массивы имеют поле, содержащее их длину, доступ к которому, осуществляется с помощью инструкции ''arraylength''.

=== Компилирование операторов <code>switch</code> ===

При компилировании операторов <code>switch</code> используются инструкции ''tableswitch''  ''lookupswitch''. Инструкция ''tableswitch'' используется, когда константы оператора <code>switch</code> могут быть легко представлены в виде набора последовательных значений, которые будут преобразованы в индекс в  таблице смещений. Ключевое слово <code>default</code> используется, если значение проверяемого выражения не совпадает ни с одной константой оператора  <code>switch</code>. Например,

<syntaxhighlight lang="java">
int chooseNear(int i) {
switch (i) {
    case 0: return 0;
    case 1: return 1;
    case 2: return 2;
    default: return -1;
    }
}   
</syntaxhighlight>

будет скомпилировано в: 

 Метод int chooseNear(int)
 0  ''iload_1''                // Записать в стек локальную
                           // переменную 1 (аргумент i)
 1  ''tableswitch'' 0 to 2:    // Допустимые пределы индексов от 0 до 2
 0: 28                     // Если i равно 0, продолжить
                           // выполнение со смещения 28
 1: 30                     // Если i равно 1, продолжить с 30
 2: 32                     // Если i равно 2, продолжить с 32
 default:34                // Иначе, продолжить с 34
 28  ''iconst_0''              // i равно 0; записать в стек константу 0 типа int...
 29  ''ireturn''               // ... и вернуть ее
 30  ''iconst_1''              // i равно 1; записать 1...
 31  ''ireturn''               // ...и вернуть ее
 32  ''iconst_2''              // i равно 2; записать 2...
 33  ''ireturn''               // ...и вернуть ее
 34  ''iconst_m1''             // иначе записать константу -1...
 35  ''ireturn''               // ...и вернуть ее

Инструкции виртуальной машины Java ''tableswitch'' и ''lookupswitch'' работают только со значениями типа <code>int</code>. Поскольку операции над типами <code>byte</code>,  <code>char</code> и  <code>short</code> преобразуются к операциям с типом <code>int</code>, операторы <code>switch</code> с выражениями указанных типов компилируются успешно и используют значения типа <code>int</code>. Если бы метод <code>chooseNear</code> был написан с использованием типа <code>short</code>, то инструкции виртуальной машины Java были бы те же что и для метода с типом <code>int</code>. Другие численные типы для использования в операторе <code>switch</code> должны быть преобразованы посредством сужения к типу <code>int</code>. 

Если значения констант оператора <code>switch</code> идут не последовательно, то создание таблицы смещений для инструкции  ''tableswitch'' становится не эффективным из-за дополнительного расхода памяти. Вместо этого должна быть использована инструкция ''lookupswitch''. Инструкция ''lookupswitch'' связывает значение целочисленного ключа (значения меток  <code>case</code>) со смещением начала исполнимого кода. Когда исполняется инструкция ''lookupswitch'', значение выражения оператора <code>switch</code> сравнивается с ключами в таблице. Если значения ключа и выражения совпадают, выполнения кода продолжается со смещения, связанного с данным ключом. Если выражение не совпадает ни с одним из ключей, то выполнения кода продолжается со смещения <code>default</code>. Например, следующий код

<syntaxhighlight lang="java">   
int chooseFar(int i) {
    switch (i) {
    case -100: return -1;
    case 0: return 0;
    case 100: return 1;
    default: return -1;
    }
}
</syntaxhighlight>

напоминает метод <code>chooseNear</code> за исключением того, что будет использована инструкция ''lookupswitch'':

 Метод int chooseFar(int)
 0  ''iload_1''
 1  ''lookupswitch'' 3:
 -100: 36
 0: 38
 100: 40
 default: 42
 36  ''iconst_m1''
 37  ''ireturn''
 38  ''iconst_0''
 39  ''ireturn''
 40  ''iconst_1''
 41  ''ireturn''
 42  ''iconst_m1''
 43  ''ireturn''

Согласно спецификации виртуальной машины Java элементы таблицы смещений инструкции ''lookupswitch'' должны быть отсортированы по ключу, так, чтобы скорость поиска была выше скорости при линейном просмотре таблицы. Даже в этом случае инструкция ''lookupswitch'' выполняет поиск ключа вместо проверки границ принадлежности выражения и использования значения выражения для непосредственного вычисления индекса смещения, как это сделано в инструкции ''tableswitch''. Поэтому инструкция ''tableswitch'' более эффективна, чем ''lookupswitch'', в случае если выбор между ними допустим.

=== Операции со стеком операндов ===

Виртуальная машина Java имеет большой набор инструкций, работающих со значениями стека операндов как с не типизированными значениями. Эти инструкции полезны, поскольку виртуальная машина Java корректно и безопасно манипулирует не типизированными значениями в стеке операндов. Например,

<syntaxhighlight lang="java">   
public long nextIndex() { 
    return index++;
    }

private long index = 0;
</syntaxhighlight>

будет скомпилировано в

 Метод long nextIndex()
 0  ''aload_0''    // Записать в стек ссылку this
 1  ''dup''        // Сделать дубликат ссылки на вершине стека
 2  ''getfield'' #4// Использован один дубликат ссылки this
               // для получения значения поля с типом long,
               // Значение поля размещено над исходной ссылкой this
 5  ''dup2_x1''    // Значение long на вершине стека операндов
               // дублируется и вставляется под ссылкой this
 6  ''lconst_1''   // Записать в стек константу 1 типа long
 7  ''ladd''       // Значение индекса на вершине стека увеличить на единицу...
 8  ''putfield'' #4// ...и результат записать обратно в поле объекта
 11 ''lreturn''    // Исходное значение индекса, оставленное на вершине
               // стека операндов, возвращается из метода

Обратите внимание, что виртуальная машина Java никогда не позволяет изменять или повредить отдельные значения в стеке операндов.

=== Генерация и обработка исключений ===

Исключения генерируются в программе с помощью ключевого слова <code>throw</code>. Его компиляция проста:

<syntaxhighlight lang="java">
void cantBeZero(int i) throws TestExc {
    if (i == 0) {
        throw new TestExc();
    }
}   
</syntaxhighlight>

будет скомпилировано в:

 Метод void cantBeZero(int)
 0  ''iload_1''             // Записать в стек локальную переменную 1 (i)
 1  ''ifne'' 12             // Если i==0, создать экземпляр и выбросить исключение
 4  ''new'' #1              // Создать экземпляр класса TestExc
 7  ''dup''                 // Одна ссылка будет передана конструктору
 8  ''invokespecial'' #7    // Метод TestExc.<init>()V
 11 ''athrow''              // Другая ссылка выброшена в качестве исключения
 12 ''return''              // Если выброшено исключение TestExc, то сюда мы не заходим

Компиляция конструкции <code>try</code>-<code>catch</code> также проста. Например,

<syntaxhighlight lang="java">
void catchOne() {
try {
    tryItOut();
    } catch (TestExc e) {
    handleExc(e);
    }
}   
</syntaxhighlight>

будет скомпилировано в:

 Метод void catchOne()
 0  ''aload_0''             // Начало try блока
 1  ''invokevirtual'' #6    // Метод Example.tryItOut()V
 4  ''return''              // Конец try блока; нормальный выход из метода
 5  ''astore_1''            // Сохранить выбрасываемое исключение в локальной переменной 1
 6  ''aload_0''             // Записать в стек ссылку this
 7  ''aload_1''             // Записать в стек выбрасываемое исключение
 8  ''invokevirtual'' #5    // Вызвать метод-обработчик:
                        // Example.handleExc(LTestExc;)V
 11  ''return''             // Возврат после обработки исключения TestExc
 Таблица исключений:
 От    К     Смещение    Тип
 0     4     5           Класс TestExc

При более внимательном рассмотрении мы можем заметить, что <code>try</code> блок компилируется так, как если бы оператора <code>try</code> не было вообще:

 Метод void catchOne()
 0  ''aload_0''             // Начало try блока
 1  ''invokevirtual'' #6    // Метод Example.tryItOut()V
 4  ''return''              // Конец try блока; нормальный выход из метода

Если в ходе выполнения <code>try</code> блока исключение не было выброшено вообще, то код выполняется, как будто  <code>try</code> отсутствует: вызывается метод <code>tryItOut</code> и происходит возврат из метода <code>catchOne</code>.

Следующий  <code>try</code> блок – это реализация виртуальной машиной Java единственного оператора <code>catch</code>:

 5  ''astore_1''        // Сохранить выбрасываемое исключение в локальной переменной 1
 6  ''aload_0''         // Записать в стек ссылку this
 7  ''aload_1''         // Записать в стек ссылку на выбрасываемое исключение
 8  ''invokevirtual'' #5// Вызвать метод-обработчик:Example.handleExc(LTestExc;)V
 11  ''return''         // Возврат после обработки исключения TestExc
 Таблица исключений:
 От    До     Смещение    Тип
 0     4      5           Класс TestExc


Вызов метода <code>handleExc</code> – обработчика в операторе <code>catch</code> – также компилируется как обычный вызов метода. Однако наличие оператора <code>catch</code> вынуждает компилятор генерировать таблицу исключений (см. §2.10,  §4.7.3). Таблица исключений для метода <code>catchOne</code> имеет одну строку (для экземпляра класса <code>TestExc</code>) соответственно одному оператору <code>catch</code> в методе <code>catchOne</code>. Если будет выброшено исключение – экземпляр класса <code>TestExc</code> – во время выполнения инструкций между индексами ''0'' и ''4'' в методе <code>catchOne</code>, управление будет передано коду, сгенерированному виртуальной машиной Java, начиная с индекса ''5''; этот код реализует обработку оператора  <code>catch</code>. Если будет выброшено исключение, не являющееся экземпляром класса <code>TestExc</code>, оператор <code>catch</code> метода <code>catchOne</code> не обработает его. Вместо этого исключение будет выброшено повторно для метода, вызвавшего <code>catchOne</code>.

Блок <code>try</code> может иметь несколько блоков <code>catch</code>:

<syntaxhighlight lang="java">
void catchTwo() {
    try {
        tryItOut();
    } catch (TestExc1 e) {
        handleExc(e);
    } catch (TestExc2 e) {
    handleExc(e);
    }
}   
</syntaxhighlight>

Для компилирования несколько блоков <code>catch</code> в блоке  <code>try</code> необходимо добавить по одной строке в таблицу исключений для каждого блока <code>catch</code>, а также добавить код вызова обработчика исключения, который выполнить виртуальная машина Java. Пример:

 Метод void catchTwo()
 0  ''aload_0''             // Начало блока try
 1  ''invokevirtual'' #5    // Метод Example.tryItOut()V
 4  ''return''              // Конец try блока; нормальный выход из метода
 5  ''astore_1''            // Начало обработчика TestExc1;
                        // Сохранить выбрасываемое исключение
                        // в локальной переменной 1
 6  ''aload_0''             // Записать в стек ссылку this
 7  ''aload_1''             // Записать в стек ссылку на выбрасываемое исключение
 8  ''invokevirtual'' #7    // Вызвать метод-обработчик:
                        // Example.handleExc(LTestExc1;)V
 11  ''return''             // Возврат после обработки исключения TestExc1
 12  ''astore_1''           // Начало обработчика TestExc2;
                        // Сохранить выбрасываемое исключение
                        // в локальной переменной 1
 13  ''aload_0''            // Записать в стек ссылку this
 14  ''aload_1''            // Записать в стек ссылку на выбрасываемое исключение
 15  ''invokevirtual'' #7   // Вызвать метод-обработчик:
                       // Example.handleExc(LTestExc2;)V
 18  ''return''             // Возврат после обработки исключения TestExc2
 Таблица исключений:
 От     До     Смещение     Тип
 0      4      5            Class TestExc1
 0      4      12           Class TestExc2

Если во время выполнения блока <code>try</code> (между индексами ''0'' и ''4'') будет выброшено исключение соответствующее одному или нескольким блокам <code>catch</code> (исключение является прямым либо не прямым наследником одного из базовых классов <code>TestExc1</code> или <code>TestExc2</code>), то будет выбран первый (самый внутренний) блок <code>catch</code> для обработки. Управление передаётся соответствующему обработчику блока <code>catch</code>. Если выброшенное исключение не соответствует ни одному из блоков <code>catch</code> метода <code>catchTwo</code>, виртуальная машина Java повторно выбрасывает исключение в вызывающем методе; обработка блоков <code>catch</code> метода <code>catchTwo</code> больше не производится.

Вложенные блоки <code>try</code>-<code>catch</code> компилируются похожим на рассмотренную выше компиляцию нескольких блоков <code>catch</code> образом:

<syntaxhighlight lang="java"> 
void nestedCatch() {
try 	{
    try {
        tryItOut();
    } catch (TestExc1 e) {
        handleExc1(e);
    }
} catch (TestExc2 e) {
        handleExc2(e);
  }
}  
</syntaxhighlight>

компилируется в:

 Метод void nestedCatch()
 0  ''aload_0''             // Начало блока try
 1  ''invokevirtual'' #8    // Метод Example.tryItOut()V
 4  ''return''              // Конец try блока; нормальный выход из метода
 5  ''astore_1''            // Начало обработчика TestExc1;
                        // Сохранить выбрасываемое исключение
                        // в локальной переменной 1
 6  ''aload_0''             // Записать в стек ссылку this
 7  ''aload_1''             // Записать в стек ссылку на выбрасываемое исключение
 8  ''invokevirtual'' #7    // Вызвать метод-обработчик:
                        // Example.handleExc1(LTestExc1;)V
 11  ''return''             // Возврат после обработки исключения TestExc1
 12  ''astore_1''           // Начало обработчика TestExc2;
                        // Сохранить выбрасываемое исключение
                        // в локальной переменной 1
 13  ''aload_0''            // Записать в стек ссылку this
 14  ''aload_1''            // Записать в стек ссылку на выбрасываемое исключение
 15  ''invokevirtual'' #6   // Вызвать метод-обработчик:
                        // Example.handleExc2(LTestExc2;)V
 18  ''return''             // Возврат после обработки исключения TestExc2
 Таблица исключений:
 От     До     Смещение     Тип
 0      4      5            Class TestExc1
 0      12     12           Class TestExc2


Вложенность <code>catch</code> блоков отражена только в таблице исключений. Виртуальная машина Java не регламентирует расположение согласно вложенности или любое другое упорядочение элементов таблицы исключений (см. §2.10). Однако, поскольку блоки <code>try</code>-<code>catch</code> структурированы, компилятор всегда может упорядочить элементы так, что для любого выбрасываемого исключения и любого значения программного счетчика в этом методе, первый обработчик, тип исключения которого совпадает с выброшенным исключением, соответствует наиболее подходящему блоку <code>catch</code>.

Например, если вызов <code>tryItOut</code> (индекс операции ''1'') генерирует исключение – экземпляр класса <code>TestExc1</code> – то оно будет обработано блоком <code>catch</code>, вызывающим <code>handleExc1</code>. Это случится, даже если генерирование исключения произойдёт в пределах внешнего блока <code>catch</code> (обрабатывающего <code>TestExc2</code>) и даже если этот внешний блок <code>catch</code> будет способен обработать исключение.

Один нюанс: обратите внимание, что левая граница предела блока <code>catch</code> включает в себя начальное значение, а правая – не включает конечное (см. §4.7.3). Поэтому элемент таблицы исключений соответствующий <code>TestExc1</code> не включает в себя инструкцию ''<code>return</code>'', имеющую смещение ''4''. Тем не менее, элемент таблицы исключений соответствующий <code>TestExc2</code> включает в себя инструкцию ''return'', имеющую смещение ''11''. Инструкции возврата для вложенных <code>catch</code> блоков включаются в пределы объемлющих их блоков.

=== Компиляция инструкции <code>finally</code> ===

(В этом разделе предполагается, что компилятор генерирует <code>class</code>-файлы версии 50.0 или ниже так, что может быть использована инструкция ''jsr''. См. также §4.10.2.5.)

Компиляция структуры <code>try</code>-<code>finally</code> напоминает компиляцию <code>try</code>-<code>catch</code>. Блок <code>finally</code> должен быть выполнен перед передачей управления из блока <code>try</code>, вне зависимости от того, было ли выполнение блока <code>try</code> успешным или аварийным, вследствие выброшенного исключения. Например, 

<syntaxhighlight lang="java">  
void tryFinally() {
    try {
    tryItOut();
    } finally {
    wrapItUp();
    }
} 
</syntaxhighlight>

будет скомпилировано в:

 Метод void tryFinally()
 0  ''aload_0''             // Начало блока try
 1  ''invokevirtual'' #6    // Метод Example.tryItOut()V
 4  ''jsr'' 14              // Вызов блока finally
 7  ''return''              // Конец блока try
 8  ''astore_1''            // Начало обработчика для произвольного исключения
 9  ''jsr'' 14              // Вызов блока finally
 12 ''aload_1''             // Записать в стек ссылку на исключение
 13 ''athrow''              // ...и повторно выбросить исключение в вызывающем методе
 14 ''astore_2''            // Начало блока finally
 15 ''aload_0''             // Записать в стек ссылку this
 16 ''invokevirtual'' #5    // Метод Example.wrapItUp()V
 19 ''ret'' 2               // Возврат из блока finally
 Таблица исключений:
 От     До     Смещение     Тип
 0      4      8            Произвольный

Существуют четыре способа передачи управления из блока <code>try</code>: после достижения конца блока, при выполнении инструкций <code>break</code> или <code>continue</code> внутри блока и при выбросе исключения. Если метод <code>tryItOut</code> не выбросит исключение, управление будет передано блоку <code>finally</code> посредством инструкции  ''jsr''. Инструкция ''jsr'' ''14'', расположенная по индексу ''4'' выполняет «вызов подпрограммы» - обработчика блока <code>finally</code> с индексом ''14'' (такими образом <code>finally</code> представляет собой внутреннюю подпрограмму). Когда выполнение блока <code>finally</code> будет завершено, инструкция ''ret''  ''2'' передаст управление инструкции, следующей за ''jsr''. 

Более детально, вызов подпрограммы работает следующим образом: инструкция ''jsr'' перед переходом записывает в стек операндов адрес следующей инструкции (''return'', имеющей индекс ''7''). Инструкция ''astore_2'' – начало подпрограммы – сохраняет адрес из стека в локальную переменную ''2''.  Начинает выполняться код блока <code>finally</code> (в данном случае инструкции ''aload_0'' и ''invokevirtual''). Предполагая, что выполнение кода будет завершено успешно, инструкция ''ret'' получает адрес возврата из локальной переменной ''2'' и передаёт управление по этому адресу. Затем выполняется инструкция ''return'' и метод <code>tryFinally</code> успешно завершается.

Блок <code>try</code> совместно с блоком <code>finally</code> компилируется в обработчик исключений специального вида – такой, что любое исключение, выброшенное в блоке <code>try</code>, будет перехвачено; и будет вызван блок <code>finally</code>. Если <code>tryItOut</code> выбрасывает исключение, будет выполнен поиск соответствующего обработчика в таблице исключений метода <code>tryFinally</code>. Будет найден обработчик специального вида, и выполнение инструкций продолжится с индекса ''8''. Инструкция ''astore_1'' с индексом ''8'' считывает из стека значение – ссылку на сгенерированное исключение – в локальную переменную ''1''. Следующая инструкция ''jsr'' выполняет переход к началу подпрограммы – блоку <code>finally</code>. Предполагая, что выполнение блоку <code>finally</code> завершится успешно, инструкция ''aload_1'' с индексом ''12'' записывает в стек операндов ссылку на выброшенное исключение, а затем инструкция ''athrow'' повторно выбрасывает исключение.

Компиляция блока <code>try</code> совместно с блоками <code>catch</code> и <code>finally</code> более сложна:

<syntaxhighlight lang="java">
void tryCatchFinally() {
try {
        tryItOut();
    } catch (TestExc e) {
    handleExc(e);
    } finally {
         wrapItUp();
    }
}   
</syntaxhighlight>

будет скомпилировано в

 Метод void tryCatchFinally()
 0  ''aload_0''             // Начало блока try
 1  ''invokevirtual'' #4    // Метод Example.tryItOut()V
 4  ''goto'' 16             // Переход к блоку finally
 7  ''astore_3''            // Начало обработчика TestExc;
                        // Считать из стека ссылку на выброшенное исключение
                        // и сохранить в локальной переменной 3
 8  ''aload_0''             // Записать в стек ссылку this
 9  ''aload_3''             // Записать в стек ссылку на выброшенное исключение
 10 ''invokevirtual'' #6    // Вызвать метод-обработчик:
                        // Example.handleExc(LTestExc;)V
 13 ''goto'' 16             // В этой инструкции ''goto'' нет необходимости,
                        // но она добавлена компилятором javac в JDK версии 1.0.2.
 16 ''jsr'' 26              // Переход к блоку finally
 19 ''return''              // Возврат после обработки исключения TestExc
 20 ''astore_1''            // Начало обработчика исключений
                        // отличных от TestExc, или исключений
                        // выброшенных во время работы TestExc
 21 ''jsr'' 26              // Переход к блоку finally
 24 ''aload_1''             // Записать в стек ссылку на исключение...
 25 ''athrow''              // ...и повторно выбросить исключение в вызывающем методе
 26 ''astore_2''            // Начало блока finally
 27 ''aload_0''             // Записать в стек ссылку this
 28 ''invokevirtual'' #5    // Метод Example.wrapItUp()V
 31 ''ret'' 2               // Возврат из блока finally
 Таблица исключений:
 От     До     Смещение     Тип
 0      4      7            Class TestExc
 0      16     20           any

Если выполнение блока <code>try</code> завершается успешно, инструкция ''<code>goto</code>'' с индексом ''4'' выполнит переход к инструкции с индексом ''16'', вызывающей блок <code>finally</code>. Блок <code>finally</code> начинается с индекса ''26'', успешно выполняется и возвращает управление инструкции ''return'' с индексом ''19''. Затем выполнение <code>tryCatchFinally</code> успешно завершается.

Если метод <code>tryItOut</code> выбрасывает экземпляр исключения <code>TestExc</code>, то будет выбран первый (ближайший) обработчик исключений из таблиц исключений. Код обработчика исключений, начинающийся с индекса ''7'', передаёт ссылку на выброшенное исключение методу <code>handleExc</code> и после его выполнения вызывает блок <code>finally</code> с индексом ''26'' также как и в случае успешного завершения блока <code>try</code>. Если исключение не было выброшено в ходе выполнения <code>handleExc</code>, то выполнение <code>tryCatchFinally</code> завершится успешно.

Если метод <code>tryItOut</code> генерирует исключение, которое не является экземпляром <code>TestExc</code> либо обработчик <code>handleExc</code> сам по себе выбрасывает исключение, в таком случае обработка исключения происходит в соответствии со второй строкой таблицы исключений: интервал индексов инструкций для этой строки изменяется от ''0'' до ''16''.  Обработчик исключения  <code>handleExc</code> начинает работу с инструкции с индексом ''20'', где ссылка на созданное исключение считывается из стека и сохраняется в локальную переменную ''1''. Затем происходит вызов блока <code>finally</code> (вызов как подпрограммы), который начинается с индекса ''26''. Если происходи возврат из блока <code>finaly</code>, то ссылка на исключение считывается из локальной переменной ''1'' и происходит повторное генерирование исключения с помощью инструкции ''athrow''. Если во время выполнения блока  <code>finally</code> будет сгенерировано новое исключение, блок <code>finally</code> завершится аварийно, что в свою очередь приведет к аварийному завершению <code>tryCatchFinally</code> и выбросу исключения в вызвавшем <code>tryCatchFinally</code> методе.

=== Компиляция инструкций синхронизации ===

Синхронизация в виртуальной машине Java осуществляется посредством явного или неявного захвата и освобождения монитора. Явный захват монитора подразумевает использование инструкций ''monitorenter'' и ''monitorexit'', неявный – вызов метода и возврат из метода.

Для кода, написанного на языке программирования Java, наиболее общим способом синхронизации является использование <code>synchronized</code> методов. Метод является синхронизированным не только, если он использует инструкции ''monitorenter'' и ''monitorexit''. В константном пуле времени выполнения для синхронизированного метода установлен флаг <code>ACC_SYNCHRONIZED</code>, который проверяется инструкцией вызова метода (см. §2.11.10).

Инструкции ''monitorenter'' и  ''monitorexit'' используются для компиляции синхронизационных блоков. Например,

<syntaxhighlight lang="java"> 
void onlyMe(Foo f) {
    synchronized(f) {
    doSomething();
    }
}  
</syntaxhighlight>

компилируется в:

 Метод void onlyMe(Foo)
 0  ''aload_1''             // Записать в стек ссылку f
 1  ''dup''                 // Сделать копию ссылки в стеке
 2  ''astore_2''            // Записать из стека значение ссылки
                    // в локальную переменную 2
 3  ''monitorenter''        // Захватить монитор, связанный с f
 4  ''aload_0''             // Удерживая монитор, записать в стек ссылку this и...
 5  ''invokevirtual'' #5    // ...вызвать Example.doSomething()V
 8  ''aload_2''             // Записать в стек локальную переменную 2 (f)
 9  ''monitorexit''         // Освободить монитор, связанный с f
 10 ''goto'' 18             // Успешно завершить метод
 13 ''astore_3''            // В случае любого исключения, перейти сюда
 14 ''aload_2''             // Записать в стек локальную переменную 2 (f)
 15 ''monitorexit''         // Не смотря на исключение освободить монитор!
 16 ''aload_3''             // Записать в стек ссылку на исключение
                        // из локальной переменной  3...
 17 ''athrow''              // ...повторно выбросить исключение в вызывающем методе
 18 ''return''              // Выход из метода
 Таблица исключений:
 От     До     Смещение     Тип
 4      10     13           any
 13     16     13           any

Компилятор гарантирует, что вне зависимости от того, как завершиться метод, каждой выполненной инструкции ''monitorenter'' будет соответствовать одно и только одна выполненная инструкция ''monitorexit''. Это справедливо как для нормального (см. §2.6.4) так и аварийного завершения метода (см. §2.6.5). Чтобы обеспечить соответствие числа инструкций ''monitorenter'' и  ''monitorexit'' при аварийном завершении метода, компилятор генерирует обработчик исключения (§2.10), который перехватит любое исключение и выполнит инструкцию.

=== Аннотации ===

Представление аннотаций в  <code>class</code>-файле, относящихся к типам данных, полям и методам описано в разделах  §4.7.16 и  §4.7.17. Аннотации, относящиеся к пакетам, требуют выполнения дополнительных правил. Эти правила описаны в данном разделе.

Когда компилятор встречает аннотацию, относящуюся к объявлению пакета, он создает  <code>class</code>-файл, содержащий интерфейс, внутреннее имя которого (см. §4.2.1) <code>package-name.package-info</code>. Интерфейс имеет уровень доступа по умолчанию («<code>package</code>-<code>private</code>») и не имеет предков-интерфейсов. В структуре  <code>ClassFile</code> установлены флаги <code>ACC_INTERFACE</code> и  <code>ACC_ABSTRACT</code>. Если для созданного <code>class</code>-файла номер версии меньше чем 50.0, то флаг <code>ACC_SYNTHETIC</code> сброшен; если номер версии больше либо равен, то флаг <code>ACC_SYNTHETIC</code> установлен. В созданном интерфейсе нет статических членов данных, кроме тех, которые создаются согласно ''Спецификации языка программирования Java 7'' (см. §9.2 спецификации).

Аннотации, относящиеся к пакетам, хранятся в атрибутах <code>RuntimeVisibleAnnotations</code> (§4.7.16) и  <code>RuntimeInvisibleAnnotations</code> (§4.7.17) структуры <code>ClassFile</code> интерфейса.

== ГЛАВА 4. Формат <code>class</code>-файла ==

В этой главе описан формат <code>class</code> файла виртуальной машины Java. Каждый <code>class</code>-файл состоит из определения единственного класс или интерфейса. Хотя класс или интерфейс не должен обязательно храниться во внешнем файле (например, класс может генерироваться непосредственно загрузчиком классов), тем не менее, любое корректное представление класса или интерфейса мы будем называть <code>class</code>-файлом.

Class-файл представляет собой последовательность байт, состоящих из восьми бит. Все 16-ти, 32-х и 64-х битовые значения формируются из последовательностей двух, четырёх и восьми байт соответственно.  Элементы, состоящие из нескольких байт, всегда хранятся в порядке от старшего байта к младшему. Данный формат поддерживается виртуальной машиной Java интерфейсами <code>java.io.DataInput</code> и <code>java.io.DataOutput</code>, а также такими классами как <code>java.io.DataInputStream</code> и <code>java.io.DataOutputStream</code>.

В данной главе определен свой собственный набор типов, представляющих данные <code>class</code>-файла. Типы <code>u1</code>,  <code>u2</code> и  <code>u4</code> представляют беззнаковые значения размером один, два и четыре байта соответственно. В платформе Java эти типы могут быть считаны такими методами как <code>readUnsignedByte</code>,  <code>readUnsignedShort</code> и <code>readInt</code> интерфейса <code>java.io.DataInput</code>.

Также в данной главе используется C-подобная нотация для записи псевдоструктур, с помощью которых определен формат <code>class</code>-файла. Для изменения путаницы с полями классов и экземпляров классов, содержимое псевдоструктур мы будем называть ''элементами''. Корректные элементы хранятся в <code>class</code>-файле последовательно без выравнивания по байтам.

Во многих структурах <code>class</code>-файла используются ''таблицы'', состоящие из переменного числа элементов. И хотя мы используем C-подобный синтаксис для обращения к элементам таблицы, это не значит, что индекс элемента может быть непосредственно преобразован в смещение элемента в памяти, поскольку каждый элемент может иметь различную размерность.

Там, где мы обращаемся со структурой <code>class</code>-файла как с массивом, это значит, что она состоит из элементов одинаковой размерности, расположенных непрерывно и по индексу элемента можно вычислить его смещение в памяти.

Замечание. Мы используем данный шрифт для кода на Prolog, а <code>этот шрифт</code> для инструкций виртуальной машины Java и структур <code>class</code>-файла. Комментарии, добавленные с целью разъяснения отдельных моментов, представлены по тексту описания структур <code>class</code>-файлов. Комментарии могут содержать примеры, а также обоснования тех или иных архитектурных решений.

