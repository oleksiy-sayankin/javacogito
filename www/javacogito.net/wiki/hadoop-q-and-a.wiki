__NOTOC__

Перевод: [[Саянкин Алексей Александрович | Саянкин А.А.]]

<br><br><br><br>
'''Предисловие переводчика'''

-----
Данная статья представляет перевод следующих статей:

# http://stackoverflow.com/questions/15164886/hadoop-speculative-task-execution
# http://www.bigdatainterviewquestions.com/hadoop-interview-questions/
# http://www.wiziq.com/blog/31-questions-for-hadoop-developers/ 

<br><br><br><br>

= Каковы наиболее общие форматы входных данных, определённые в  Hadoop? Какой из них используется по умолчанию? =

Наиболее общие форматы входных данных, определённые в  Hadoop это 
* <font face=Courier>TextInputFormat</font>
* <font face=Courier>KeyValueInputFormat</font>
* <font face=Courier>SequenceFileInputFormat</font>

По умолчанию используется <font face=Courier>TextInputFormat</font>.

<br><br><br><br>

= В чём отличие между классами <font face=Courier>TextInputFormat</font> и <font face=Courier>KeyValueInputFormat</font>? =

<font face=Courier>TextInputFormat</font> читает строки из текстового файла и предоставляет смещение строки относительно начала файла в качестве входного ключа для отображения (Mapper), а саму строку в качестве входного значения для отображения (Mapper).

<font face=Courier>KeyValueInputFormat</font>  читает строки из текстового файла производит разбор каждой отдельной строки в пару ключ-значение. Все символы от начала строки и до первого символа табуляции передаются отображению (Mapper) в качестве ключа, а остаток передаётся отображению (Mapper) в качестве значения.

<br><br><br><br>

= Что такое <font face=Courier>InputSplit</font> в Hadoop? =

<font face=Courier>InputSplit</font> — это интерфейс в платформе Hadoop, предоставляющий информацию о расположении фрагментов, на которые разделён входной файл для последующей обработки.  

Когда в Hadoop запускается задание (job), оно разделяет входные файлы на фрагменты (chunk), а затем каждый фрагмент отдаёт на обработку отдельному процессу отображения (Mapper). 

Также <font face=Courier>InputSplit</font> — это  часть входных данных, которая обрабатывается отдельной задачей отображения (map). Каждый <font face=Courier>InputSplit</font> разделяется на записи, а затем отображение обрабатывает отдельную запись, которая представляет собой пару ключ/значение.

Длина <font face=Courier>InputSplit</font> вычисляется в байтах.

Каждый  <font face=Courier>InputSplit</font> имеет некоторое место расположения (строка с именем узла). Место расположения <font face=Courier>InputSplit</font> используется системой MapReduce для расположения заданий отображения (map) настолько близко к данным (в нашем случае <font face=Courier>InputSplit</font>), насколько это возможно.

<br><br><br><br>

= Как происходит разделение файла на фрагменты (<font face=Courier>InputSplit</font>) в платформе Hadoop? =

Разделение файла на фрагменты (<font face=Courier>InputSplit</font>) в платформе Hadoop происходит посредством вызова метода <font face=Courier>getInputSplit()</font> класса, представляющего входной формат данных (такой как <font face=Courier>FileInputFormat</font>). Вызов выполняет сама платформа Hadoop.

<br><br><br><br>

= Произведите расчёт количества фрагментов (split), на которые будут разбиты входные данные. =

Рассмотрим следующий сценарий: 

* В MapReduce системе размер блока равен 64 MB, 
* В качестве входного формата используется FileInputFormat,
* Дано три файла, размерами 64K, 65Mb и 127Mb соответственно.

На сколько входных фрагментов (split) будут разбиты входные файлы?

Платформа Hadoop разобьёт входные данные на 5 фрагментов (split) следующим образом:

* 1 фрагмент (split) для файла размером  64K
* 2 фрагмента для файла размером 65Mb 
* 2 фрагмента для файла размером 127MB

<br><br><br><br>

= Каково предназначение <font face=Courier>RecordReader</font> в Hadoop? =

Класс, реализующий интерфейс <font face=Courier>InputSplit</font>, определяет количество данных, но не определяет как получить доступ к ним. Класс, реализующий интерфейс <font face=Courier>RecordReader</font>, загружает данные и преобразует их в пары ключ-значение, подходящие для процесса отображения (Mapper). Экземпляр класса,  реализующего интерфейс <font face=Courier>RecordReader</font>, создаётся на основе входного формата.

<br><br><br><br>

= После завершения фазы отображения (Map) платформа Hadoop выполняет секционирование (Partitioning), тасовку (Shuffle) и сортировку (Sort). Поясните назначение этих процессов. =

'''Секционирование (Partitioning).'''  Это процесс определения какому процессу свёртки (reducer) будут переданы промежуточные пары ключ/значение из процесса отображения (Map), в случае, если процессов свёртки (reducer) несколько.  Каждая задача отображения (Map) создаёт один раздел (Partition) для задачи одной задачи свёртки (reducer), а также определяет какая задача свёртки (reducer) будет обрабатывать данную пару ключ/значение. В каждом разделе может быть много ключей (и связанных с ними значений), но все записи для заданного ключа находятся в одном разделе. Иными словами, не важно каким процессом отображения (Map) генерируется пара ключ/значение, раздел (Partition) для этой пары ключ/значение будет одним и тем же.   

'''Тасовка (Shuffle).''' После того как первая из задач отображения (map) будет завершена, другие узлы кластера будут всё ещё продолжать выполнять каждый свою задачу отображения (map). Завершённая задача отображение передаёт свои промежуточные результаты на вход задаче свёртки (reduce). Такой процесс передачи промежуточных результатов от задач отображения к задаче свёртки называется тасовкой.

'''Сортировка (Sort).''' Каждая задача свёртки (reduce) отвечает за обработку данных, включающих в себя несколько промежуточных пар ключ/значение. Платформа Hadoop сортирует эти промежуточные пары по ключу, на узле, где происходит выполнение задачи отображения (Map). После сортировки данные передаются задаче свёртки (reduce). 

<br><br><br><br>

= В случае, если пользовательский механизм секционирования не задан, то каким образом платформа Hadoop определяет, в какой раздел записать результирующие данные отображения (Map) перед отправкой процессу свёртки (Reducer)? =

В случае, если пользовательский механизм секционирования не задан, то используется  механизм секционирования по умолчанию, вычисляющий хешкод ключа, и на основании хешкода определяющий раздел (Partition), в который нужно записать данные.

<br><br><br><br>
= Что такое комбинирующая функция в  Hadoop? =

Комбинирующая функция — это что-то вроде «мини свёртки», которая оперирует только данными полученными от единственного процесса отображения. Комбинирующая функция получает на вход все данные, полученные заданным процессом отображения (Map) на заданном узле. Выход комбинирующей функции отправляется затем на вход процессу свёртки (Reduce) вместо выходных данных процесса отображения.

<br><br><br><br>
= Что такое трекер заданий  (JobTracker)? =

Трекер заданий (JobTracker) — это сервис платформы Hadoop, который запускает на кластере задания (Job), построенные согласно модели вычисления MapReduce. Трекером заданий (JobTracker) также называется узел кластера, на котором работает указанный сервис.

<br><br><br><br>
= Каковы типичные функции трекера заданий (JobTracker)? =

При запуске нового задания трекер заданий (JobTracker) выполняет следующие типичные функции: 

* Трекер заданий (JobTracker) делает запрос к узлу умён (Name node) для определения местоположения входных данных.
* Трекер заданий (JobTracker) определяет узлы трекера задач (Tasktracker), на которых есть доступные слоты, причём узлы трекера задач (Tasktracker) должны находится в максимальной близости ко входным данным. 
* Трекер заданий (JobTracker) ставит задачу в очередь задач на выбранных узлах трекера задач (Tasktracker).
* Трекер заданий (JobTracker) мониторит узлы трекера задач (Tasktracker). Если они не посылают  переодический сигнал проверки состояния (heartbeat), то узлы трекера задач (Tasktracker) считаются сбойными. В этом случае задание запускается на работающих узлах трекера задач (Tasktracker).
* Трекер заданий (JobTracker) обновляет статус задачи, когда она выполнена.
* Клиентские приложения могут делать запросы к трекеру задач (JobTracker) для получения информации.
* Также трекер задач (JobTracker) принимает запросы на выполнение нового задания.

<br><br><br><br>

= Что такое трекер задач (TaskTracker)? =

Трекер задач (TaskTracker) — это сервис платформы Hadoop, принимающий  запрос на выполнение задачи от трекера заданий (JobTracker), выполняющий фазы отображения (Map) и свёртки (Reduce) задачи, а также промежуточные задачи между свёрткой и отображением:  секционирование (Partitioning), тасовку (Shuffle) и сортировку (Sort).

Каждый трекер задач (TaskTracker) отвечает за выполнение и управление отдельными задачами, полученными от трекера заданий (Job Tracker). Трекер задач (TaskTracker) запускает отдельную виртуальную машину Java (называется экземпляром задачи) для выполнения непосредственной работы. В случае сбоя в задаче, он произойдёт в отдельной виртуальной машине и не затронет трекер задач (TaskTracker).
Трекер задач (TaskTracker) отвечает за перемещение данных между отображением (map) и свёрткой (reduce).

Трекер задач (TaskTracker) переодически сообщает трекеру заданий (Job Tracker) о текущем статусе задания. Трекер задач (TaskTracker) также передаёт  трекеру заданий (Job Tracker) код завершения задачи. 

Если трекер заданий (Job Tracker)  не получает переодический сигнал проверки состояния трекер задач (TaskTracker), то трекер задач считается сбойным и затем трекер заданий (Job Tracker) повторно запускает задачу на другом (не сбойном) трекере задач (TaskTracker).

<br><br><br><br>

= Как относятся между собой задания (Job) и задачи (Task) в Hadoop? =

Задание (Job) разбивается на одну или более задач (Task) в Hadoop.

<br><br><br><br>
= Предположим, что платформа Hadoop разбила задание (Job)  на 100 задач (Task), одна из которых завершилась аварийно. Что сделает платформа Hadoop в этом случае? =

Платформа Hadoop повторно запустит задачу (Task) на другом трекере задач (TaskTracker) и если задача завершится аварийно более чем четыре раза (значение по умолчанию и может быть изменено), то  Hadoop остановит задание (Job). 

<br><br><br><br>
= Платформа Hadoop достигает параллелизма в работе за счёт распределения задач по множеству узлов. Если один из узлов работает медленно, это может привести к общему замедлению выполнения всего задания. Каков механизм предотвращения этого? =

Спекулятивные вычисления.

<br><br><br><br>
= Как работают спекулятивные вычисления в Hadoop? =

Одна из проблем, возникающих при использовании Hadoop для распределённых вычислений, это замедление работы всего кластера из-за медленной работы одного из узлов.
Задачи могут выполняться медленно по многим причинам, включая медленно работающее оборудование, неверную конфигурацию программного обеспечения, но выяснить причину зачастую бывает сложно, поскольку несмотря на медленную работу, задачи тем не менее выполняются успешно хотя и дольше чем ожидалось. Платформа Hadoop не пытается диагностировать и исправлять причину медленной работы; вместо этого она пытается определить тот момент, когда исполняемая задача работает дольше чем ожидалось и запускает аналогичную задачу в качестве резервной. Такой процесс выполнения резервной копии для медленно работающих задач называется спекулятивным выполнением задач (спекулятивными вычислениями). 

Например, если один из узлов имеет медленный привод диска, то такой узел может читать входные данные только со скоростью 10% по отношению к узлу с обычным приводом диска. Так что, когда 99 задач отображения (Map) будут выполнены, система будет ждать завершения последней задачи отображения, причём время ожидания будет намного больше чем для аналогичных задач на других узлах. 
Поскольку задачи отображения работают независимо друг от друга,  отдельная задача не имеет информации о том, откуда поступили её входные данные. Задачи отображения полагаются на платформу Hadoop при получении входных данных. Поэтому некоторые входные данные могут быть обработаны несколько раз в параллельном режиме, чтобы компенсировать разницу в мощности узлов. Как только большинство задач (Task), составляющих задание (Job), подходят к завершению выполнения, платформа Hadoop запустит на выполнение дополнительные копии оставшихся задач на узлах, которые менее остальных загружены работой. Этот процесс известен как спекулятивные вычисления. Когда задачи будут выполнены, они сообщат об это трекеру заданий (JobTracker). Причём не важно, какая именно из задач завершиться первой (основная или дополнительная копия) — именно её результаты используются для последующей обработки. Если есть ещё копии, выполняющиеся спекулятивно, платформа Hadoop даст команду трекеру задач (TaskTracker) прервать их выполнение и игнорировать результаты. Процессы свёртки (Reducer) получают на вход данные из любого процесса (основного или дополнительного) отображения (Mapper), который завершился первым. 

По умолчанию, спекулятивные вычисления включены. Выключить их можно для процессов отображения (Map)  и свёртки (Reduce) задав свойства mapred.map.tasks.speculative.execution и mapred.reduce.tasks.speculative.execution в false соответственно для старого API и mapreduce.map.speculative и mapreduce.reduce.speculative для нового.

<br><br><br><br>

= Как с помощью командной строки Linux посмотреть список всех заданий (Job), запущенных в кластере Hadoop? Остановить выполнение задания (Job)? =

С помощью командной строки Linux посмотреть список всех заданий (Job), запущенных в кластере Hadoop, можно следующим образом:

<font face=Courier>
:: hadoop job -list
</font>

Остановить выполнение задания (Job) с помощью командной строки Linux можно следующим образом:

<font face=Courier>
:: hadoop job -kill <JobID>
</font>

<br><br><br><br>

= Что такое Hadoop Streaming? =

Hadoop Streaming — это общий API, позволяющий программе, написанной теоретически на любом языке, реализовать фазы отображения (Map) и свёртки (Reduce) в платформе Hadoop. 

<br><br><br><br>
= Какая характеристика интерфейса Hadoop Streaming делает доступным запуск задач (Job), написанных на языках Perl, Ruby, Awk (и других), в модели вычислений MapReduce? =

Интерфейс Hadoop Streaming позволяет программам, написанным на произвольных языках, выполняться в фазах отображения (Map) и свёртки (Reduce) благодаря тому, что как отображение (Map) так и свёртка (Reduce) получают входные данные из стандартного потока ввода (stdin), а результаты записывают в стандартный поток вывода (stdout).

<br><br><br><br>
= Что такое распределённых кеш в Hadoop? =

Распределённый кеш в Hadoop — это средство кеширования файлов (текстовых файлов, архивов, jar-файлов и так далее), которые нужны приложениям во время их работы в кластере. Платформа Hadoop копирует необходимые файлы на узлы данных прежде чем задача (Job) будет запущена на этом узле.

<br><br><br><br>
= Каковы преимущества распределённого кеша? Почему мы не можем просто поместить необходимые файлы HDFS и дать возможность приложениям считать их? =

Мы не помещаем необходимые файлы HDFS потому, что распределённый кеш намного быстрее. Перед стартом задачи (Job) платформа Hadoop копирует необходимые файлы на все узлы, где будут запущены трекеры задач (TaskTracker). Теперь, если трекер задач (TaskTracker) запустит на выполнение 10 или 100 процессов отображений (Map) или свёрток (Reduce), то каждый такой процесс будет использовать свою копию файла. С другой стороны, если вы напишите код для чтения данных из HDFS, в программе MapReduce, то каждая задача отображения (Map) будет пытаться получить файл из HDFS. Следовательно, если трекер задач (TaskTracker) запустит 100 задач отображения (Map), то файл будет прочитан 100 раз. HDFS не совсем подходит для такого использования файлов.

<br><br><br><br>

= Какой механизм предоставляет платформа Hadoop для синхронизации изменений в распределённом кеше, выполненных во время работы приложения? =

Такого механизм нет. Распределённый кеш спроектирован только на чтение данных во время работы приложения (Job).

<br><br><br><br>
= Для чего используются счётчики (Counters) в Hadoop? =

Счётчики (Counters) являются полезным инструментом для сборка статистики о задании (Job), которая используется как с целью анализа ошибок в ходе выполнения задания, так и с целью сбора общей информации о задании. Вместо вывода сообщений в журнал (Log) из задач отображения (Map) или свёртки (Reduce) бывает лучше воспользоваться счётчиком для регистрации определённых условий. Hadoop ведёт для каждого задания набор встроенных счётчиков для вычисления различных метрик. Например, имеются счётчики количества обработанных байтов и записей; по ним можно убедиться в том, было ли обработано ожидаемое количество данных и сгенерирован ожидаемый объём выходных данных.

Ещё пример. Предположим у вас есть кластер из 100 узлов и задание (job), состоящее из 100 отображений (map), работающих на 100 различных узлах. Также допустим, что вы ходите получать информацию о каждой неверной записи в фазе отображения. Для этого вы можете добавить сообщение отладки в класс отображения (Map) таким образом, что каждый раз, когда отображение обнаружит неверную строку, оно сделает соответствующую запись в файле журнала. Но объединение всех журнальных сообщений из 100 различных узлов может быть очень затратным по времени. Вместо этого вы можете использовать счётчик,  увеличивая его значение всякий раз, при обнаружении неверной записи. Удобство в использовании счётчиков в том, что вы получаете сразу итоговое значение количества неверных записей, вместо 100 файлов журналов, в которых хранятся ваши сообщения о неверных записях по отдельности.

<br><br><br><br>
= Можно ли предоставить множественный ввод в Hadoop? Если да, то как задать несколько директорий в качестве входных данных для задачи (job). =

Да, множественный ввод допустим в Hadoop. Класс <font face=Courier>FileInputFormat<K,V></font> содержит методы для добавления входных путей к задаче (job).

<br><br><br><br>

= Допустимо ли для задания (job) Hadoop иметь множественный вывод в несколько директорий. Если да, то каким образом? =

Да, для  задания (job) иметь множественный вывод в несколько директорий допустимо. Достигается с помощью использование класса <font face=Courier>MultipleOutputs<KEYOUT,VALUEOUT></font>.

<br><br><br><br>

= Что произойдёт с заданием (job) Hadoop при попытке указать в качестве выходной директории уже существующую директорию? =

Задание (job) Hadoop в данном случае выбросит исключение и завершит свою работу аварийно.

<br><br><br><br>
= Как задать произвольное число отображений (mapper) в задании (job) Hadoop? =

Это невозможно в рамках существующей реализации. Число отображений не задаётся произвольно, а зависит от размера входных данных и параметров конфигурации Hadoop (точнее говоря количество отображений (mapper) определяется количеством входных сплитов).

<br><br><br><br>
= Как задать произвольное число свёрток (Reducer) в задании (job) Hadoop? =

Число свёрток (Reducer)  в задании (job) можно задать либо вызвав метод <font face=Courier>setNumReduceTasks</font> класса <font face=Courier>org.apache.hadoop.mapred.JobConf</font> либо через файлы конфигурации (свойство <font face=Courier>mapred.reduce.tasks</font>). 

<br><br><br><br>

= Как создать пользовательскую реализацию механизма секционирования? =

Для создания  пользовательской реализации механизма секционирования необходимо выполнить минимум три вещи:

* создать новый класс, являющийся наследником класса <font face=Courier>org.apache.hadoop.mapreduce.Partitioner<KEY,VALUE></font>
* реализовать абстрактный метод <font face=Courier>getPartition(KEY key, VALUE value, int numPartitions)</font>
* в классе-обёртке, запускающем задание (job) добавить программно  пользовательскую реализацию механизма секционирования с помощью метода <font face=Courier>setPartitionerClass(Class<? extends Partitioner> cls)</font> класса <font face=Courier>org.apache.hadoop.mapreduce.Job</font>

<br><br><br><br>

= Как выполнить отладку кода Hadoop? =

Есть несколько способов для выполнения отладки кода Hadoop:

* с помощью добавления счётчиков для заданий (job).
* настройкой удалённой отладки для отображения (map) в файле <font face=Courier>mapred-site.xml</font>

<font face=Courier>
<property>

::<name>mapred.map.child.java.opts</name>

::<value>-Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y</value>

</property>
</font>

<br><br><br><br>

= Как необходимо проводить отладку задач (job) Hadoop с низкой производительностью или долго работающих задач? =

Существует несколько сценариев. В самом общем виде вы должны выполнить следующие шаги:

# Понять симптомы проблемы.
# Проанализировать текущее положение дел.
# Определить области существования проблемы.
# Предложить решение.


'''Сценарий 1.''' Задача (Job) из 100 отображений (map) и одной свёртки (reduce) надолго «зависает» после того как все отображения (map) завершили работу, а свёртка (reduce) ещё  не начиналась. Одна из причин может быть в том, что свёртка (reduce) тратит много времени копируя выходные данные отображений (map) для последующей работы с ними. В этом случае можно выполнить следующие действия:

# Если возможно, то добавить комбинирующую функцию для уменьшения количества выходных данных, пересылаемых от отображений (map) к свёртке (reduce).
# Настроить сжатие выходных данных отображений (map) — это уменьшит размер передаваемой информации от отображений (map) к свёртке (reduce). 


'''Сценарий 2.''' Задача (Job) использует слишком много памяти, что приводит к замедлению работы или аварийной остановке. В этом случае можно выполнить следующие действия:

# Проверить , что соединения таблиц выполняются с оптимальным распределением памяти. Например, в Pig соединениях вначале свёртке посылаются левые таблицы (слева от оператора соединения), которые затем хранятся в памяти, а правые таблицы (справа от оператора соединения) передаются свёртке потоком.
# Мы можем также увеличить требования к памяти для отображений и свёрток, задавая параметры <font face=Courier>mapreduce.map.memory.mb и mapreduce.reduce.memory.mb</font>


'''Сценарий 3.''' Понимание структуры данных позволяет оптимизировать их обработку в запросах PIG и HIVE.

# Если вам необходимо соединять таблицы небольшого размера, из можно хранить в распределённом кеше и загружать в память во время выполнения отображения (Map), и поэтому всё соединение может быть выполнено только с использованием отображений. При этом можно избежать как стадии тасовки (Shuffle) так и стадии свёртки (reduce). Это значительно увеличивает производительность. В Pig необходимо использовать <font face=Courier>USING REPLICATED</font>, а в Hive — опцию  <font face=Courier>hive.auto.convert.join</font>.
# Если входные данные уже отсортированы по ключу, в  Pig можно использовать <font face=Courier>USING MERGE</font> для выполнения соединений только с помощью отображений (Map).
# Если данные сегментированы (bucketted) в  Hive то можно использовать опции <font face=Courier>hive.optimize.bucketmapjoin</font> и <font face=Courier>hive.optimize.bucketmapjoin.sortedmerge</font> в зависимости от характеристик данных. 


'''Сценарий 4.''' Процесс тасовки (Shuffle) — это сердце программы MapReduce и именно там можно добиться наибольшего улучшения производительности.

# Если вы видите, что много записей записываются на диск (проверьте счётчик в выводе программы Spilled Records), вы можете увеличить память, доступную для отображений (Map), увеличив значение переменной <font face=Courier>io.sort.mb</font>. Это уменьшит количество выводов отображений (Map), так что сортировка ключей может быть выполнена в памяти.
# На стороне свёртки (Reduce) операция слияния (объединение вывода нескольких отображений (Map)) может быть выполнена на диске установкой параметра <font face=Courier>mapred.inmem.merge.threshold</font> в ноль.

<br><br><br><br>

= Предположим есть три команды: исследовательская, маркетинговая и финансовая, которым необходимо соответственно 60%, 30% и 10% мощностей кластера. Как вы назначите 60% ресурсов кластера исследовательской команде, 30% - маркетинговой, и 10% - финансовой во время пиковых нагрузок? =

Для этой задачи предназначен планировщик нагрузки (Capacity scheduler) в Hadoop. Планировщик нагрузки поддерживает иерархические очереди, причём мощность может быть задана для каждой отдельной очереди. 

В нашем случае необходимо задать три очереди под корневой очередью и установить соответствующий процент нагрузки для каждой из очередей. 


:: '''Пример. Настройка трёх очередей в планировщике нагрузки'''

:: Ниже заданы свойства в файле <font face=Courier>capacity-scheduler.xml</font>. 

<font face=Courier>
:: <property>

::: <name>yarn.scheduler.capacity.root.queues</name>

::: <value>research,marketing,finance</value>

:: </property>

:: <property>

::: <name>yarn.scheduler.capacity.research.capacity</name>

::: <value>60</value>

:: </property>

:: <property>

::: <name>yarn.scheduler.capacity.research.capacity</name>

::: <value>30</value>

:: </property>

:: <property>

::: <name>yarn.scheduler.capacity.research.capacity</name>

::: <value>10</value>

:: </property>
</font>

<br><br><br><br>

= Как бы вы выполнили эталонное тестирование кластера с помощью стандартных средств Hadoop? =

'''TestDFSIO'''

:: Утилита TestDFSIO предоставляет информацию о производительности ввода/вывода вашего кластера. Она выполняет тесты чтения/записи и является полезной в определении узких мест в вашей сети, аппаратном обеспечении, а также настройки ваших узлов данных (DataNode) и узлов имён (NameNode).

'''NNBench'''

:: NNBench эмулирует запросы на создание, чтение, переименование и удаление файлов в HDFS и полезна для нагрузочного тестирования настройки аппаратного обеспечения узла имён (NameNode).

'''MRBench'''

:: MRBench — это тест модели вычислений MapReduce. Он запускает в цикле небольшую задачу MapReduce определённое количество раз и проверяет эффективность кластера.


:: '''Пример. Запуск утилит проверки кластера'''

:: TestDFSIO тестирует запись на 100 файлах, каждый из которых 100 МБ.

:: <font face=Courier>$ hadoop jar /dirlocation/hadoop-test.jar TestDFSIO -write -nrFiles 100 -fileSize 100</font>


:: TestDFSIO тестирует чтение на 100 файлах, каждый из которых 100 МБ.

:: <font face=Courier>$ hadoop jar /dirlocation/hadoop-test.jar TestDFSIO -read -nrFiles 100 -fileSize 100</font>


:: MRBench запускает набор из 50 небольших заданий.

:: <font face=Courier>$ hadoop jar /dirlocation/hadoop-test.jar mrbench -numRuns 50</font>


:: NNBench создаёт 1000 файлов используя 12 отображений (map) и 6 свёрток (reducer).

<font face=Courier>
:: $ hadoop jar /dirlocation/hadoop-test.jar nnbench -operation create_write \
:: -maps 12 -reduces 6 -blockSize 1 -bytesToWrite 0 -numberOfFiles 1000 \
:: -replicationFactorPerFile 3
</font>
<br><br><br><br>

= Какая разница между входными сплитами и блоками? =

Блок представляет собой единицу физического разделения данных, в котором не учитываются логические границы данных. Это означает, что запись может начаться в одном блоке и закончится в другом. В то время как входные сплиты учитывают логические границы записей. 

<br><br><br><br>
= Как выполнить проверку работоспособности файловой системы HDFS? =

Для проверки работоспособности файловой системы HDFS используется утилита FSCK. Она очень удобна для проверки целостности файла, имён блоков и расположения блоков.


:: '''Пример. Запуск утилиты  FSCK.'''

:: <font face=Courier>hdfs fsck /dir/hadoop-test -files -blocks -locations</font>

<br><br><br><br>

= Каковы параметры функций отображений (map) и свёртки (reducer)? =

Сигнатуры методов отображения и свёртки много говорят о типе входных и выходных данных, которыми работает задание (Job). В предположении что вы используете <font face=Courier>TextInputFormat</font>, параметры функции отображения (Map) могут выглядеть следующим образом:

* <font face=Courier>LongWritable</font> (Входной ключ)
* <font face=Courier>Text</font> (Входное значение)
* <font face=Courier>Text</font> (Промежуточный выходной ключ)
* <font face=Courier>IntWritable</font> (Промежуточное выходное значение)


Четыре параметра функции свёртки (reduce) могут быть такими:

* <font face=Courier>Text</font> (Промежуточный выходной ключ)
* <font face=Courier>IntWritable</font> (Промежуточное выходное значение)
* <font face=Courier>Text</font> (Окончательный выходной ключ)
* <font face=Courier>IntWritable</font> (Окончательное выходное значение)

<br><br><br><br>

= Как переопределить фактор репликации? =

Есть несколько способов сделать это. Смотрите пример ниже.


:: '''Пример. Переопределение фактора репликации.'''

<font face=Courier>
:: hadoop fs -setrep -w 5 -R hadoop-test

:: hadoop fs -Ddfs.replication=5 -cp hadoop-test/test.csv hadoop-test/test_with_rep5.csv
</font>

<br><br><br><br>

= Каковы функции <font face=Courier>InputFormat</font>? =

Функции <font face=Courier>InputFormat</font> следующие:

* Проверить, что входные данные существуют, а также проверить входную конфигурацию.
* Создать входные сплиты (<font face=Courier>InputSplits</font>) на основании блоков данных.
* Создать реализацию <font face=Courier>RecordReader</font> для получения пар ключ/значение из входных сплитов. Эти пары  ключ/значение одна за одной будут отправлены отображению (mapper).

<br><br><br><br>

= Для чего предназначен формат файла <font face=Courier>SequenceFile</font> в Hadoop? =

Формат файла <font face=Courier>SequenceFile</font> используется для хранения двоичных пар ключ/значение. Формат <font face=Courier>SequenceFile</font> позволяет разделять файл даже если данные внутри файла хранятся в сжатом виде, что невозможно при обычном архивировании файлов. Вы можете выбрать как сжатие на уровне записи, при котором отдельные пары ключ/значение будут сжаты. Либо вы можете выбрать сжатие на уровне блока, несколько записей будут сжаты вместе.

<br><br><br><br>

= Что такое платформа Hadoop? =

Hadoop — это свободно распространяемая платформа, основанная на языке программирования Java и позволяющая проводить вычисления над большими объёмами данных в распределённых кластерах.

Hadoop является частью проекта Apache, который спонсируется фондом Apache Software Foundation.
Hadoop позволяет запускать приложения в кластерах, состоящих из тысяч узлов и проводя обработку тысяч терабайт данных. Его распределённая файловая система способствует увеличению скорости передачи данных между узлами и позволяет всему кластеру в целом продолжать работу, даже если один из узлов остановится аварийно. Данный подход снижает риск полного отказа кластера, даже если значительное число узлов выйдут из строя.
Hadoop используется многими компаниями, такими как Google, Yahoo и IBM, в основном в приложениях поиска информации и контекстной рекламы.
Предпочтительные операционные системы, с которыми работает Hadoop это Linux и Hadoop, но также допустимы как BSD так и OS X.

<br><br><br><br>
= Что такое MapReduce? =

MapReduce — это модель параллельных вычислений, которая используется для работы с большими объёмами данных в Hadoop кластере, состоящим из сотен или даже тысяч узлов.

Модель MapReduce переносит вычисления к месту расположения данных в отличие от традиционной модели параллелизма, в которой данные переносятся к вычислениям.
Вычисления в модели MapReduce состоят из двух фаз: отображения (Map) и свёртки (Reduce). В первой фазе — отображение (Map) — происходит преобразование входного набора данных в выходной, в котором элементы разбиты на кортежи (пары ключ/значение).  Во второй фазе — свёртка (Reduce) — происходит обработка результатов предыдущей фазы и преобразование данных также в набор пар ключ/значение, но уже меньшего размера. Как видно из самого названия модели вычислений MapReduce свёртка (Reduce) всегда выполняется после отображения (Map). Язык, на котором реализована модель MapReduce — это Java. Все данные, которые подлежат обработке в модели вычислений  MapReduce дожны быть представлены в виде пар ключ/значение.

<br><br><br><br>
= Какова структура программы MapReduce? =

Программа MapReduce состоит из трёх следующих частей:

* Драйвер
* Отображение (Mapper)
* Свёртка (Reducer)


# '''Драйвер''' запускается на клиентской машине и отвечает за построение файла конфигурации задания (job) и запуск задания в кластере Hadoop. Код драйвера содержит метод main(), который принимает аргументы из командной строки.
# '''Отображение (Mapper)''' читает данные из входных файлов в виде пар <Ключ, Значение> и сохраняет выходные пары. Отображение (Mapper) наследуется от класса MapReduceBase и реализует интерфейс Mapper. Интерфейс <font face=Courier>Mapper</font> параметризирован четырьмя обобщёнными типами, соответствующими парам входных и выходных данных ключ/значение.  Первые два параметра определяют входные типы ключа и значения, вторые два параметра определяют выходные ключ и значение.
# '''Свёртка (Reducer)'''  читает данные сгенерированные различными отображениями в виде пар <Ключ, Значение> и сохраняет выходные пары. Свёртка (Reducer) наследуется от класса MapReduceBase и реализует интерфейс Reducer. Интерфейс <font face=Courier>Reducer</font> параметризирован четырьмя обобщёнными типами, соответствующими парам входных и выходных данных ключ/значение. Первые два параметра определяют промежуточные типы ключа и значения, вторые два параметра определяют окончательные выходные ключ и значение. Ключи реализуют интерфейс <font face=Courier>WritableComparable</font>, значения — <font face=Courier>Writable</font>.

<br><br><br><br>

= Какие интерфейсы необходимо реализовать, чтобы создать отображение (Mapper) и свёртку (Reducer) в Hadoop? =

Чтобы создать отображение (Mapper) и свёртку (Reducer) в Hadoop необходимо реализовать следующие интерфейсы:

* <font face=Courier>org.apache.hadoop.mapreduce.Mapper</font>
* <font face=Courier>org.apache.hadoop.mapreduce.Reducer</font>

<br><br><br><br>

= Что делает отображение (Mapper) в Hadoop? =

Отображение (Mapper) — это первая фаза в модели вычислений  MapReduce, в ходе которой происходит чтение входных пар ключ/значение и формирование промежуточных пар ключ/значение.

Отображения (Mapper) представляют собой отдельные задачи по преобразованию входных записей в промежуточные записи.
Полученные промежуточные записи не обязательно должны быть того же типа, что и входные записи. Также данная входная пара ключ/значение может не соответствовать ни одной выходной паре или соответствовать сразу нескольким. 

<br><br><br><br>
= Сколько и какие фоновые процессы обычно запущены в кластере Hadoop? =

Hadoop включает в себя пять отдельных фоновых процессов. Каждый из них запущен в отдельной виртуальной машине Java. Следующие три фоновых процесса работают на ведущих узлах:

* '''NameNode (узел имён)''' — этот фоновый процесс хранит и обновляет метаданные для HDFS. NameNode — главный фоновый процесс в Hadoop, который управляет пространством имён файловой системы и предоставляющий доступ к файлам кластера.

* '''Secondary NameNode (вторичный узел имён)''' - этот фоновый процесс не является дублирующим для процесса  NameNode (как можно было бы подумать из названия), а переодически выполняет сохранение контрольных точек файловой системы и проводит слияние образа пространства имён с журналом изменений, чтобы предотвратить чрезмерное разрастание последнего. 

* '''JobTracker(трекер задач)''' — Каждый кластер имеет единственный экземпляр трекера задач, который управляет задачами (job) MapReduce и распределяет задания (task) между трекерами  заданий TaskTracker.

Следующие два фоновых процесса работают на каждом из подчинённых узлов:

* '''DataNode(узел данных)''' — хранит актуальные блоки данных HDFS. Фоновый процесс узла данных управляет хранилищами, подключёнными к узлу. Узлов данных может быть несколько. Каждый узел данных будет иметь соответствующий фоновый процесс. 

* '''TaskTracker (трекер заданий)''' — отвечает за создание и проверку состояния отдельных заданий отображения (Map) и свёртки (Reduce), то есть трекер заданий на узле данных и выполняет фактическую работу.

<br><br><br><br>

= Что произойдёт, если узел трекера задач (JobTracker) остановит свою работу вследствие неисправности? =

В Hadoop 1.0 узел трекера задач (Job Tracker) является так называемой единой точкой отказа, что означает, если узел трекера задач (Job Tracker) будет неисправен, то все задания должны быть запущены повторно. Иными словами весь поток выполнения задач будет прерван. Эта одна из причин по которой в Hadoop 2.0 концепция трекера задач была заменена на YARN.

В  YARN (Yet Another Resource Negotiator — ещё один планировщик ресурсов — ''прим. перев.'') понятия трекер задач (JobTracker) и трекер заданий (TaskTracker) полностью удалены. Вместо этого две главные задачи трекера задач (JobTracker) в YARN, а именно: управление ресурсами и повторный перезапуск/мониторинг заданий — разделены между двумя компонентами:

* Менеджер ресурсов (Resource Manager)
* Менеджер узлов (Node Manager)

<br><br><br><br>

= Что произойдёт в случае отказа узла данных (DataNode)? =

В случае отказа узла данных происходит следующее:

* Узел имён (namenode) определяет аварийный узел данных. Узел имён использует переодический сигнал проверки состояния узла данных и если узел данных не отвечает на сигнал в течении заданного времени — он считается сбойным.
* Узел имён (namenode) выполняет повторное реплицирование блоков, находящихся на сбойном узле данных, сохраняя реплики на других доступных узлах.

<br><br><br><br>

= Назовите основные параметры конфигурации, которые необходимо задать для запуска задания (Job) MapReduce? =

Пользователи платформы Mapreduce должны определить:

* Расположение входных данных задания (Job) в распределённой файловой системе.
* Расположение выходных данных задания (Job) в распределённой файловой системе.
* Формат входных данных.
* Формат выходных данных.
* Класс, содержащий функцию отображения (map).
* Класс, содержащий функцию свёртки (reduce).
* JAR файл, содержащий реализацию классов отображения (map), свёртки (reduce) и драйвера.

<br><br><br><br>

= Поясните, что такое  переодический сигнал проверки состояния (Heartbeat) в Hadoop? =

Переодический сигнал проверки состояния (Heartbeat) — это сигнал, который используется между узлом данных (data node) и узлом умён (Name node), а также между трекером заданий (JobTracker) и трекером задач (task tracker) для проверки состояния узла данных и трекера задач. Если узел данных (data node) либо трекер задач (task tracker) перестают посылать переодический сигнал проверки состояния в течении заданного времени, то они считаются сбойными.

<br><br><br><br>
= В чем отличие HDFS (Hadoop Distributed File System) от NAS (Network Attached Storage)? = 

Существуют следующие отличия HDFS и NAS:

* В HDFS блоки данных распределены между локальным дисками всех узлов кластера, в то время как в NAS данные хранятся только в специализированных дисках.
* HDFS спроектирован для работы в модели вычислений MapReduce и поэтому вычисления переносятся к данным.  NAS не подходит для  модели вычислений MapReduce, поскольку данные хранятся отдельно от места, где происходит их обработка.
* HDFS работает на кластере из нескольких машин и хранит данные с избыточностью, используя протокол репликации. В то время как NAS использует одну машину и поэтому не хранит данные с избыточностью.

<br><br><br><br>

= Как изменить файл в HDFS в произвольном месте данного файла? =

HDFS не поддерживает изменение файлов в произвольном месте. Также не поддерживается множественная запись в один и тот же файл. Модификация файла происходит путём добавления информации в конец файла.

[[Категория:Переводы на русский язык]]

