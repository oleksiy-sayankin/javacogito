'''Список инструкций JVM с правилами проверки их безопасности''' - перевод на русский язык главы [[Спецификация виртуальной машины Java|Спецификации виртуальной машины Java]].
<br><br><br>
Перевод: [[Саянкин Алексей Александрович | Саянкин А.А.]]

{| width="100%"
| style="text-align:left;"  | '''''aaload'''''
| style="text-align:right;"  | '''''aaload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''aaload'' безопасна по типу тогда и только тогда, когда мы правомерно можем заменить тип <font face=Courier>int</font> и массив с компонентами <font face=Courier>ComponentType</font>, где <font face=Courier>ComponentType</font> это подтип  <font face=Courier>Object</font>  на <font face=Courier>ComponentType</font> равный  выходному состоянию типов.
|}
 
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">instructionIsTypeSafe(aaload, Environment, _Offset, StackFrame,
			NextStackFrame, ExceptionStackFrame) :-
    nth1OperandStackIs(2, StackFrame, ArrayType),
    arrayComponentType(ArrayType, ComponentType),
    isBootstrapLoader(BL),
    validTypeTransition(Environment,
			  [int, arrayOf(class('java/lang/Object', BL))],
                        ComponentType, StackFrame, NextStackFrame),
exceptionStackFrame(StackFrame, ExceptionStackFrame).   
</syntaxhighlight>
|}

{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Тип компонента массива <font face=Courier>X</font> это <font face=Courier>X</font>. Мы определяем тип компонента <font face=Courier>null</font> равным <font face=Courier>null</font>.
|}
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
arrayComponentType(arrayOf(X), X).
arrayComponentType(null, null).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aastore'''''
| style="text-align:right;"  | '''''aastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''aastore'' безопасна по типу тогда и только тогда, когда мы правомерно можем считать из входящего стека операндов типы, соответствующие <font face=Courier>Object</font>, <font face=Courier>int</font> и массиву <font face=Courier>Object</font> и после этого получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(aastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    isBootstrapLoader(BL),
    canPop(StackFrame,
           [class('java/lang/Object', BL),
           int,
           arrayOf(class('java/lang/Object', BL))],
           NextStackFrame),
exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aconst_null'''''
| style="text-align:right;"  | '''''aconst_null'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''aconst_null'' безопасна по типу тогда и только тогда, когда мы правомерно можем записать во входящий стек тип <font face=Courier>null</font> и после этого получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(aconst_null, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], null, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aload'''''
| style="text-align:right;"  | '''''aload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''aload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>reference</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(aload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
     loadIsTypeSafe(Environment, Index, reference,
     StackFrame,  NextStackFrame),
     exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aload_<n>'''''
| style="text-align:right;"  | '''''aload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''aload_<n>'' для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''aload'' безопасна по типу. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(aload_0,aload(0)).
instructionHasEquivalentTypeRule(aload_1,aload(1)).
instructionHasEquivalentTypeRule(aload_2,aload(2)).
instructionHasEquivalentTypeRule(aload_3,aload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''anewarray'''''
| style="text-align:right;"  | '''''anewarray'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''anewarray'' с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда  <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего либо класс, либо массив и можно правомерно заменить тип <font face=Courier>int</font> во входящем стеке операндов на массив с компонентами  <font face=Courier>CP</font> и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(anewarray(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    (CP = class(_, _) ; CP = arrayOf(_)),
    validTypeTransition(Environment, [int], arrayOf(CP),
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''areturn'''''
| style="text-align:right;"  | '''''areturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''areturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>ReturnType</font> равный типу <font face=Courier>reference</font> и допустимо считать тип соответствующий <font face=Courier>ReturnType</font> из входящего стека операндов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(areturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, ReturnType),
    isAssignable(ReturnType, reference),
    canPop(StackFrame, [ReturnType], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''arraylength'''''
| style="text-align:right;"  | '''''arraylength'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''arraylength'' безопасна по типу тогда и только тогда, когда допустимо заменить тип массива во входящем стеке операндов на тип <font face=Courier>int</font> и при этом получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(arraylength, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    nth1OperandStackIs(1, StackFrame, ArrayType),
    arrayComponentType(ArrayType, _),
    validTypeTransition(Environment, [top], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''astore'''''
| style="text-align:right;"  | '''''astore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''astore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>reference</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(astore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, reference, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''astore_<n>'''''
| style="text-align:right;"  | '''''astore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''astore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''astore''  также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(astore_0, astore(0)).
instructionHasEquivalentTypeRule(astore_1, astore(1)).
instructionHasEquivalentTypeRule(astore_2, astore(2)).
instructionHasEquivalentTypeRule(astore_3, astore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''athrow'''''
| style="text-align:right;"  | '''''athrow'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''athrow'' безопасна по типу тогда и только тогда, когда на вершине стека операндов находится элемент, соответствующий <font face=Courier>Throwable</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(athrow, _Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    isBootstrapLoader(BL),
    canPop(StackFrame, [class('java/lang/Throwable', BL)], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''baload'''''
| style="text-align:right;"  | '''''baload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''baload'' безопасна по типу тогда и только тогда, когда допустимо заменить типы, соответствующие <font face=Courier>int</font> и массиву «малых» типов во входящем стеке операндов на тип <font face=Courier>int</font> и после замены получить выходное состояние типов.

Массив является ''массивом «малых» типов''  если это массив из типов <font face=Courier>byte</font>, либо <font face=Courier>boolean</font>, либо <font face=Courier>null</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(baload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :
    nth1OperandStackIs(2, StackFrame, Array),
    isSmallArray(Array),
    validTypeTransition(Environment, [int, top], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).

isSmallArray(arrayOf(byte)).
isSmallArray(arrayOf(boolean)).
isSmallArray(null).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''bastore'''''
| style="text-align:right;"  | '''''bastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''bastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font>, <font face=Courier>int</font> и массиву «малых» типов и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(bastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    nth1OperandStackIs(3, StackFrame, Array),
    isSmallArray(Array),
    canPop(StackFrame, [int, int, top], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''bipush'''''
| style="text-align:right;"  | '''''bipush'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''bastore''  безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''sipush'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(bipush(Value), sipush(Value)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''caload'''''
| style="text-align:right;"  | '''''caload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''caload'' безопасна по типу тогда и только тогда, когда допустимо заменить типы, соответствующие <font face=Courier>int</font> и массиву типов <font face=Courier>char</font> во входящем стеке операндов на тип <font face=Courier>int</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(caload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(char)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''castore'''''
| style="text-align:right;"  | '''''castore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''castore'' безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font>, <font face=Courier>int</font> и массиву  типов <font face=Courier>char</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(castore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int, int, arrayOf(char)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''checkcast'''''
| style="text-align:right;"  | '''''checkcast'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''checkcast''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего либо класс либо массив и допустимо заменить тип <font face=Courier>Object</font> на вершине входящего стека операндов на тип, обозначенный через  <font face=Courier>CP</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(checkcast(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    (CP = class(_, _) ; CP = arrayOf(_)),
    isBootstrapLoader(BL),
    validTypeTransition(Environment, [class('java/lang/Object', BL)], CP,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2f'''''
| style="text-align:right;"  | '''''d2f'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''d2f''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип <font face=Courier>double</font>, заменить его на <font face=Courier>float</font> и после получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(d2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2i'''''
| style="text-align:right;"  | '''''d2i'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''d2i''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип <font face=Courier>double</font>, заменить его на <font face=Courier>int</font> и после получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(d2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2l'''''
| style="text-align:right;"  | '''''d2l'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''d2l''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип <font face=Courier>double</font>, заменить его на <font face=Courier>long</font> и после получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(d2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
     validTypeTransition(Environment, [double], long,
                         StackFrame, NextStackFrame),
     exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dadd'''''
| style="text-align:right;"  | '''''dadd'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dadd'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>double</font> и <font face=Courier>double</font>, на <font face=Courier>double</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
     validTypeTransition(Environment, [double, double], double,
                         StackFrame, NextStackFrame),
     exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''daload'''''
| style="text-align:right;"  | '''''daload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''daload'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>double</font>, на <font face=Courier>double</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(daload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(double)], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dastore'''''
| style="text-align:right;"  | '''''dastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>double</font>, <font face=Courier>int</font> и массиву типов <font face=Courier>double</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [double, int, arrayOf(double)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dcmp<op>'''''
| style="text-align:right;"  | '''''dcmp<op>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dcmpg'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>double</font> и <font face=Courier>double</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dcmpg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double, double], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dcmpl'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dcmpg'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dcmpl, dcmpg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dconst_<d>'''''
| style="text-align:right;"  | '''''dconst_<d>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dconst_0''  безопасна по типу тогда и только тогда, когда допустимо записать во входящий стек операндов тип, соответствующий <font face=Courier>double</font>,  и после записи получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dconst_1'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dconst_0'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dconst_1, dconst_0).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ddiv'''''
| style="text-align:right;"  | '''''ddiv'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ddiv'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ddiv, dadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dload'''''
| style="text-align:right;"  | '''''dload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>double</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    loadIsTypeSafe(Environment, Index, double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dload_<n>'''''
| style="text-align:right;"  | '''''dload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''dload_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''dload'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dload_0, dload(0)).
instructionHasEquivalentTypeRule(dload_1, dload(1)).
instructionHasEquivalentTypeRule(dload_2, dload(2)).
instructionHasEquivalentTypeRule(dload_3, dload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dmul'''''
| style="text-align:right;"  | '''''dmul'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dmul'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dmul, dadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dneg'''''
| style="text-align:right;"  | '''''dneg'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dneg''  безопасна по типу тогда и только тогда, когда  во входящем стеке  находится тип, соответствующие <font face=Courier>double</font>. Инструкция ''dneg''  не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [double], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''drem'''''
| style="text-align:right;"  | '''''drem'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''drem'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(drem, dadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dreturn'''''
| style="text-align:right;"  | '''''dreturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dreturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>double</font>  и допустимо считать тип соответствующий <font face=Courier>double</font> из входящего стека операндов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dreturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, double),
    canPop(StackFrame, [double], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dstore'''''
| style="text-align:right;"  | '''''dstore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dstore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>double</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, double, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dstore_<n>'''''
| style="text-align:right;"  | '''''dstore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''dstore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''dstore'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dstore_0, dstore(0)).
instructionHasEquivalentTypeRule(dstore_1, dstore(1)).
instructionHasEquivalentTypeRule(dstore_2, dstore(2)).
instructionHasEquivalentTypeRule(dstore_3, dstore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dsub'''''
| style="text-align:right;"  | '''''dsub'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dsub'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''dadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(dsub, dadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup'''''
| style="text-align:right;"  | '''''dup'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup''  безопасна по типу тогда и только тогда, когда допустимо заменить тип <font face=Courier>Type</font>, принадлежащий категории 1 на типы <font face=Courier>Type</font> , <font face=Courier>Type</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    popCategory1(InputOperandStack, Type, _),
    canSafelyPush(Environment, InputOperandStack, Type, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup_x1'''''
| style="text-align:right;"  | '''''dup_x1'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x1''  безопасна по типу тогда и только тогда, когда допустимо заменить два типа <font face=Courier>Type1</font> и <font face=Courier>Type2</font>, принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup_x1, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup_x2'''''
| style="text-align:right;"  | '''''dup_x2'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x2'' безопасна по типу тогда и только тогда, когда она представляет собой одну из безопасных по типу форм этой инструкции:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup_x2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack,
                             OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x2'' является ''безопасной по типу формой'' инструкции ''dup_x2''  только тогда, когда она является формой 1 инструкции ''dup_x2'' или формой 2 этой инструкции.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x2''  является ''безопасной по типу формой 1'' инструкции dup_x2 тогда и только тогда, когда допустимо заменить три типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и <font face=Courier>Type3</font>, принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup_x2''  является ''безопасной по типу формой 2'' инструкции dup_x2 тогда и только тогда, когда допустимо заменить  тип <font face=Courier>Type1</font>, принадлежащий категории 1, и тип <font face=Courier>Type2</font>, принадлежащий категории 2, на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>,  <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory2(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2'''''
| style="text-align:right;"  | '''''dup2'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2'' безопасна по типу тогда и только тогда, когда она представляет собой одну из безопасных по типу форм этой инструкции:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2SomeFormIsTypeSafe(Environment,InputOperandStack, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2'' является ''безопасной по типу формой'' инструкции dup2  только тогда, когда она является формой 1 инструкции ''dup2'' или формой 2 этой инструкции.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2Form1IsTypeSafe(Environment,InputOperandStack, OutputOperandStack).

dup2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2Form2IsTypeSafe(Environment,InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2''  является ''безопасной по типу формой 1'' инструкции dup2 тогда и только тогда, когда допустимо заменить два типа <font face=Courier>Type1</font> и  <font face=Courier>Type2</font>  принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack):-
    popCategory1(InputOperandStack, Type1, TempStack),
    popCategory1(TempStack, Type2, _),
    canSafelyPushList(Environment, InputOperandStack, [Type1, Type2],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2''  является безопасной по типу формой 2 инструкции ''dup2'' тогда и только тогда, когда допустимо заменить  тип <font face=Courier>Type</font>, принадлежащий категории 2,  на типы <font face=Courier>Type</font>, <font face=Courier>Type</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack):-
    popCategory2(InputOperandStack, Type, _),
    canSafelyPush(Environment, InputOperandStack, Type, OutputOperandStack).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2_x1'''''
| style="text-align:right;"  | '''''dup2_x1'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x1'' безопасна по типу тогда и только тогда, когда она представляет собой одну из безопасных по типу форм этой инструкции:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup2_x1, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2_x1SomeFormIsTypeSafe(Environment, InputOperandStack,
                              OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x1'' является ''безопасной по типу формой'' инструкции dup2_x1  только тогда, когда она является формой 1 инструкции ''dup2_x1'' или формой 2 этой инструкции.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
up2_x1SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x1Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup2_x1SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x1Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x1''  является ''безопасной по типу формой 1'' инструкции dup2_x1 тогда и только тогда, когда допустимо заменить три типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font>  и  <font face=Courier>Type3</font>  принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x1Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest, [Type2, Type1, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x1''  является ''безопасной по типу формой 2'' инструкции dup2_x1 тогда и только тогда, когда допустимо заменить  тип <font face=Courier>Type1</font>, принадлежащий категории 2, и тип <font face=Courier>Type2</font>, принадлежащий категории 1  на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x1Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2_x2'''''
| style="text-align:right;"  | '''''dup2_x2'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2'' безопасна по типу тогда и только тогда, когда она представляет собой одну из безопасных по типу форм этой инструкции:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(dup2_x2, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack,
                              OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2'' является ''безопасной по типу формой'' инструкции dup2_x2  только тогда, когда справедливо одно из следующих утверждений:
* она является безосной по типу формой 1 инструкции ''dup2_x2''.
* она является безосной по типу формой 2 инструкции ''dup2_x2''.
* она является безосной по типу формой 3 инструкции ''dup2_x2''.
* она является безосной по типу формой 4 инструкции ''dup2_x2''.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form3IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).

dup2_x2SomeFormIsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    dup2_x2Form4IsTypeSafe(Environment, InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2''  является ''безопасной по типу формой 1'' инструкции dup2_x2 тогда и только тогда, когда допустимо заменить четыре типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>   и  <font face=Courier>Type4</font>  принадлежащие категории 1 на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type4</font>, <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2Form1IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Stack3),
    popCategory1(Stack3, Type4, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type2, Type1, Type4, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2''  является ''безопасной по типу формой 2'' инструкции dup2_x2 тогда и только тогда, когда допустимо заменить  тип <font face=Courier>Type1</font>, принадлежащий категории 2, и два типа <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, принадлежащий категории 1  на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type1</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2Form2IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory1(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type1, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2''  является ''безопасной по типу формой 3'' инструкции dup2_x2 тогда и только тогда, когда допустимо заменить  два типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, принадлежащие категории 1, и  тип <font face=Courier>Type3</font>, принадлежащий категории 2,  на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type3</font>, <font face=Courier>Type1</font>, <font face=Courier>Type2</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2Form3IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory1(InputOperandStack, Type1, Stack1),
    popCategory1(Stack1, Type2, Stack2),
    popCategory2(Stack2, Type3, Rest),
    canSafelyPushList(Environment, Rest,
                      [Type2, Type1, Type3, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''dup2_x2''  является ''безопасной по типу формой 4'' инструкции dup2_x2 тогда и только тогда, когда допустимо заменить  два типа <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, принадлежащие категории 2,  на типы <font face=Courier>Type1</font>, <font face=Courier>Type2</font>, <font face=Courier>Type1</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
dup2_x2Form4IsTypeSafe(Environment, InputOperandStack, OutputOperandStack) :-
    popCategory2(InputOperandStack, Type1, Stack1),
    popCategory2(Stack1, Type2, Rest),
    canSafelyPushList(Environment, Rest, [Type1, Type2, Type1],
                      OutputOperandStack).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2d'''''
| style="text-align:right;"  | '''''f2d'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''f2d''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>float</font>, и заменить его на <font face=Courier>double</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(f2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2i'''''
| style="text-align:right;"  | '''''f2i'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''f2i''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>float</font>, и заменить его на <font face=Courier>int</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(f2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float], int,
                    StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2l'''''
| style="text-align:right;"  | '''''f2l'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''f2l''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>float</font>, и заменить его на <font face=Courier>long</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(f2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fadd'''''
| style="text-align:right;"  | '''''fadd'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fadd''  безопасна по типу тогда и только тогда, когда допустимо заменить во входящем стеке операндов типы, соответствующие <font face=Courier>float</font> и <font face=Courier>float</font>,  на <font face=Courier>float</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float, float], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>



<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''faload'''''
| style="text-align:right;"  | '''''faload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''faload''  безопасна по типу тогда и только тогда, когда допустимо заменить во входящем стеке операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>float</font>,  на <font face=Courier>float</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(faload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(float)], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fastore'''''
| style="text-align:right;"  | '''''fastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>float</font>,  <font face=Courier>int</font> и массиву <font face=Courier>float</font>,   и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [float, int, arrayOf(float)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fcmp<op>'''''
| style="text-align:right;"  | '''''fcmp<op>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fcmpg''  безопасна по типу тогда и только тогда, когда допустимо заменить во входящем стеке операндов типы, соответствующие <font face=Courier>float</font> и  <font face=Courier>float</font>,  на <font face=Courier>int</font> и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fcmpg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float, float], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fcmpl''  безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fcmpg'' также  безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fcmpl, fcmpg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fconst_<f>'''''
| style="text-align:right;"  | '''''fconst_<f>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fconst_0''  безопасна по типу тогда и только тогда, когда допустимо записать во входящий стек операндов тип, соответствующий <font face=Courier>float</font>   и после записи получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Правила для остальных вариантов инструкции <font face=Courier>fconst</font> эквивалентны.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fconst_1, fconst_0).
instructionHasEquivalentTypeRule(fconst_2, fconst_0).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fdiv'''''
| style="text-align:right;"  | '''''fdiv'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fdiv'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fdiv, fadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fload'''''
| style="text-align:right;"  | '''''fload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>float</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    loadIsTypeSafe(Environment, Index, float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fload_<n>'''''
| style="text-align:right;"  | '''''fload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''fload_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''fload'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fload_0, fload(0)).
instructionHasEquivalentTypeRule(fload_1, fload(1)).
instructionHasEquivalentTypeRule(fload_2, fload(2)).
instructionHasEquivalentTypeRule(fload_3, fload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fmul'''''
| style="text-align:right;"  | '''''fmul'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fmul'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fmul, fadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fneg'''''
| style="text-align:right;"  | '''''fneg'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fneg''  безопасна по типу тогда и только тогда, когда  во входящем стеке  находится тип, соответствующие <font face=Courier>float</font>. Инструкция ''fneg''  не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [float], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''frem'''''
| style="text-align:right;"  | '''''frem'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''frem'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(frem, fadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''freturn'''''
| style="text-align:right;"  | '''''freturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''freturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>float</font>  и допустимо считать тип соответствующий <font face=Courier>float</font> из входящего стека операндов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(freturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, float),
    canPop(StackFrame, [float], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fstore'''''
| style="text-align:right;"  | '''''fstore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fstore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>float</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(fstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, float, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fstore_<n>'''''
| style="text-align:right;"  | '''''fstore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''fstore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''fstore'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fstore_0, fstore(0)).
instructionHasEquivalentTypeRule(fstore_1, fstore(1)).
instructionHasEquivalentTypeRule(fstore_2, fstore(2)).
instructionHasEquivalentTypeRule(fstore_3, fstore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fsub'''''
| style="text-align:right;"  | '''''fsub'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''fsub'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''fadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(fsub, fadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''getfield'''''
| style="text-align:right;"  | '''''getfield'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''getfield'' с операндом <font face=Courier>CP</font> безопасна по типу тогда и только тогда, когда  <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего поле, чей объявленный тип равен <font face=Courier>FieldType</font>, в классе <font face=Courier>FieldClass</font> и допустимо заменить во входящем стеке операндов тип, соответствующий <font face=Courier>FieldClass</font> на тип <font face=Courier>FieldType</font> и после замены получить выходящее состояние типов. <font face=Courier>FieldClass</font> не должен быть массивом. Поля с модификатором доступа <font face=Courier>protected</font> обсуждаются ниже.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(getfield(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = field(FieldClass, FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    passesProtectedCheck(Environment, FieldClass, FieldName,
                         FieldDescriptor, StackFrame),
    validTypeTransition(Environment, [class(FieldClass)], FieldType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Проверка для модификатора <font face=Courier>protected</font> применима только к членам данным классов предков текущего класса. Остальные случаи вступают в силу при выполнении проверок во время разрешения ссылок. Если имя текущего класса не совпадает с именем класса предка, то такой случай может быть безопасно проигнорирован.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor, StackFrame) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    notMember(class(MemberClassName, _), Chain).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Использование членов данных, которые не являются <font face=Courier>protected</font> тривиально и является корректным.

Если <font face=Courier>MemberClassName</font> такой же как и имя класса предка, то класс, чьё разрешение сейчас происходит, может быть на самом деле классом предком. В этом случае, если в другом  пакете времени выполнения отсутствует класс предок с именем <font face=Courier>MemberClassName</font>, который имеет член с модификатором <font face=Courier>protected</font>, именем <font face=Courier>MemberName</font> и дескриптором <font face=Courier>MemberDescriptor</font>, то нет необходимости применять проверку для <font face=Courier>protected</font>.

Так происходит потому, что класс, разрешение которого в данный момент происходит, будет  одним из тех классов предков, для которых мы знаем, что либо это тот же пакет времени выполнения и доступ в этом случае может быть предоставлен; либо член данное, о котором идёт речь, не является  <font face=Courier>protected</font> и проверка не применяется; либо он будет классом наследником, и в этом случае проверка закончится успешно всегда; либо он будет каким-либо другим классом в том же пакете времени выполнения и это значит доступ  может быть предоставлен, а в проверке нет необходимости; либо верификатор считает, что нет необходимости отмечать эту ситуацию как проблемную, поскольку она будет все равно перехвачена аварийно завершившегося разрешения. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor, StackFrame) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWithProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, []).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Если в классе предке существует член с модификатором <font face=Courier>protected</font> в другом пакете времени выполнения, выполняется загрузка <font face=Courier>MemberClassName</font>; если член данное не является <font face=Courier>protected</font>, то проверка не выполняется.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor,

                     frame(_Locals, [Target | Rest], _Flags)) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWIthProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, List),
    List /= [],
    loadedClass(MemberClassName, CurrentLoader, ReferencedClass),
    isNotProtected(ReferencedClass, MemberName, MemberDescriptor).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
В противном случае использование члена с типом <font face=Courier>Target</font> требует того, чтобы <font face=Courier>Target</font> можно было присвоить типу в текущем классе.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
passesProtectedCheck(Environment, MemberClassName, MemberName,
                     MemberDescriptor,
    frame(_Locals, [Target | Rest], _Flags)) :-
    thisClass(Environment, class(CurrentClassName, CurrentLoader)),
    superclassChain(CurrentClassName, CurrentLoader, Chain),
    member(class(MemberClassName, _), Chain),
    classesInOtherPkgWithProtectedMember(
      class(CurrentClassName, CurrentLoader),
      MemberName, MemberDescriptor, MemberClassName, Chain, List),
  List /= [],
  loadedClass(MemberClassName, CurrentLoader, ReferencedClass),
  isProtected(ReferencedClass, MemberName, MemberDescriptor),
  isAssignable(Target, class(CurrentClassName, CurrentLoader)).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Предикат <font face=Courier>classesInOtherPkgWithProtectedMember</font>(<font face=Courier>Class</font>, <font face=Courier>MemberName</font>, <font face=Courier>MemberDescriptor</font>, <font face=Courier>MemberClassName</font>, <font face=Courier>Chain</font>, <font face=Courier>List</font>) является истинным, если <font face=Courier>List</font> — это набор классов цепи <font face=Courier>Chain</font> с находящимся в нем именем <font face=Courier>MemberClassName</font>, причём класс <font face=Courier>MemberClassName</font> расположен в отличном пакете времени выполнения, чем  класс <font face=Courier>Class</font>, который имеет член данное  <font face=Courier>MemberName</font> с модификатором <font face=Courier>protected</font> и дескриптором <font face=Courier>MemberDescriptor</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
classesInOtherPkgWithProtectedMember(_, _, _, _, [], []).

classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     [class(MemberClassName, L) | T]) :-
    differentRuntimePackage(Class, class(MemberClassName, L)),
    loadedClass(MemberClassName, L, Super),
    isProtected(Super, MemberName, MemberDescriptor),
    classesInOtherPkgWithProtectedMember(
      Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).

classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     T) :-
   differentRuntimePackage(Class, class(MemberClassName, L)),
   loadedClass(MemberClassName, L, Super),
   isNotProtected(Super, MemberName, MemberDescriptor),
   classesInOtherPkgWithProtectedMember(
     Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).

classesInOtherPkgWithProtectedMember(Class, MemberName,
                                     MemberDescriptor, MemberClassName,
                                     [class(MemberClassName, L) | Tail],
                                     T] :-
    sameRuntimePackage(Class, class(MemberClassName, L)),
    classesInOtherPkgWithProtectedMember(
      Class, MemberName, MemberDescriptor, MemberClassName, Tail, T).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''getstatic'''''
| style="text-align:right;"  | '''''getstatic'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''getstatic'' с операндом <font face=Courier>CP</font> безопасна по типу тогда и только тогда, когда  <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего поле, чей объявленный тип равен <font face=Courier>FieldType</font>,  и допустимо записать во входящий стек операндов тип, соответствующий  <font face=Courier>FieldType</font> и после записи получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(getstatic(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = field(_FieldClass, _FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    validTypeTransition(Environment, [], FieldType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''goto'''''
| style="text-align:right;"  | '''''goto'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''goto''  безопасна по типу тогда и только тогда, когда её целевой операнд может быть точкой перехода.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(goto(Target), Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    targetIsTypeSafe(Environment, StackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''goto_w'''''
| style="text-align:right;"  | '''''goto_w'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''goto_w''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''goto'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(goto_w(Target), goto(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2b'''''
| style="text-align:right;"  | '''''i2b'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2b''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''ineg'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(i2b, ineg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2c'''''
| style="text-align:right;"  | '''''i2c'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2c''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''ineg'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(i2c, ineg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2d'''''
| style="text-align:right;"  | '''''i2d'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2d''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>int</font>, затем записать туда  <font face=Courier>double</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(i2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2f'''''
| style="text-align:right;"  | '''''i2f'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2f''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>int</font>, затем записать туда  <font face=Courier>float</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(i2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2l'''''
| style="text-align:right;"  | '''''i2l'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2f''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>int</font>, затем записать туда  <font face=Courier>long</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(i2l, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2s'''''
| style="text-align:right;"  | '''''i2s'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''i2s''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''ineg'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(i2s, ineg).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iadd'''''
| style="text-align:right;"  | '''''iadd'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iadd'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и <font face=Courier>int</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iadd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, int], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iaload'''''
| style="text-align:right;"  | '''''iaload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iaload'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>int</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iaload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(int)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iand'''''
| style="text-align:right;"  | '''''iand'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iand''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''iadd'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(iand, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iastore'''''
| style="text-align:right;"  | '''''iastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font>, <font face=Courier>int</font> и массиву типов <font face=Courier>int</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int, int, arrayOf(int)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if_acmp<cond>'''''
| style="text-align:right;"  | '''''if_acmp<cond>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''if_acmpeq''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>reference</font> и <font face=Courier>reference</font> и после считывания получить выходное состояние типов <font face=Courier>NextStackFrame</font>, причём операнд <font face=Courier>Target</font> инструкции ''if_acmpeq'' является  допустимой целью для перехода, принимая во внимание <font face=Courier>NextStackFrame</font> как  входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(if_acmpeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [reference, reference], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Правило для ''if_acmpne'' идентично.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(if_acmpne(Target), if_acmpeq(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if_icmp<cond>'''''
| style="text-align:right;"  | '''''if_icmp<cond>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''if_icmpeq''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и <font face=Courier>int</font> и после считывания получить выходное состояние типов <font face=Courier>NextStackFrame</font>, причём операнд <font face=Courier>Target</font> инструкции ''if_icmpeq'' является  допустимой целью для перехода, принимая во внимание <font face=Courier>NextStackFrame</font> как  входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(if_icmpeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int, int], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Правила для остальных вариантов инструкции ''if_icmp<cond>'' идентичны.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(if_icmpge(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmpgt(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmple(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmplt(Target), if_icmpeq(Target)).
instructionHasEquivalentTypeRule(if_icmpne(Target), if_icmpeq(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if<cond>'''''
| style="text-align:right;"  | '''''if<cond>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ifeq''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>int</font>  и после считывания получить выходное состояние типов <font face=Courier>NextStackFrame</font>, причём операнд <font face=Courier>Target</font> инструкции ''ifeq'' является  допустимой целью для перехода, принимая во внимание <font face=Courier>NextStackFrame</font> как  входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ifeq(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Правила для остальных вариантов инструкции ''if<cond>'' идентичны.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ifge(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifgt(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifle(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(iflt(Target), ifeq(Target)).
instructionHasEquivalentTypeRule(ifne(Target), ifeq(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ifnonnull'''''
| style="text-align:right;"  | '''''ifnonnull'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ifnonnull'' безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>reference</font>  и после считывания получить выходное состояние типов <font face=Courier>NextStackFrame</font>, причём операнд <font face=Courier>Target</font> инструкции ''ifnonnull'' является  допустимой целью для перехода, принимая во внимание <font face=Courier>NextStackFrame</font> как  входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ifnonnull(Target), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [reference], NextStackFrame),
    targetIsTypeSafe(Environment, NextStackFrame, Target),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ifnull'''''
| style="text-align:right;"  | '''''ifnull'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ifnull''  безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''ifnonnull'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ifnull(Target), ifnonnull(Target)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iinc'''''
| style="text-align:right;"  | '''''iinc'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iinc'' с первым операндом <font face=Courier>Index</font> безопасна по типу тогда и только тогда, когда  <font face=Courier>LIndex</font> имеет тип <font face=Courier>int</font>. Инструкция ''iinc'' не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iinc(Index, _Value), _Environment, _Offset,
                     StackFrame, StackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, _OperandStack, _Flags),
    nth0(Index, Locals, int),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iload'''''
| style="text-align:right;"  | '''''iload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>int</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(iload(Index), Environment, _Offset, StackFrame,
NextStackFrame, ExceptionStackFrame) :-
loadIsTypeSafe(Environment, Index, int, StackFrame, NextStackFrame),
exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iload_<n>'''''
| style="text-align:right;"  | '''''iload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''iload_<n>'', где 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная им инструкция ''iload'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(iload_0, iload(0)).
instructionHasEquivalentTypeRule(iload_1, iload(1)).
instructionHasEquivalentTypeRule(iload_2, iload(2)).
instructionHasEquivalentTypeRule(iload_3, iload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''imul'''''
| style="text-align:right;"  | '''''imul'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''imul'' безопасна по типу тогда и только тогда, когда эквивалентная ей инструкция ''iadd'' также безопасна по типу.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(imul, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ineg'''''
| style="text-align:right;"  | '''''ineg'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ineg'' безопасна по типу тогда и только тогда, когда во входящем стеке операндов находится тип, соответствующий <font face=Courier>int</font>. Инструкция ''ineg'' не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ineg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''instanceof'''''
| style="text-align:right;"  | '''''instanceof'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''instanceof''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего либо класс либо массив и допустимо заменить тип <font face=Courier>Object</font> на вершине входящего стека операндов на тип <font face=Courier>int</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(instanceof(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    (CP = class(_, _) ; CP = arrayOf(_)),
    isBootstrapLoader(BL),
    validTypeTransition(Environment, [class('java/lang/Object'), BL], int,
                        StackFrame,NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokedynamic'''''
| style="text-align:right;"  | '''''invokedynamic'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokedynamic'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:


* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего узел динамического вызова с именем <font face=Courier>CallSiteName</font> и дескриптором <font face=Courier>Descriptor</font>.
* <font face=Courier>CallSiteName</font> не является <font face=Courier><init></font>.
* <font face=Courier>CallSiteName</font> не является <font face=Courier><clinit></font>.
* Во входящем стеке операндов допустимо заменить типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokedynamic(CP,0,0), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :-
    CP = dmethod(CallSiteName, Descriptor),
    CallSiteName \= ' <init> ',
    CallSiteName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    reverse(OperandArgList, StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokeinterface'''''
| style="text-align:right;"  | '''''invokeinterface'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokeinterface'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:


* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего метод интерфейса с именем <font face=Courier>MethodName</font> и дескриптором <font face=Courier>Descriptor</font>, который является членом интерфейса с именем <font face=Courier>MethodIntfName</font>.
* <font face=Courier>CallSiteName</font> не является <font face=Courier><init></font>.
* <font face=Courier>CallSiteName</font> не является <font face=Courier><clinit></font>.
* Её второй операнд <font face=Courier>Count</font> является действительным счётчиком (см ниже).
* Во входящем стеке операндов допустимо заменить тип, соответствующий <font face=Courier>MethodIntfName</font> и типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokeinterface(CP, Count, 0), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :-
    CP = imethod(MethodIntfName, MethodName, Descriptor),
    MethodName \= ' <init> ',
    MethodName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    currentClassLoader(Environment, L),
    reverse([class(MethodIntfName, L) | OperandArgList], StackArgList),
    canPop(StackFrame, StackArgList, TempFrame),
    validTypeTransition(Environment, [], ReturnType, TempFrame, NextStackFrame),
    countIsValid(Count, StackFrame, TempFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Операнд <font face=Courier>Count</font> инструкции ''invokeinterface'' является действительным, если он равен количеству аргументов инструкции. Количество аргументов равно разнице размеров <font face=Courier>InputFrame</font> и <font face=Courier>OutputFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
countIsValid(Count, InputFrame, OutputFrame) :-
    InputFrame = frame(_Locals1, OperandStack1, _Flags1),
    OutputFrame = frame(_Locals2, OperandStack2, _Flags2),
    length(OperandStack1, Length1),
    length(OperandStack2, Length2),
    Count =:= Length1 - Length2.
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokespecial'''''
| style="text-align:right;"  | '''''invokespecial'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokespecial'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:

* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего метод с именем <font face=Courier>MethodName</font> и дескриптором <font face=Courier>Descriptor</font>, который является членом класса с именем <font face=Courier>MethodClassName</font>.

Либо:

* <font face=Courier>MethodName</font> не является <font face=Courier><init></font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><clinit></font>.
* Во входящем стеке операндов допустимо заменить тип, соответствующий текущему классу и типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов. 
* Во входящем стеке операндов допустимо заменить тип, соответствующий  классу <font face=Courier>MethodClassName</font> и типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokespecial(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(MethodClassName, MethodName, Descriptor),
    MethodName \= ' <init> ',
    MethodName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    thisClass(Environment, CurrentClass),
    reverse([CurrentClass | OperandArgList], StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    currentClassLoader(Environment, L),
    reverse([class(MethodClassName, L) | OperandArgList], StackArgList2),
    validTypeTransition(Environment, StackArgList2, ReturnType,
                        StackFrame, _ResultStackFrame),
    isAssignable(class(CurrentClassName, L), class(MethodClassName, L)).
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Либо:

* <font face=Courier>MethodName</font>  является <font face=Courier><init></font>.
* В дескрипторе <font face=Courier>Descriptor</font> определен тип возвращаемого значения как <font face=Courier>void</font>.
* Во входящем стеке операндов допустимо считать типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> и неинициализированный тип <font face=Courier>UninitializedArg</font> и в результате считывания получить <font face=Courier>OperandStack</font>. 
* Исходящее состояние типов поличается их входящего заменой, во-первых, входящего стека операндов на <font face=Courier>OperandStack</font> и, во-вторых, заменой всех экземпляров  <font face=Courier>UninitializedArg</font>  на тип экземпляра, который инициализируется.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokespecial(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(MethodClassName, ' <init> ', Descriptor),
    parseMethodDescriptor(Descriptor, OperandArgList, void),
    reverse(OperandArgList, StackArgList),
    canPop(StackFrame, StackArgList, TempFrame),
    TempFrame = frame(Locals, FullOperandStack, Flags),
    FullOperandStack = [UninitializedArg | OperandStack],
    currentClassLoader(Environment, CurrentLoader),
    rewrittenUninitializedType(UninitializedArg, Environment,
                               class(MethodClassName, CurrentLoader), This),
    rewrittenInitializationFlags(UninitializedArg, Flags, NextFlags),
    substitute(UninitializedArg, This, OperandStack, NextOperandStack),
    substitute(UninitializedArg, This, Locals, NextLocals),
    NextStackFrame = frame(NextLocals, NextOperandStack, NextFlags),
    ExceptionStackFrame = frame(NextLocals, [], Flags),
    passesProtectedCheck(Environment, MethodClassName, ' <init> ',
    Descriptor, NextStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Специальное правило для ''invokespecial'' <font face=Courier><init></font> метода.

Это правило является единственной причиной для возврата явного исключения в стеке фреймов. Предположим что ''invokespecial'' может привести к вызову <font face=Courier><init></font> метода в классе предке и вызов закончиться аварийно, оставляя <font face=Courier>this</font> не инициализированным. Данная ситуация не может быть создана с использованием исходного кода на языке программирования Java, но может быть воссоздана  непосредственно с помощью байт-кода.

Исходный фрейм содержит неинициализированный объект в локальных переменных а также флаг <font face=Courier>uninitializedThis</font>. Нормальное завершение ''invokespecial'' инициализирует  неинициализированный объект и сбрасывает флаг <font face=Courier>uninitializedThis</font>. Но если вызов метода <font face=Courier><init></font> приводит к исключению, то неинициализированный объект может пребывать в частично инициализированном состоянии и требовать того, чтобы его обозначили как не готового к использованию. Это достигается тем, что в фрейм исключения содержит неверный объект (новое значение локальной переменной) и флаг <font face=Courier>uninitializedThis</font> (старый флаг). Поскольку нет возможности получить из частично инициализированного объекта, содержащего флаг <font face=Courier>uninitializedThis</font> полностью инициализированный объект, так что  объект помечается как не готовый к использованию. Для других случаев стековый фрейм исключения может быть таким же, как входящий стековый фрейм. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
rewrittenUninitializedType(uninitializedThis, Environment,
                           _MethodClass, This) :-
    thisClass(Environment, This).

rewrittenUninitializedType(uninitialized(Address), Environment,
                           MethodClass, MethodClass) :-
    allInstructions(Environment, Instructions),
    member(instruction(Address, new(MethodClass)), Instructions).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Вычисляем к какому типу тип неинициализированного аргумента должен быть приведён. Есть два случая:

Первый случай. Если мы инициализируем объект внутри конструктора, то его тип изначально равен <font face=Courier>uninitializedThis</font>. Он будет замене на тип класса, которому принадлежит метод  <font face=Courier><init></font>.

Второй случай. Мы инициализируем объект с помощью операции ''new''. Тогда  тип неинициализированного аргумента должен быть равным <font face=Courier>MethodClass</font> — типу, содержащему метод <font face=Courier><init></font>. Мы также проверяем действительно ли по адресу <font face=Courier>Address</font> находится инструкция ''new''.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
rewrittenInitializationFlags(uninitializedThis, _Flags, []).
rewrittenInitializationFlags(uninitialized(_), Flags, Flags).

substitute(_Old, _New, [], []).
	substitute(Old, New, [Old | FromRest], [New | ToRest]) :
    substitute(Old, New, FromRest, ToRest).
substitute(Old, New, [From1 | FromRest], [From1 | ToRest]) :-
    From1 \= Old,
    substitute(Old, New, FromRest, ToRest).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokestatic'''''
| style="text-align:right;"  | '''''invokestatic'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokestatic'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:

* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего метод с именем <font face=Courier>MethodName</font> и дескриптором <font face=Courier>Descriptor</font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><init></font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><clinit></font>.
* Во входящем стеке операндов допустимо заменить типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokestatic(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(_MethodClassName, MethodName, Descriptor),
    MethodName \= ' <init> ',
    MethodName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    reverse(OperandArgList, StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokevirtual'''''
| style="text-align:right;"  | '''''invokevirtual'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''invokevirtual'' безопасна по типу тогда и только тогда, когда справедливы все следующие условия:

* Её первый операнд <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего метод с именем <font face=Courier>MethodName</font> и дескриптором <font face=Courier>Descriptor</font>, причем метод принадлежит классу <font face=Courier>MethodClassName</font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><init></font>.
* <font face=Courier>MethodName</font> не является <font face=Courier><clinit></font>.
* Во входящем стеке операндов допустимо заменить тип, соответствующий <font face=Courier>MethodClassName</font> и типы, соответствующие типам аргументов представленных в <font face=Courier>Descriptor</font> на тип возвращаемого значения, представленного в <font face=Courier>Descriptor</font> и в результате замены получить выходящее состояние типов.
* Если метод является <font face=Courier>protected</font>  использование согласуется с правилами, описывающими доступ к членам данным с модификатором <font face=Courier>protected</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(invokevirtual(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = method(MethodClassName, MethodName, Descriptor),
    MethodName \= ' <init> ',
    MethodName \= ' <clinit> ',
    parseMethodDescriptor(Descriptor, OperandArgList, ReturnType),
    reverse(OperandArgList, ArgList),
    currentClassLoader(Environment, L),
    reverse([class(MethodClassName, L) | OperandArgList], StackArgList),
    validTypeTransition(Environment, StackArgList, ReturnType,
                        StackFrame, NextStackFrame),
    canPop(StackFrame, ArgList, PoppedFrame),
    passesProtectedCheck(Environment, MethodClassName, MethodName,
    Descriptor, PoppedFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ior'''''
| style="text-align:right;"  | '''''ior'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ior'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ior, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''irem'''''
| style="text-align:right;"  | '''''irem'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''irem'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(irem, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ireturn'''''
| style="text-align:right;"  | '''''ireturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ireturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>int</font>  и допустимо считать тип соответствующий <font face=Courier>int</font> из входящего стека операндов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ireturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, int),
    canPop(StackFrame, [int], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ishl'''''
| style="text-align:right;"  | '''''ishl'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ishl'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ishl, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ishr'''''
| style="text-align:right;"  | '''''ishr'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ishr'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ishr, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''istore'''''
| style="text-align:right;"  | '''''istore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''istore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>int</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(istore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''istore_<n>'''''
| style="text-align:right;"  | '''''istore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''istore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''istore'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(istore_0, istore(0)).
instructionHasEquivalentTypeRule(istore_1, istore(1)).
instructionHasEquivalentTypeRule(istore_2, istore(2)).
instructionHasEquivalentTypeRule(istore_3, istore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''isub'''''
| style="text-align:right;"  | '''''isub'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''isub'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(isub, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iushr'''''
| style="text-align:right;"  | '''''iushr'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''iushr'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(iushr, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ixor'''''
| style="text-align:right;"  | '''''ixor'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ixor'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''iadd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ixor, iadd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2d'''''
| style="text-align:right;"  | '''''l2d'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''l2d''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>long</font>, затем записать туда  <font face=Courier>double</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(l2d, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long], double,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2f'''''
| style="text-align:right;"  | '''''l2f'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''l2f''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>long</font>, затем записать туда  <font face=Courier>float</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(l2f, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long], float,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2i'''''
| style="text-align:right;"  | '''''l2i'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''l2i''  безопасна по типу тогда и только тогда, когда  допустимо  во входящем стеке операндов считать тип, соответствующий  <font face=Courier>long</font>, затем записать туда  <font face=Courier>float</font> и после замены получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(l2i, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ladd'''''
| style="text-align:right;"  | '''''ladd'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ladd'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>long</font> и <font face=Courier>long</font>, на <font face=Courier>long</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ladd, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long, long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''laload'''''
| style="text-align:right;"  | '''''laload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''laload'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>long</font>, на <font face=Courier>long</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(laload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(long)], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''land'''''
| style="text-align:right;"  | '''''land'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''land'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(land, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lastore'''''
| style="text-align:right;"  | '''''lastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>long</font>, <font face=Courier>int</font> и массиву типов <font face=Courier>long</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [long, int, arrayOf(long)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lcmp'''''
| style="text-align:right;"  | '''''lcmp'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lcmp'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>long</font> и <font face=Courier>long</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lcmp, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long, long], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lconst_<l>'''''
| style="text-align:right;"  | '''''lconst_<l>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lconst_0''  безопасна по типу тогда и только тогда, когда допустимо записать во входящий стек операндов тип, соответствующий <font face=Courier>long</font>,  и после записи получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lconst_0, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lconst_1'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''lconst_0'' также безопасна.

|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lconst_1, lconst_0).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc'''''
| style="text-align:right;"  | '''''ldc'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ldc''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего элемент <font face=Courier>Type</font>, где <font face=Courier>Type</font> это либо <font face=Courier>int</font>, <font face=Courier>float</font>, <font face=Courier>String</font>, <font face=Courier>Class</font>, <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font>, либо <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font> и допустимо записать во входящий стек операндов на тип <font face=Courier>Type</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ldc(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    functor(CP, Tag, _),
    isBootstrapLoader(BL),
    member([Tag, Type], [
       [int, int],
       [float, float],
       [string, class('java/lang/String', BL)],
       [classConst, class('java/lang/Class', BL)],
       [methodTypeConst, class('java/lang/invoke/MethodType', BL)],
       [methodHandleConst, class('java/lang/invoke/MethodHandle', BL)],
    ]),
    validTypeTransition(Environment, [], Type, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc_w'''''
| style="text-align:right;"  | '''''ldc_w'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ldc_w'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ldc'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ldc_w(CP), ldc(CP)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc2_w'''''
| style="text-align:right;"  | '''''ldc2_w'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ldc2_w''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего элемент <font face=Courier>Tag</font>, где <font face=Courier>Tag</font> это либо <font face=Courier>long</font> либо <font face=Courier>double</font> и допустимо записать во входящий стек операндов на тип <font face=Courier>Tag</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(ldc2_w(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    functor(CP, Tag, _),
    member(Tag, [long, double]),
    validTypeTransition(Environment, [], Tag, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldiv'''''
| style="text-align:right;"  | '''''ldiv'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''ldiv'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(ldiv, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lload'''''
| style="text-align:right;"  | '''''lload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lload'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция загрузки с операндом <font face=Courier>Index</font> и типом <font face=Courier>long</font> является безопасной по типу  и приводит к выходящему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lload(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    loadIsTypeSafe(Environment, Index, long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lload_<n>'''''
| style="text-align:right;"  | '''''lload_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''lload_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''lload'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lload_0, lload(0)).
instructionHasEquivalentTypeRule(lload_1, lload(1)).
instructionHasEquivalentTypeRule(lload_2, lload(2)).
instructionHasEquivalentTypeRule(lload_3, lload(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lmul'''''
| style="text-align:right;"  | '''''lmul'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lmul'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lmul, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lneg'''''
| style="text-align:right;"  | '''''lneg'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lneg'' безопасна по типу тогда и только тогда, когда во входящем стеке операндов находится тип, соответствующий <font face=Courier>long</font>. Инструкция ''lneg'' не меняет состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lneg, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lookupswitch'''''
| style="text-align:right;"  | '''''lookupswitch'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lookupswitch'' безопасна по типу, если её ключи отсортированы, а также допустимо считать <font face=Courier>int</font> из входящего стека операндов, получая при этом новое состояние типов <font face=Courier>BranchStackFrame</font> и все целевые точки переходов инструкций являются действительными точками переходов в предположении, что <font face=Courier>BranchStackFrame</font> их входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lookupswitch(Targets, Keys), Environment, _, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    sort(Keys, Keys),
    canPop(StackFrame, [int], BranchStackFrame),
    checklist(targetIsTypeSafe(Environment, BranchStackFrame), Targets),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lor'''''
| style="text-align:right;"  | '''''lor'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lor'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lor, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lrem'''''
| style="text-align:right;"  | '''''lrem'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lrem'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lrem, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lreturn'''''
| style="text-align:right;"  | '''''lreturn'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lreturn'' безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>long</font>  и допустимо считать тип соответствующий <font face=Courier>long</font> из входящего стека операндов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lreturn, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, long),
    canPop(StackFrame, [long], _PoppedStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lshl'''''
| style="text-align:right;"  | '''''lshl'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lshl''  безопасна по типу тогда и только тогда, когда допустимо заменить  во входящем стеке операндов типы, соответствующие <font face=Courier>int</font> и <font face=Courier>long</font>  на <font face=Courier>long</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lshl, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, long], long,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lshr'''''
| style="text-align:right;"  | '''''lshr'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lshr'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''lshl'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lshr, lshl).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lstore'''''
| style="text-align:right;"  | '''''lstore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lstore'' с операндом <font face=Courier>Index</font> безопасна по типу и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>, если инструкция сохранения  с операндом <font face=Courier>Index</font> и типом <font face=Courier>long</font> безопасна по типам  и приводит к результирующему состоянию типов <font face=Courier>NextStackFrame</font>.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(lstore(Index), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    storeIsTypeSafe(Environment, Index, long, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lstore_<n>'''''
| style="text-align:right;"  | '''''lstore_<n>'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкции ''lstore_<n>'', для 0 ≤ n ≤ 3 безопасны по типу тогда и только тогда, когда эквивалентная инструкция ''lstore'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lstore_0, lstore(0)).
instructionHasEquivalentTypeRule(lstore_1, lstore(1)).
instructionHasEquivalentTypeRule(lstore_2, lstore(2)).
instructionHasEquivalentTypeRule(lstore_3, lstore(3)).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lsub'''''
| style="text-align:right;"  | '''''lsub'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lsub'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lsub, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lushr'''''
| style="text-align:right;"  | '''''lushr'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lushr'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''lshl'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lushr, lshl).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lxor'''''
| style="text-align:right;"  | '''''lxor'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''lxor'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''ladd'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(lxor, ladd).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''monitorenter'''''
| style="text-align:right;"  | '''''monitorenter'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''monitorenter''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>reference</font> и  после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(monitorenter, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [reference], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''monitorexit'''''
| style="text-align:right;"  | '''''monitorexit'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''monitorexit'' безопасна по типу тогда и только тогда, когда эквивалентная инструкция ''monitorenter'' также безопасна.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(monitorexit, monitorenter).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''multianewarray'''''
| style="text-align:right;"  | '''''multianewarray'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''multianewarray''  с операндами <font face=Courier>CP</font>  и <font face=Courier>Dim</font> безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего массив, чья размерность больше либо равна  <font face=Courier>Dim</font>,  <font face=Courier>Dim</font> строго больше нуля,  и допустимо заменить во входящем стеке операндов  типы <font face=Courier>Dim</font> <font face=Courier>int</font> на тип обозначенный <font face=Courier>CP</font> и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(multianewarray(CP, Dim), Environment, _Offset,
                      StackFrame, NextStackFrame, ExceptionStackFrame) :-
    CP = arrayOf(_),
    classDimension(CP, Dimension),
    Dimension >= Dim,
    Dim > 0,
    /* Make a list of Dim ints */
    findall(int, between(1, Dim, _), IntList),
    validTypeTransition(Environment, IntList, CP, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Размерность массива, чью компоненты также являются массивами, на один больше чем размерность самих компонентов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
classDimension(arrayOf(X), Dimension) :-
    classDimension(X, Dimension1),
    Dimension is Dimension1 + 1.

classDimension(_, Dimension) :-
    Dimension = 0.
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''new'''''
| style="text-align:right;"  | '''''new'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''new''  с операндом <font face=Courier>CP</font>  и смещением  <font face=Courier>Offset</font> безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего класс, тип  <font face=Courier>uninitialized</font>(<font face=Courier>Offset</font>) не появляется во входящем стеке операндов  и допустимо записать <font face=Courier>uninitialized</font>(<font face=Courier>Offset</font>) во входящий стек операндов и заменить  <font face=Courier>uninitialized</font>(<font face=Courier>Offset</font>) на  <font face=Courier>top</font> во входящих локальных переменных  и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(new(CP), Environment, Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, OperandStack, Flags),
    CP = class(_, _),
    NewItem = uninitialized(Offset),
    notMember(NewItem, OperandStack),
    substitute(NewItem, top, Locals, NewLocals),
    validTypeTransition(Environment, [], NewItem,
                        frame(NewLocals, OperandStack, Flags),
                        NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''newarray'''''
| style="text-align:right;"  | '''''newarray'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''newarray''  с операндом <font face=Courier>TypeCode</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>TypeCode</font> соответствует элементарному типу <font face=Courier>ElementType</font> и допустимо заменить тип <font face=Courier>int</font> во входящем стеке операндов на «массив  <font face=Courier>ElementType</font>»  и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
nstructionIsTypeSafe(newarray(TypeCode), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    primitiveArrayInfo(TypeCode, _TypeChar, ElementType, _VerifierType),
    validTypeTransition(Environment, [int], arrayOf(ElementType),
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Соответствие между кодом типа и самим примитивным типом определено следующими предикатами:
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
primitiveArrayInfo(4,  0'Z, boolean, int).
PrimitiveArrayInfo(5,  0'C, char,    int).
PrimitiveArrayInfo(6,  0'F, float,   float).
PrimitiveArrayInfo(7,  0'D, double,  double).
PrimitiveArrayInfo(8,  0'B, byte,    int).
PrimitiveArrayInfo(9,  0'S, short,   int).
primitiveArrayInfo(10, 0'I, int,     int).
primitiveArrayInfo(11, 0'J, long,    long).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''nop'''''
| style="text-align:right;"  | '''''nop'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''nop'' всегда безопасна по типу. Инструкция ''nop'' не влияет на состояние типов. 
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(nop, _Environment, _Offset, StackFrame,
                      StackFrame, ExceptionStackFrame) :-
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''pop'''''
| style="text-align:right;"  | '''''pop'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop''   безопасна по типу тогда и только тогда, когда допустимо считать тип категории 1 из входящего стека операндов и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(pop, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, [Type | Rest], Flags),
    Type \= top,
    sizeOf(Type, 1),
    NextStackFrame = frame(Locals, Rest, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''pop2'''''
| style="text-align:right;"  | '''''pop2'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop2''  безопасна по типу тогда и только тогда, когда она является безопасной по типу формой инструкции ''pop2''.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(pop2, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, InputOperandStack, Flags),
    pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack),
    NextStackFrame = frame(Locals, OutputOperandStack, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop2''  является  ''безопасной по типу формой инструкции'' pop2, когда она представляет собой безопасную по типу форму 1 инструкции  ''pop2'' либо  безопасную по типу форму 2 инструкции  ''pop2''.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack) :-
    pop2Form1IsTypeSafe(InputOperandStack, OutputOperandStack).

pop2SomeFormIsTypeSafe(InputOperandStack, OutputOperandStack) :-
    pop2Form2IsTypeSafe(InputOperandStack, OutputOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop2''  является  ''безопасной по типу формой 1 инструкции'' pop2 тогда и только тогда, когда допустимо считать из входящего стека операндов два типа размера 1 и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
pop2Form1IsTypeSafe([Type1, Type2 | Rest], Rest) :-
    sizeOf(Type1, 1),
    sizeOf(Type2, 1).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''pop2''  является  ''безопасной по типу формой 2 инструкции'' pop2 тогда и только тогда, когда допустимо считать из входящего стека операндов  тип размера 2 и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
pop2Form2IsTypeSafe([top, Type | Rest], Rest) :- sizeOf(Type, 2).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''putfield'''''
| style="text-align:right;"  | '''''putfield'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''putfield''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего поле, чей объявленный тип это <font face=Courier>FieldType</font>, причём поле находится в классе <font face=Courier>FieldClass</font> и допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>FieldType</font> и <font face=Courier>FieldClass</font>, и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(putfield(CP), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = field(FieldClass, FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    canPop(StackFrame, [FieldType], PoppedFrame),
    passesProtectedCheck(Environment, FieldClass, FieldName,
                         FieldDescriptor, PoppedFrame),
    currentClassLoader(Environment, CurrentLoader),
    canPop(StackFrame, [FieldType, class(FieldClass, CurrentLoader)],
           NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''putstatic'''''
| style="text-align:right;"  | '''''putstatic'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''putstatic''  с операндом <font face=Courier>CP</font>  безопасна по типу тогда и только тогда, когда <font face=Courier>CP</font> ссылается на элемент константного пула, обозначающего поле, чей объявленный тип это <font face=Courier>FieldType</font>, и допустимо считать из входящего стека операндов тип, соответствующий <font face=Courier>FieldType</font> и при этом получить выходящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(putstatic(CP), _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    CP = field(_FieldClass, _FieldName, FieldDescriptor),
    parseFieldDescriptor(FieldDescriptor, FieldType),
    canPop(StackFrame, [FieldType], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''return'''''
| style="text-align:right;"  | '''''return'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''return''  безопасна по типу тогда и только тогда, когда метод, в котором она находится имеет тип возвращаемого значения <font face=Courier>void</font> и вдобавок либо:


* метод, в котором находится инструкция не является <font face=Courier><init></font> методом либо
* <font face=Courier>this</font> полностью инициализирована в той точке кода, где помещена инструкция.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(return, Environment, _Offset, StackFrame,
                      afterGoto, ExceptionStackFrame) :-
    thisMethodReturnType(Environment, void),
    StackFrame = frame(_Locals, _OperandStack, Flags),
    notMember(flagThisUninit, Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''saload'''''
| style="text-align:right;"  | '''''saload'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''saload'' безопасна по типу тогда и только тогда, когда допустимо заменить из входящего стека операндов типы, соответствующие <font face=Courier>int</font> и массиву <font face=Courier>short</font>, на <font face=Courier>int</font>, и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(saload, Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [int, arrayOf(short)], int,
                        StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''sastore'''''
| style="text-align:right;"  | '''''sastore'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''sastore''  безопасна по типу тогда и только тогда, когда допустимо считать из входящего стека операндов типы, соответствующие <font face=Courier>int</font>, <font face=Courier>int</font> и массиву типов <font face=Courier>short</font> и после считывания получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(sastore, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    canPop(StackFrame, [int, int, arrayOf(short)], NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''sipush'''''
| style="text-align:right;"  | '''''sipush'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''sipush''  безопасна по типу тогда и только тогда, когда допустимо записать тип <font face=Courier>int</font> во входящий стек операндов и после записи получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(sipush(_Value), Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    validTypeTransition(Environment, [], int, StackFrame, NextStackFrame),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''swap'''''
| style="text-align:right;"  | '''''swap'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''swap''  безопасна по типу тогда и только тогда, когда допустимо заменить два типа категории 1 <font face=Courier>Type1</font> и <font face=Courier>Type2</font> на типы <font face=Courier>Type2</font> и <font face=Courier>Type1</font> во входящем стеке операндов и после замены получить выходное состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(swap, _Environment, _Offset, StackFrame,
                      NextStackFrame, ExceptionStackFrame) :-
    StackFrame = frame(_Locals, [Type1, Type2 | Rest], _Flags),
    sizeOf(Type1, 1),
    sizeOf(Type2, 1),
    NextStackFrame = frame(_Locals, [Type2, Type1 | Rest], _Flags),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''tableswitch'''''
| style="text-align:right;"  | '''''tableswitch'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''tableswitch'' безопасна по типу, если её ключи отсортированы, а также допустимо считать <font face=Courier>int</font> из входящего стека операндов, получая при этом новое состояние типов <font face=Courier>BranchStackFrame</font> и все целевые точки переходов инструкций являются действительными точками переходов в предположении, что <font face=Courier>BranchStackFrame</font> их входящее состояние типов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionIsTypeSafe(tableswitch(Targets, Keys), Environment, _Offset,
                      StackFrame, afterGoto, ExceptionStackFrame) :-
    sort(Keys, Keys),
    canPop(StackFrame, [int], BranchStackFrame),
    checklist(targetIsTypeSafe(Environment, BranchStackFrame), Targets),
    exceptionStackFrame(StackFrame, ExceptionStackFrame).
</syntaxhighlight>
|}
<br>


<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''wide'''''
| style="text-align:right;"  | '''''wide'''''
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Инструкция ''wide'' подчинена тем же самым правилам, что и инструкция, которую она расширяет.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
instructionHasEquivalentTypeRule(wide(WidenedInstruction),
                                 WidenedInstruction).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Состояние типов после того, как инструкция завершиться аварийно такое же как и входящее состояние типов, за исключением того, что стек операндов пуст.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
exceptionStackFrame(StackFrame, ExceptionStackFrame) :-
    StackFrame = frame(Locals, _OperandStack, Flags),
    ExceptionStackFrame = frame(Locals, [], Flags).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Большинство правил для типов в данной спецификации зависят от понимания корректного преобразования типов.

Преобразование типов является корректным, если допустимо считать список ожидаемых типов из входящего состояния типов стека операндов и заменить их на ожидаемые типы и при этом получить новое корректное состояние типов. В частности размер стека операндов в новом состоянии типов не должен превышать объявленный максимально допустимый размер.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
validTypeTransition(Environment, ExpectedTypesOnStack, ResultType,
                    frame(Locals, InputOperandStack, Flags),
                    frame(Locals, NextOperandStack, Flags)) :-
    popMatchingList(InputOperandStack, ExpectedTypesOnStack, InterimOperandStack),
    pushOperandStack(InterimOperandStack, ResultType, NextOperandStack),
    operandStackHasLegalLength(Environment, NextOperandStack).
</syntaxhighlight>
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
Доступ к I-тому элементу стека операндов.
|}
<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<syntaxhighlight lang="prolog">
nth1OperandStackIs(I, frame(_Locals, OperandStack, _Flags), Element) :-
    nth1(I, OperandStack, Element).
</syntaxhighlight>
|}
<br>

[[Категория:Переводы на русский язык]]
