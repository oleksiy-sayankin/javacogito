{| width="100%"
| style="text-align:left;"  | '''''aaload'''''
| style="text-align:right;"  | '''''aaload'''''
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" | '''Операция'''
|Загружает ссылку из массива
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" | '''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
|''aaload''
|}
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" | '''Формы'''
|''aaload'' = 50 (0x32)
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;"| '''Стек операндов'''
| ..., ''ссылка на массив'', ''индекс'' →
|-
|
|
|-
|
| ..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" | '''Описание'''
| style="vertical-align:top;"|Значение ''ссылки на массив'' должно быть типа <font face=Courier>reference</font> и должно ссылаться на массив, чьи компоненты также принадлежат типу <font face=Courier>reference</font>. Значение ''индекса'' должно быть типа <font face=Courier>int</font>. Как ''ссылка на массив'' так и ''индекс'' считываются из стека операндов. ''Значение'' типа <font face=Courier>reference</font> считывается из элемента массива с индексом ''индекс'' и записывается в стек операндов.

|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" | '''Исключения времени выполнения'''
| style="vertical-align:top;"|Если значение ''ссылки на массив'' равно <font face=Courier>null</font>, то инструкция ''aaload'' генерирует исключение <font face=Courier>NullPointerException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aastore'''''
| style="text-align:right;"  | '''''aastore'''''
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Операция'''
|Сохраняет ссылку (<font face=Courier>reference</font>) из стека в массив
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
|''aastore''
|}
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Формы'''
|''aastore''= 83 (0x53)
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Стек операндов'''
|..., ''ссылка на массив'', ''индекс'', ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Описание'''
|Значение ''ссылки на массив'' должно быть типа <font face=Courier>reference</font> и должно ссылаться на массив, чьи компоненты также принадлежат типу <font face=Courier>reference</font>. Значение ''индекса'' должно быть типа <font face=Courier>int</font>, ''значение'' должно быть типа <font face=Courier>reference</font>. ''Значение'', ''ссылка на массив'' и ''индекс'' считываются из стека операндов. ''Значение'' типа <font face=Courier>reference</font> сохраняется в элементе массива с ''индекс''ом ''индекс''.

Во время выполнения тип ''значения'' должен быть совместим с типом компонентов массива, на который ссылается ''ссылка на массив''.

Присваивание ссылочного типа <font face=Courier>''S''</font> (источник) типу <font face=Courier>''T''</font> (приёмник) допустимо тогда и только тогда:

* Если <font face=Courier>''S''</font> - это класс, тогда:
** Если <font face=Courier>''T''</font> – это класс, то <font face=Courier>''S''</font> должно быть такого же класса, как и <font face=Courier>''T''</font> либо <font face=Courier>''S''</font> должно быть наследником <font face=Courier>''T''</font>;
** Если <font face=Courier>''T''</font> – это интерфейс, то <font face=Courier>''S''</font> должно реализовывать этот интерфейс;
* Если <font face=Courier>''S''</font> - это интерфейс, тогда:
** Если <font face=Courier>''T''</font> – это класс, тогда <font face=Courier>''T''</font> должно быть типа <font face=Courier>Object</font>.
** Если <font face=Courier>''T''</font> – это интерфейс, то <font face=Courier>''S''</font> должно быть тем же интерфейсом или интерфейсом-предком <font face=Courier>''S''</font>.
* Если <font face=Courier>''S''</font> – это массив (назовём его <font face=Courier><font face=Courier>''SC''</font></font>[], что значит массив с компонентами типа <font face=Courier><font face=Courier>''SC''</font></font>), тогда:
** Если <font face=Courier>''T''</font> – это класс, тогда <font face=Courier>''T''</font> должен быть <font face=Courier>Object</font>.
** Если <font face=Courier>''T''</font> – это интерфейс, тогда <font face=Courier>''T''</font> должно быть одним из интерфейсов, которые реализует массив (см. JLS §4.10.3).
** Если <font face=Courier>''T''</font> – массив <font face=Courier><font face=Courier>''TC''</font></font>[],  что значит массив с компонентами типа <font face=Courier><font face=Courier>''TC''</font></font>, тогда одно из следующих утверждений должно быть истинным:
*** <font face=Courier><font face=Courier>''TC''</font></font> и <font face=Courier><font face=Courier>''SC''</font></font> принадлежат одному примитивному типу.
*** <font face=Courier><font face=Courier>''TC''</font></font> и <font face=Courier><font face=Courier>''SC''</font></font> ссылочные типы и <font face=Courier><font face=Courier>''SC''</font></font> можно присвоить <font face=Courier><font face=Courier>''TC''</font></font>.
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Исключения времени выполнения'''
|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то инструкция ''aaload'' генерирует исключение <font face=Courier>NullPointerException</font>.
В противном случае, если ''индекс'' вне границ массива, на который ссылается ''ссылка на массив'', то ''aastore'' генерирует исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aconst_null'''''
| style="text-align:right;"  | '''''aconst_null'''''
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Операция'''
|Записывает в стек <font face=Courier>null</font>
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
|''aconst_null''
|}
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Формы'''
|''aconst_null''= 1 (0x1)
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Стек операндов'''
|... →

..., null
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Описание'''
|Записывает в стек операндов ссылку на <font face=Courier>null</font> объект.
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Примечания'''
|Виртуальная машина Java не определяет конкретного значения для <font face=Courier>null</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aload'''''
| style="text-align:right;"  | '''''aload'''''
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Операция'''
|Загружает ссылку из локальной переменной в стек
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
|aload
|-
|индекс
|}
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Формы'''
|''aload'' = 25 (0x19)
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Стек операндов'''
|..., →

..., ''ссылка на объект''
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Описание'''
|''Индекс'' представляет собой беззнаковый байт, который определяет локальную переменную текущего фрейма ([[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с указанным индексом должна содержать ''значение'' типа <font face=Courier>reference</font>. ''Ссылка на объект'' из локальной переменной записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Примечания'''
|Инструкция ''aload'' не может быть использована для записи в стек операндов значений типа <font face=Courier>returnAddress</font> из локальной переменной. Эта асимметрия с инструкцией ''astore'' сделана намеренно.

Инструкция ''aload'' может быть использована с инструкцией ''wide'' для доступа к локальным переменным, имеющим двухбайтовый индекс.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''aload_<n>'''''
| style="text-align:right;"  | '''''aload_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Операция'''
|Загружает ссылку из локальной переменной в стек
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
|''aload_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Формы'''
|''aload_0''= 42 (0x2a)

''aload_1''= 43 (0x2b)

''aload_2''= 44 (0x2c)

''aload_3''= 45 (0x2d)
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Стек операндов'''
|..., →

..., ''ссылка на объект''
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Описание'''
|Значение <n> должно быть индексом локальной переменной текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с индексом <n> должна содержать ''значение'' типа <font face=Courier>reference</font>. ''Ссылка на объект'', находящаяся в локальной переменной с индексом <n> записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
| width="150px" style="vertical-align:top;" |'''Примечания'''
|Инструкция ''aload_<n>'' не может быть использована для записи в стек операндов значений типа <font face=Courier>returnAddress</font> из локальной переменной. Эта асимметрия с инструкцией ''astore_<n>'' сделана намеренно.

Каждая из инструкций ''aload_<n>''  выполняет то же, что и ''aload'' с явно заданным индексом.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''anewarray'''''
| style="text-align:right;"  | '''''anewarray'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Создаёт новый массив из ссылок
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''anewarray''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''anewarray'' = 189 (0xbd)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''число элементов'' →

..., ''ссылка на массив''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Число элементов должно принадлежать типу <font face=Courier>int</font>. Оно считывается из стека операндов. Число элементов определяет размер массива. Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение'' ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула, на который указывает построенный ''индекс'', должен быть ссылкой на класс, массив или интерфейс. Обозначенный класс, массив или интерфейс разрешается (см. [[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]) и определяется тип элементов массива. В куче создаётся новый массив, с указанным типом элементов, заданной размерностью. Ссылка на созданный массив записывается в стек операндов. Все элементы инициализируются значениями <font face=Courier>null</font>, которые являются значениями по умолчанию для типа <font face=Courier>reference</font> (см. [[Спецификация виртуальной машины Java#Ссылочные типы и их значения|§2.4]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на класс, массив или интерфейс, может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]).
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''число элементов'' меньше нуля, инструкция ''anewarray'' генерирует <font face=Courier>NegativeArraySizeException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''anewarray'' используется для создания одномерного массива ссылок на объекты или части многомерного массива.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''areturn'''''
| style="text-align:right;"  | '''''areturn'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Создаёт новый массив из ссылок
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''areturn''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''areturn''= 176 (0xb0)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'' →

[пусто]
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font> и должна ссылаться на объект, тип которого совместим по присвоению  (см. JLS §5.2) с типом возвращаемого ''значения'', заданным в дескрипторе текущего метода (см. [[Спецификация виртуальной машины Java#Дескрипторы методов|§4.3.3]]). Если текущий метод объявлен как <font face=Courier>synchronized</font>, то происходит захват (или повторный захват) монитора, при запуске метода, и освобождение монитора при выполнении ''areturn'', так как если бы была выполнена инструкция ''monitorexit'' в текущем потоке. Если в ходе выполнения метода не было сгенерировано исключение, ''ссылка на объект'' считывается из стека операндов текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]) и записывается в стек операндов вызывающего метода. Все значения в стеке операндов текущего фрейма теряются.

Интерпретатор восстанавливает вызывающий фрейм и передаёт управление вызвавшему методу.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font> и должна ссылаться на объект, тип которого совместим по присвоению  (см. JLS §5.2) с типом возвращаемого ''значения'', заданным в дескрипторе текущего метода (см. [[Спецификация виртуальной машины Java#Дескрипторы методов|§4.3.3]]). Если текущий метод объявлен как <font face=Courier>synchronized</font>, то происходит захват (или повторный захват) монитора, при запуске метода, и освобождение монитора при выполнении ''areturn'', так как если бы была выполнена инструкция ''monitorexit'' в текущем потоке. Если в ходе выполнения метода не было сгенерировано исключение, ''ссылка на объект'' считывается из стека операндов текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]) и записывается в стек операндов вызывающего метода. Все значения в стеке операндов текущего фрейма теряются.

Интерпретатор восстанавливает вызывающий фрейм и передаёт управление вызвавшему методу.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''arraylength'''''
| style="text-align:right;"  | '''''arraylength'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Возвращает длину массива
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''arraylength''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''arraylength''= 190 (0xbe)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'' →

..., ''длина массива''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна принадлежать типу <font face=Courier>reference</font>. Она считывается из стека операндов. Определяется ''длина массива'' по указанной ссылке. Эта ''длина массива'' записывается в стек операндов как значение типа <font face=Courier>int</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>,  ''arraylength'' генерирует <font face=Courier>NullPointerException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''astore'''''
| style="text-align:right;"  | '''''astore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает ссылку из стека и сохраняет в локальную переменную
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''astore''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''astore''= 58 (0x3a)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'' →

...,
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' представляет собой беззнаковый байт, являющейся индексом локальной переменной текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Ссылка на объект'' на вершине стека операндов должна принадлежать типу <font face=Courier>returnAddress</font> или <font face=Courier>reference</font>. Ссылка считывается из стека операндов и записывается в локальную переменную с заданным индексом.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''astore'' совместно со ссылкой типа <font face=Courier>returnAddress</font> используется для реализации блока <font face=Courier>finally</font> в языке программирования Java (см. [[Спецификация виртуальной машины Java#Компиляция инструкции finally|§3.13]]).

Инструкция ''aload'' не может быть использована для загрузки значения типа  <font face=Courier>returnAddress</font> из локальной переменной в стек операндов. Эта асимметрия с ''astore'' сделана намеренно.

Также ''astore'' может быть использована с инструкцией ''wide'', которая расширяет значения индекса локальной переменной до двух байт.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''astore_<n>'''''
| style="text-align:right;"  | '''''astore_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает ссылку из стека и сохраняет в локальную переменную
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''astore_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''astore_0''= 75 (0x4b)

''astore_1''= 76 (0x4c)

''astore_2''= 77 (0x4d)

''astore_3''= 78 (0x4e)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|<n> представляет собой беззнаковый байт, являющейся индексом локальной переменной текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Ссылка на объект'' на вершине стека операндов должна принадлежать типу <font face=Courier>returnAddress</font> или <font face=Courier>reference</font>. Ссылка считывается из стека операндов и записывается в локальную переменную с заданным индексом <n>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''astore_<n>'' совместно со ссылкой типа <font face=Courier>returnAddress</font> используется для реализации блока <font face=Courier>finally</font> в языке программирования Java (см. [[Спецификация виртуальной машины Java#Компиляция инструкции finally|§3.13]]).

Инструкция ''aload_<n>'' не может быть использована для загрузки значения типа  <font face=Courier>returnAddress</font> из локальной переменной в стек операндов. Эта асимметрия с ''astore_<n>'' сделана намеренно.

Каждая инструкция ''astore_<n>'' выполняет то же самое, что и инструкция ''astore'' с ''индексом'' равным <n>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''athrow'''''
| style="text-align:right;"  | '''''athrow'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Выбрасывает исключение
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''athrow''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''athrow''= 191 (0xbf)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект''→

''ссылка на объект''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на объект''  должна принадлежать типу <font face=Courier>reference</font> и должна ссылаться на объект класса <font face=Courier>Throwable</font> или его наследника. Она считывается из стека операндов. Затем в текущем методе (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]) первого подходящего обработчика по алгоритму, указанному в [[Спецификация виртуальной машины Java#Исключения|§2.10]].

Если обработчик исключения соответствующий ссылке на объект (т.е. соответствующему исключению) был найден, то в нем находится ссылка на первую инструкцию кода, который должен быть выполнен. В регистр <font face=Courier>pc</font> записывается адрес первой инструкции кода, стек операндов текущего фрейма очищается, ''ссылка на объект'' записывается обратно в стек и выполнение продолжается.

Если обработчик не найден в текущем фрейме, текущий фрейм считывается из стека фреймов. Если текущий метод был объявлен как <font face=Courier>synchronized</font>, захваченный при входе в метод монитор отпускается, как если была выполнена инструкция ''monitorexit''. Фрейм вызывающего метода (если таковой существует) становится текущим и исключение выбрасывается повторно. Если такого фрейма нет, происходит выход из текущего потока.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' равна <font face=Courier>null</font>, инструкция ''athrow'' генерирует <font face=Courier>NullPointerException</font>.

В противном случае, если реализация виртуальной машины Java не поддерживает правила структурной блокировки, описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], тогда если метод текущего фрейма объявлен как <font face=Courier>synchronized</font> и текущий поток не является владельцем монитора, захваченного при входе в метод, то генерируется исключение <font face=Courier>IllegalMonitorStateException</font> вместо исключения выброшенного ранее. Это может произойти, если аварийно прерванный <font face=Courier>synchronized</font> метод содержит инструкцию ''monitorexit'', а соответствующей инструкции  ''monitorenter'' для того же объекта синхронизации нет.

Если реализация виртуальной машины Java поддерживает правила структурной блокировки, описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]] и первое из этих правил нарушено во время вызова метода, тогда ''athrow'' генерирует <font face=Courier>IllegalMonitorStateException</font> вместо выбрасываемого до этого исключения.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Описание стека операндов для инструкции ''athrow'' может сбивать с толку: если обработчик найден в текущем методе, инструкция ''athrow'' очищает стек операндов, а затем записывает в стек ссылку на выбрасываемое исключение. Однако, такое решение вполне приемлемо, поскольку, если соответствующего обработчика в текущем методе не найдено, то исключение будет выброшено далее по цепочке вызовов методов и если обработчик будет найден, стек будет очищен и ссылка на исключение помещена в стек. Все промежуточные фрейм из цепочки вызова методов, в которых обработчик не был найден, также будут очищены.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''baload'''''
| style="text-align:right;"  | '''''baload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>byte</font> или <font face=Courier>boolean</font> из массива в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''baload''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''baload'' = 51 (0x33)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'' →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна принадлежать типу <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты являются типами <font face=Courier>byte</font> или <font face=Courier>boolean</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', так и  ''индекс'' считываются из стека операндов. ''Значение'' типа <font face=Courier>byte</font> считывается из элемента массива с заданным индексом, расширяется с учётом знака до типа <font face=Courier>int</font> и записывается вершину стека операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''baload'' генерирует <font face=Courier>NullPointerException</font>.

Если ''индекс'' вне границ массива, то ''baload'' генерирует <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''baload'' используется для получения значений из массивов как типа <font face=Courier>byte</font>, так и типа <font face=Courier>boolean</font>. В реализации виртуальной машины Java компании Oracle массивы значений типа <font face=Courier>boolean</font> (тип <font face=Courier>T_BOOLEAN</font> (см. [[Спецификация виртуальной машины Java#Типы данных|§2.2]])), представлены как массивы, хранящие 8 бит информации на одно значение типа <font face=Courier>boolean</font>. Другие реализации могут использовать упакованные массивы для хранения <font face=Courier>boolean</font>; инструкция ''baload'' также должна использоваться и для доступа к таким массивам.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''bastore'''''
| style="text-align:right;"  | '''''bastore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>byte</font> или <font face=Courier>boolean</font> в массив из стека
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''bastore''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''bastore''= 84 (0x54)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'', ''значение''→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна принадлежать типу <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты являются типами <font face=Courier>byte</font> или <font face=Courier>boolean</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', ''индекс'' так и ''значение'' считываются из стека операндов. ''Значение'', принадлежащее типу <font face=Courier>int</font>, урезается до типа <font face=Courier>byte</font> и записывается в массив, в элемент с заданным индексом.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, ''bastore'' генерирует <font face=Courier>NullPointerException</font>.

Если ''индекс'' вне границ массива, то ''bastore'' генерирует <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''bastore'' используется для записи в массив значений как типа <font face=Courier>byte</font> так и типа <font face=Courier>boolean</font>. В реализации виртуальной машины компании Oracle массивы значений типа <font face=Courier>boolean</font> (тип <font face=Courier>T_BOOLEAN</font> (см. [[Спецификация виртуальной машины Java#Типы данных|§2.2]])), представлены как массивы, хранящие 8 бит информации на одно значение типа <font face=Courier>boolean</font>. Другие реализации могут использовать упакованные массивы для хранения <font face=Courier>boolean</font>; инструкция ''bastore'' также должна использоваться и для записи значений в такие массивы.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''bipush'''''
| style="text-align:right;"  | '''''bipush'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает значение типа <font face=Courier>byte</font> в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''bipush''
|-
| style="vertical-align:top;"|байт
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''bipush''= 16 (0x10)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|С помощью знакового расширения ''значение'' байта преобразуется к типу <font face=Courier>int</font> и записывается в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''caload'''''
| style="text-align:right;"  | '''''caload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>char</font> из массива в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''caload''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''caload''= 52 (0x34)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'' →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна принадлежать типу <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты являются типами <font face=Courier>char</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', так и  ''индекс'' считываются из стека операндов. ''Значение'' считывается из элемента массива с заданным индексом, расширяется без учёта знака до типа <font face=Courier>int</font> и записывается вершину стека операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''caload'' генерирует <font face=Courier>NullPointerException</font>.

Если ''индекс'' вне границ массива, то ''caload'' генерирует <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''castore'''''
| style="text-align:right;"  | '''''castore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>char</font> в массив
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''castore''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''castore''= 85 (0x55)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'', ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна принадлежать типу <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты являются типами <font face=Courier>char</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', ''индекс'' так и ''значение'' считываются из стека операндов. ''Значение'', принадлежащее типу <font face=Courier>char</font>, урезается до типа <font face=Courier>byte</font> и записывается в массив, в элемент с заданным индексом.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, ''castore'' генерирует <font face=Courier>NullPointerException</font>.

Если ''индекс'' вне границ массива, то ''castore'' генерирует <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''checkcast'''''
| style="text-align:right;"  | '''''checkcast'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Проверяет, принадлежит ли объект заданному типу
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''checkcast''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''checkcast''= 192 (0xc0)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'' →

..., ''ссылка на объект''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font>. Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения индекса массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение индекса определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула, на который указывает построенный индекс, должен быть ссылкой на класс, массив или интерфейс.

Если ''ссылка на объект'' равна <font face=Courier>null</font>, то содержимое стека операндов не меняется.

В противном случае класс, массив или интерфейс разрешается (см. [[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]). Если ''ссылка на объект'' может быть преобразована к разрешённому ранее классу, массиву или интерфейсу, то стек операндов не меняется. В противном случае инструкция ''checkcast'' генерирует исключение <font face=Courier>ClassCastException</font>.

Если ''ссылка на объект''  не равна <font face=Courier>null</font>, то используются следующие правила для разрешения типов: если <font face=Courier>''S''</font>  - класс, на который  ссылается ''ссылка на объект'', а <font face=Courier>''T''</font> – разрешаемый класс, массив или интерфейс, то ''checkcast'' проверяет следующее:
* Если <font face=Courier>''S''</font> - это класс, тогда:
** Если <font face=Courier>''T''</font> – это класс, то <font face=Courier>''S''</font> должно быть такого же класса, как и <font face=Courier>''T''</font> либо <font face=Courier>''S''</font> должно быть наследником <font face=Courier>''T''</font>;
** Если <font face=Courier>''T''</font> – это интерфейс, то <font face=Courier>''S''</font> должно реализовывать этот интерфейс;
* Если <font face=Courier>''S''</font> - это интерфейс, тогда:
** Если <font face=Courier>''T''</font> – это класс, тогда <font face=Courier>''T''</font> должно быть типа <font face=Courier>Object</font>.
** Если <font face=Courier>''T''</font> – это интерфейс, то <font face=Courier>''S''</font> должно быть тем же интерфейсом или интерфейсом-предком <font face=Courier>''S''</font>.
* Если <font face=Courier>''S''</font> – это массив (назовём его <font face=Courier><font face=Courier>''SC''</font></font>[], что значит массив с компонентами типа <font face=Courier><font face=Courier>''SC''</font></font>), тогда:
** Если <font face=Courier>''T''</font> – это класс, тогда <font face=Courier>''T''</font> должен быть <font face=Courier>Object</font>.
** Если <font face=Courier>''T''</font> – это интерфейс, тогда <font face=Courier>''T''</font> должно быть одним из интерфейсов, которые реализует массив (см. JLS §4.10.3).
** Если <font face=Courier>''T''</font> – массив <font face=Courier><font face=Courier>''TC''</font></font>[],  что значит массив с компонентами типа <font face=Courier><font face=Courier>''TC''</font></font>, тогда одно из следующих утверждений должно быть истинным:
*** <font face=Courier><font face=Courier>''TC''</font></font> и <font face=Courier><font face=Courier>''SC''</font></font> принадлежат одному примитивному типу.
*** <font face=Courier><font face=Courier>''TC''</font></font> и <font face=Courier><font face=Courier>''SC''</font></font> ссылочные типы и <font face=Courier><font face=Courier>''SC''</font></font> можно присвоить <font face=Courier><font face=Courier>''TC''</font></font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на класс, массив или интерфейс, может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]).
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' не может быть преобразована к разрешённому классу, массиву или интерфейсу ''checkcast'' генерирует <font face=Courier>ClassCastException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''checkcast'' очень похожа на инструкцию ''instanceof''. Они отличаются друг от друга реакцией на <font face=Courier>null</font> (''checkcast'' генерирует исключение, ''instanceof'' записывает код результата в стек) и влиянием на стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2f'''''
| style="text-align:right;"  | '''''d2f'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует <font face=Courier>double</font> к <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''d2f''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''d2f''= 144 (0x90)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно быть типа <font face=Courier>double</font>. Оно считывается из стека операндов и подвергается набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]). Затем ''новое значение'' преобразуется к типу <font face=Courier>float</font> согласно стандарту IEEE 754. Результат записывается в стек операндов.

Там, где инструкция ''d2f'' работает в режиме FP-strict (см. [[Спецификация виртуальной машины Java#Режимы работы с плавающей точкой|§2.8.2]]) результат преобразования всегда округляется к ближайшему представимому значению во множестве значений типа <font face=Courier>float</font> (см. [[Спецификация виртуальной машины Java#Типы данных с плавающей точкой, множества значений и значения|§2.3.2]])

Там, где инструкция ''d2f'' работает в не режиме FP-strict, результат преобразования  может быть взят расширенного набора значений с плавающей точкой ([[Спецификация виртуальной машины Java#Типы данных с плавающей точкой, множества значений и значения|§2.3.2]]); оно не обязательно округляется к ближайшему представимому значению во множестве значений типа <font face=Courier>float</font>.

Если ''новое значение'' слишком мало, чтоб быть представленным как <font face=Courier>float</font>, оно преобразуется к нулю типа <font face=Courier>float</font> того же знака. Если ''новое значение'' слишком велико, чтоб быть представленным как <font face=Courier>float</font>, оно преобразуется к бесконечности типа <font face=Courier>float</font> того же знака. Не-число (NaN) типа <font face=Courier>double</font> преобразуется в не-число типа <font face=Courier>float</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''d2f'' выполняет сужающее преобразование примитивных типов, поэтому может преобразуемая величина быть потеряна полностью либо потеряна точность представления.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2i'''''
| style="text-align:right;"  | '''''d2i'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует <font face=Courier>double</font> к <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''d2i''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''d2i''= 142 (0x8e)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно быть типа <font face=Courier>double</font>. Оно считывается из стека операндов и подвергается набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]). Затем новое ''значение'' преобразуется к типу <font face=Courier>int</font>. Результат записывается в стек операндов.
* Если новое ''значение'' не-число NaN, ''результат'' преобразования <font face=Courier>int</font> 0.
* В противном случае, если новое ''значение'' не бесконечность, оно округляется к целочисленному <font face=Courier>''V''</font> согласно IEEE 754 (округление в направлении нуля). Если это целое число представимо в типе <font face=Courier>int</font>, то <font face=Courier>''V''</font> – ''результат'' преобразования.
* Если число <font face=Courier>''V''</font> не представимо в типе <font face=Courier>int</font> (оно слишком мало или является отрицательной бесконечностью) то ''результатом'' будет наименьшее число представимое в диапазоне <font face=Courier>int</font>. Либо <font face=Courier>''V''</font> не представимо в типе <font face=Courier>int</font>, поскольку оно слишком велико или является положительной бесконечностью, то ''результатом'' будет наибольшее число представимое в диапазоне <font face=Courier>int</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''d2i'' выполняет сужающее преобразование примитивных типов, поэтому может преобразуемая величина быть потеряна полностью либо потеряна точность представления.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''d2l'''''
| style="text-align:right;"  | '''''d2l'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует <font face=Courier>double</font> к <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''d2l''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''d2l''= 143 (0x8f)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''  →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно быть типа <font face=Courier>double</font>. Оно считывается из стека операндов и подвергается набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]). Затем новое ''значение'' преобразуется к типу <font face=Courier>long</font>. Результат записывается в стек операндов.
* Если новое ''значение'' не-число NaN, ''результат'' преобразования <font face=Courier>long</font> 0.
* В противном случае, если новое ''значение'' не бесконечность, оно округляется к целочисленному <font face=Courier>''V''</font> согласно IEEE 754 (округление в направлении нуля). Если это целое число представимо в типе <font face=Courier>int</font>, то <font face=Courier>''V''</font> – ''результат'' преобразования.
* Если число <font face=Courier>''V''</font> не представимо в типе <font face=Courier>long</font> (оно слишком мало или является отрицательной бесконечностью) то ''результатом'' будет наименьшее число представимое в диапазоне <font face=Courier>long</font>. Либо <font face=Courier>''V''</font> не представимо в типе <font face=Courier>long</font>, поскольку оно слишком велико или является положительной бесконечностью, то ''результатом'' будет наибольшее число представимое в диапазоне <font face=Courier>long</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''d2l'' выполняет сужающее преобразование примитивных типов, поэтому может преобразуемая величина быть потеряна полностью либо потеряна точность представления.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dadd'''''
| style="text-align:right;"  | '''''dadd'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Складывает два числа типа <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dadd''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dadd''= 99 (0x63)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>double</font>. Значения считываются из стека операндов, проходят преобразования (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) становясь ''значением1''` и ''значением2''`. Результат типа <font face=Courier>double</font> равен сумме ''значение1''` + ''значение2''`. Результат записывается в стек операндов.

Суммирование производится согласно правилам арифметики IEEE:
Если либо ''значение1''` либо  ''значение2''` есть не-число NaN, то ''результат'' есть NaN.
* Сумма двух бесконечностей противоположных знаков есть NaN.
* Сумма двух бесконечностей одинаковых знаков есть бесконечность того же знака.
* Сумма бесконечности и конечного числа есть бесконечность.
* Сумма двух нулей противоположных знаков есть положительный ноль.
* Сумма двух нулей одинаковых знаков есть ноль того же знака.
* Сумма двух не нулевых конечных значений одинаковой величины есть положительный ноль.
* В оставшихся случаях, когда ни один из операндов не бесконечность, не ноль и не NaN и ''значения'' имеют один знак или имеют разную величину, сумма вычисляется и округляется к ближайшему представимому значению согласно правилам округления IEEE 754. Если ''результат'' слишком велик, чтобы быть представленным как <font face=Courier>double</font>, мы говорим, что произошло переполнение. В этом случае ''результат'' есть бесконечность соответствующего знака. Если ''результат'' слишком мал, чтобы быть представленным как <font face=Courier>double</font>, мы говорим, что произошла потеря точности. В этом случае ''результат'' есть ноль соответствующего знака.

Инструкция ''dadd'' не генерирует исключение, если происходит переполнение или потеря точности.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''daload'''''
| style="text-align:right;"  | '''''daload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>double</font> из массива в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''daload''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''daload''= 49 (0x31)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'' →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>double</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', так и ''индекс'' считываются из стека операндов. ''Значение'' типа <font face=Courier>double</font> считывается из элемента массива с соответствующим индексом и записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''daload'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dastore'''''
| style="text-align:right;"  | '''''dastore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>double</font> в массив
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dastore''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dastore''= 82 (0x52)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'', ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>double</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>, ''значение'' должно принадлежать типу <font face=Courier>double</font>. ''Ссылка на массив'', ''индекс'' и ''значение'' считываются из стека операндов. Над значением проводится набор преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), в результате которых ''значение''` сохраняется в массиве с заданным индексом.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''dastore'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dcmp<op>'''''
| style="text-align:right;"  | '''''dcmp<op>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Сравнивает два значения типа <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dcmp<op>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dcmpg''= 152 (0x98)

''dcmpl''= 151 (0x97)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>double</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются на ''значение1''` и ''значение2''`. Сравнение значений с плавающей точкой производится следующим образом:
* Если ''значение1''` больше чем ''значение2''`, то в стек операндов записывается единица с типом <font face=Courier>int</font>.
* В противном случае, если ''значение1''` равно значению2`, то в стек операндов записывается ноль с типом <font face=Courier>int</font>.
* В противном случае, если ''значение1''` меньше чем ''значение2''`, то в стек операндов записывается минус единица с типом <font face=Courier>int</font>.
* В противном случае, по крайней мере, одно ''значение'' (либо ''значение1''`, либо ''значение2''`) есть не-число NaN. В этом случае инструкция ''dcmpg'' записывает 1 с типом <font face=Courier>int</font> в стек операндов, а инструкция ''dcmpl'' записывает -1 с типом <font face=Courier>int</font> в стек операндов.

Сравнение чисел с плавающей точкой выполняется согласно требованиям стандарта <font face=Courier>IEEE754</font>. Все ''значения'', отличные от не-числа NaN упорядочены, причём отрицательная бесконечность меньше чем все числа, а положительная бесконечность больше чем все числа. Положительный и отрицательный ноль считаются равными.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкции ''dcmpg'' и ''dcmpl'' отличаются только своим поведением при сравнении не-чисел NaN. Поскольку NaN не упорядочено, любое сравнения не-числа NaN и значения типа <font face=Courier>double</font> не определено, в случае, когда один либо оба операнда не-числа NaN. С помощью инструкций ''dcmpg'' и ''dcmpl'' любое сравнения чисел типа <font face=Courier>double</font> может быть скомпилировано так, чтобы выдавать результат, совпадающий и при сравнение обычных чисел и при сравнении не-чисел NaN. Более подробную информацию см. в [[Спецификация виртуальной машины Java#Передача управления|§3.5]].
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dconst_<d>'''''
| style="text-align:right;"  | '''''dconst_<d>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает константу типа <font face=Courier>double</font> в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dconst_<d>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dconst_0''= 14 (0xe)

''dconst_1''= 15 (0xf)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

... <d>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Записывает в стек операндов константу <d> (0.0 или 1.0) типа <font face=Courier>double</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ddiv'''''
| style="text-align:right;"  | '''''ddiv'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Делит два значения типа <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ddiv''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ddiv''= 111 (0x6f)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>double</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются на ''значение1''` и ''значение2''`. Результат – это число типа <font face=Courier>double</font> равное ''значение1''`/ ''значение2''`. Затем ''результат'' записывается в стек операндов.
Результат инструкции ''ddiv'' вычисляется согласно правилам арифметики стандарта IEEE:
* Если либо ''значение1''` либо  ''значение2''` есть не-число NaN, то ''результат'' есть NaN.
* Если ни ''значение1''` ни  ''значение2''` не являются не-числами NaN, то знак результата деления положительный, если делимое и делитель имеют один знак и отрицательный в противном случае.
* Деление бесконечности на бесконечность даёт не-число NaN.
* Деление бесконечности на конечное ''значение'' даёт бесконечность, знак которой определён по правилу, описанному выше.
* Деление конечного ''значения'' на бесконечность даёт знаковый ноль, знак которого определён по правилу, описанному выше.
* Деление ноль на ноль даёт не-число NaN; деление ноля на конечное ''значение'' даёт знаковый ноль, знак которого определён по правилу, описанному выше.
* Деление не нулевого конечного ''значения'' на ноль даёт бесконечность, знак которой определён по правилу, описанному выше.
* В оставшихся случаях, когда операнды не бесконечность, не ноль и не NaN частное вычисляется и округляется к ближайшему <font face=Courier>double</font>, используя режим округления к ближайшему стандарта IEEE 754. Если величина слишком велика, чтобы быть представленной в диапазоне типа <font face=Courier>double</font>, говорят, что произошло переполнение. В этом случае ''результатом'' является бесконечность соответствующего знака. Если величина слишком мала, чтобы быть представленной в диапазоне типа <font face=Courier>double</font>, говорят, что произошла потеря точности. В этом случае ''результатом'' является ноль соответствующего знака.

Несмотря на переполнение, потерю точности, деление на ноль инструкция ''ddiv'' никогда не генерирует исключение времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dload'''''
| style="text-align:right;"  | '''''dload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>double</font>  из локальной переменной в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dload''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dload''= 24 (0x18)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом. ''Индекс'' и величина ''индекс''+1 должны принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с заданным ''индексом'' должна содержать величину типа <font face=Courier>double</font>. ''Значение'' локальной переменной, с заданным ''индексом'', записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''dload'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый индекс локальной переменной.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dload_<n>'''''
| style="text-align:right;"  | '''''dload_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>double</font> из локальной переменной в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dload_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dload_0''= 38 (0x26)

''dload_1''= 39 (0x27)

''dload_2''= 40 (0x28)

''dload_3''= 41 (0x29)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|... →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И <n> и величина <n>+1 должны принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с индексом <n> должна содержать величину типа <font face=Courier>double</font>. ''Значение'' локальной переменной с ''индексом'' <n>, записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из инструкции ''dload_<n>'' выполняет то же, что и ''dload'' с явным ''индексом'' <n> за исключением того, что операнд <n> задан не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dmul'''''
| style="text-align:right;"  | '''''dmul'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Умножает два значения типа <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dmul''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dmul''= 107 (0x6b)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>double</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются на ''значение1''` и ''значение2''`. Результат – это число типа <font face=Courier>double</font> равное ''значение1''`* ''значение2''`. Затем ''результат'' записывается в стек операндов.

Результат инструкции ''dmul'' вычисляется согласно правилам арифметики стандарта IEEE:
* Если либо ''значение1''` либо  ''значение2''` есть не-число NaN, то ''результат'' есть NaN.
* Если ни ''значение1''` ни  ''значение2''` не являются не-числами NaN, то знак результата умножения положительный, если операнды имеют один знак и отрицательный в противном случае.
* Умножение бесконечности на ноль даёт не-число NaN.
* Умножение бесконечности на конечное ''значение'' даёт бесконечность, знак которой определён по правилу, описанному выше.
* В оставшихся случаях, когда операнды не бесконечность, не ноль и не NaN произведение вычисляется и округляется к ближайшему <font face=Courier>double</font>, используя режим округления к ближайшему стандарта IEEE 754. Если величина слишком велика, чтобы быть представленной в диапазоне типа <font face=Courier>double</font>, говорят, что произошло переполнение. В этом случае ''результатом'' является бесконечность соответствующего знака. Если величина слишком мала, чтобы быть представленной в диапазоне типа <font face=Courier>double</font>, говорят, что произошла потеря точности. В этом случае ''результатом'' является ноль соответствующего знака.

Несмотря на переполнение, потерю точности ''dmul'' никогда не генерирует исключение времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dneg'''''
| style="text-align:right;"  | '''''dneg'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Инвертирует значение типа <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dneg''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dneg''= 119 (0x77)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' должно принадлежать типу <font face=Courier>double</font>. Оно считывается из стека операндов, и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), а затем заменяется значением`. Результат – это число типа <font face=Courier>double</font> равное арифметическому отрицанию ''значения''`. Затем ''результат'' записывается в стек операндов.

Для значений типа <font face=Courier>double</font> отрицание не есть то же самое, что и вычитание из нуля. Если <font face=Courier>''x''</font> это  +0.0, то  0.0 - <font face=Courier>''x''</font> равно  +0.0, но  -<font face=Courier>''x''</font> равно  -0.0. Унарный минус лишь инвертирует знак числа типа <font face=Courier>double</font>.

Особые случаи:
* Если  операнд есть не-число NaN, то ''результат'' также NaN (поскольку у NaN нет знака).
* Если операнд – бесконечность, то ''результат'' – бесконечность противоположного знака.
* Если операнд – ноль, то ''результат'' – ноль противоположного знака.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''drem'''''
| style="text-align:right;"  | '''''drem'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Остаток от деления двух чисел типа <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''drem''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''drem''= 115 (0x73)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>double</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются  ''значением1''` и ''значением2''`. Результат вычисляется и записывается в стек операндов с типом <font face=Courier>double</font>.

Результат инструкции ''drem'' не совпадает с операцией вычисления остатка для чисел с плавающей точкой, определённой в стандарте IEEE 754. Операция вычисления остатка, заданная в стандарте IEEE 754, вычисляет остаток от «округляющего» деления, а не «урезающего» деления, так что её поведение не аналогично обычной операции целочисленного вычисления остатка. Вместо этого в виртуальной машине Java поведение инструкции ''drem'' определено наподобие инструкций целочисленного вычисления остатка (''irem'' и ''lrem''); инструкцию ''drem'' можно сравнить с библиотечной функцией <font face=Courier>fmod</font> языка <font face=Courier>''C''</font>.

Результат инструкции ''drem'' вычисляется согласно следующим правилам:
* Если либо ''значение1''` либо  ''значение2''` есть не-число NaN, то ''результат'' есть NaN.
* Если ни ''значение1''` ни  ''значение2''` не являются не-числами NaN, то знак результата совпадает со знаком делимого.
* Если делимое есть бесконечность или делитель есть ноль, либо оба числа есть нули, то ''результат'' – не-число  NaN.
* Если делимое есть конечное ''значение'', а делитель – бесконечность, то ''результат'' (остаток от деления) равен делимому.
* Если делимое есть ноль, а делитель – конечное ''значение'', то ''результат'' (остаток от деления) равен делимому.
* В оставшихся случаях, когда операнды не бесконечность, не ноль и не NaN остаток от деления с плавающей точкой делимого значения1` на делитель ''значение2''` определяется следующим отношением: ''результат'' = ''значение1''` - (''значение2''` * q), где q – целое число, имеющее знак минус в случае, если ''значение1''` / ''значение2''` отрицательно и знак плюс, если ''значение1''` / ''значение2''` положительно. Величина коэффициента q равно наибольшему целому не превосходящему частного от деления ''значения1''` на ''значение2''`.

Несмотря на деление на ноль инструкция ''drem'' никогда не генерирует исключение времени выполнения. Переполнение и потеря точности не могут произойти для этой инструкции.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Остаток от деления согласно спецификации IEEE 754 может быть вычислен с помощью метода <font face=Courier>Math</font>.<font face=Courier>IEEEremainder</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dreturn'''''
| style="text-align:right;"  | '''''dreturn'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Возвращает значение типа <font face=Courier>double</font> из метода
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dreturn''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dreturn''= 175 (0xaf)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

[пусто]
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Текущий метод должен возвращать величину типа <font face=Courier>double</font>. ''Значение'' также должно принадлежать <font face=Courier>double</font>. Если текущий метод объявлен с ключевым словом <font face=Courier>synchronized</font>, то при входе в метод монитор захватывается первоначально (либо повторно, если уже был захвачен до того), а при выходе освобождается, как при выполнении инструкции ''monitorexit'' для текущего потока. Если в ходе выполнения метода не было исключений, ''значение'' считывается из стека операндов текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]) и проходит ряд преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]). Затем преобразованное  ''значение''` записывается в стек операндов фрейма, принадлежащего вызывающему методу. Все остальные ''значения'' стека операндов текущего фрейма теряются.

Затем интерпретатор передаёт управление вызывающему методу, делая текущим соответствующий фрейм.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если реализация виртуальной машины Java не поддерживает правила структурных блокировок описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], тогда если текущий метод объявлен как  <font face=Courier>synchronized</font> и текущий поток не является владельцем монитора, захваченного при входе в метод, то при вызове ''dreturn'' будет выброшено исключение <font face=Courier>IllegalMonitorStateException</font>. Это может произойти, если <font face=Courier>synchronized</font>-метод содержит инструкцию ''monitorexit'', а инструкция ''monitorenter'' по объекту синхронизации отсутствует.

С другой стороны, если реализация виртуальной машины Java  поддерживает правила структурных блокировок описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], и во время выполнения текущего метода нарушено первое из этих правил, то при вызове ''dreturn'' будет выброшено исключение <font face=Courier>IllegalMonitorStateException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dstore'''''
| style="text-align:right;"  | '''''dstore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает значение типа <font face=Courier>double</font> из стека и сохраняет в локальной переменной
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dstore''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dstore''= 57 (0x39)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом. ''Индекс'' и величина ''индекс''+1 должны принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение''  на вершине стека операндов должно принадлежать типу <font face=Courier>double</font>. Оно считывается из стека операндов, и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), а затем заменяется значением`. В локальные переменные с индексами ''индекс'' и ''индекс''+1 записывается ''значение''`.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''dstore'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый индекс локальной переменной.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dstore_<n>'''''
| style="text-align:right;"  | '''''dstore_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает значение типа <font face=Courier>double</font> из стека и сохраняет в локальной переменной
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dstore_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dstore_0''= 71 (0x47)

''dstore_1''= 72 (0x48)

''dstore_2''= 73 (0x49)

''dstore_3''= 74 (0x4a)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И <n> и величина <n>+1 должны принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение''  на вершине стека операндов должно принадлежать типу <font face=Courier>double</font>. Оно считывается из стека операндов, и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), а затем заменяется значением`. В локальные переменные с индексами <n> и <n> +1 записывается ''значение''`.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из инструкции ''dstore_<n>'' выполняет то же, что и ''dstore'' с явным индексом <n> за исключением того, что операнд <n> задан не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dsub'''''
| style="text-align:right;"  | '''''dsub'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вычитает два значения типа <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dsub''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dsub''= 103 (0x67)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>double</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются на ''значение1''` и ''значение2''`. Результат – это число типа <font face=Courier>double</font> равное ''значение1''`- ''значение2''`. Затем ''результат'' записывается в стек операндов.

Для операндов типа <font face=Courier>double</font> всегда справедливо, что выражение <font face=Courier>''a''</font>-<font face=Courier>''b''</font> даёт такой же ''результат'', как и <font face=Courier>''a''</font>+(-<font face=Courier>''b''</font>). Тем не менее, для инструкции ''dsub'' вычитание ''значения'' из нуля не то же самое, что и отрицание, потому что если <font face=Courier>''x''</font> это +0.0, тогда 0.0-<font face=Courier>''x''</font> равно +0.0, но  -<font face=Courier>''x''</font> равно -0.0.

Несмотря на переполнение, потерю точности ''dsub'' никогда не генерирует исключение времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup'''''
| style="text-align:right;"  | '''''dup'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Дублирует значение на вершине стека операндов
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dup''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dup''= 89 (0x59)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''значение'', ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Копирует ''значение'' на вершине стека операндов и записывает копию на вершину стека.

Инструкция ''dup'' не должна использоваться, если ''значение'' не принадлежит категории 1 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup_x1'''''
| style="text-align:right;"  | '''''dup_x1'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Дублирует значение на вершине стека операндов и записывает его двумя значениями ниже в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dup_x1''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dup_x1''= 90 (0x5a)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение2'', ''значение1'' →

..., ''значение1'', ''значение2'', ''значение1''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Копирует ''значение'' на вершине стека операндов и записывает копию двумя значениями ниже в стек.

Инструкция ''dup_x1'' не должна использоваться, если ''значение1'' и ''значение2'' не принадлежат категории 1 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup_x2'''''
| style="text-align:right;"  | '''''dup_x2'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Дублирует значение на вершине стека операндов и записывает его двумя или тремя значениями ниже в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dup_x2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dup_x2''= 91 (0x5b)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Форма 1:

..., ''значение3'', ''значение2'', ''значение1'' →

..., ''значение1'', ''значение3'', ''значение2'', ''значение1''

где ''значение1'', ''значение2'' и ''значение3'' принадлежат категории 1 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])



Форма 2:

..., ''значение2'', ''значение1'' →

..., ''значение1'', ''значение2'', ''значение1''

где ''значение1'' принадлежит категории 1 вычислимых типов, а ''значение2'' принадлежит категории 2  (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Копирует ''значение'' на вершине стека операндов и записывает копию двумя или тремя значениями ниже в стек.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2'''''
| style="text-align:right;"  | '''''dup2'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Дублирует один или два операнда на вершине стека
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dup2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dup2''= 92 (0x5c)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Форма 1:


... ''значение2'', ''значение1'' →

..., ''значение2'', ''значение1'', ''значение2'', ''значение1''

где ''значение1'', ''значение2''  принадлежат категории 1 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])



Форма 2:


..., ''значение'' →

..., ''значение'', ''значение''

где ''значение'' принадлежит категории 2 вычислимых типов  (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Копирует одно или два значения на вершине стека операндов и записывает копию (одно или два значения) в стек.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2_x1'''''
| style="text-align:right;"  | '''''dup2_x1'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Дублирует один или два операнда на вершине стека и записывает его двумя или тремя значениями ниже в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dup2_x1''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dup2_x1''= 93 (0x5d)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Форма 1:



..., ''значение3'', ''значение2'', ''значение1'' →

..., ''значение2'', ''значение1'', ''значение3'', ''значение2'', ''значение1''

где ''значение1'', ''значение2'' и ''значение3'' принадлежат категории 1 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])



Форма 2:



..., ''значение2'', ''значение1'' →

..., ''значение1'', ''значение2'', ''значение1''

где ''значение1'' принадлежит категории 2 вычислимых типов, а ''значение2'' принадлежит категории 1  (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Копирует одно или два значения на вершине стека операндов и записывает копию (одно или два значения) в стек ниже на одно или два значения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''dup2_x2'''''
| style="text-align:right;"  | '''''dup2_x2'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Дублирует один или два операнда на вершине стека и записывает его двумя, тремя или четырьмя значениями ниже в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''dup2_x2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''dup2_x2''= 94 (0x5e)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Форма 1:


..., ''значение4'', ''значение3'', ''значение2'', ''значение1'' →

..., ''значение2'', ''значение1'', ''значение4'', ''значение3'', ''значение2'', ''значение1''

где ''значение1'', ''значение2'', ''значение3''  и ''значение4'' принадлежат категории 1 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])



Форма 2:


..., ''значение3'', ''значение2'', ''значение1'' →

..., ''значение1'', ''значение3'', ''значение2'', ''значение1''

где ''значение1'' принадлежит категории 2 вычислимых типов, а ''значение2'' и ''значение3'' принадлежат категории 1  (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])



Форма 3:


..., ''значение3'', ''значение2'', ''значение1'' →

..., ''значение2'', ''значение1'', ''значение3'', ''значение2'', ''значение1''

где ''значение1'' и  ''значение2'' принадлежат категории 1 вычислимых типов, а  ''значение3'' принадлежит категории 1  (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])



Форма 4:


..., ''значение2'', ''значение1'' →

..., ''значение1'', ''значение2'', ''значение1''

где ''значение1'' и ''значение3'' принадлежат категории 2 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Копирует одно или два значения на вершине стека операндов и записывает копию (одно или два значения) в стек.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2d'''''
| style="text-align:right;"  | '''''f2d'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>float</font> к <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''f2d''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''f2d''= 141 (0x8d)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''→

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно быть типа <font face=Courier>float</font>. Оно считывается из стека операндов и подвергается набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]). Затем новое ''значение'' преобразуется к типу <font face=Courier>double</font>. Результат записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Там, где инструкция ''f2d'' работает в режиме FP-strict (см. [[Спецификация виртуальной машины Java#Режимы работы с плавающей точкой|§2.8.2]]), будет выполнено расширение примитивных типов (см. JLS §5.1.2). Поскольку все значения множества чисел с плавающей точкой одинарной точности (см. [[Спецификация виртуальной машины Java#Типы данных с плавающей точкой, множества значений и значения|§2.3.2]]) однозначно представимы значениями двойной точности, то расширение будет выполнено без потери точности.

Там, где инструкция ''f2d'' работает не в режиме FP-strict, результат преобразования может быть взят из множества значений двойной точности с расширенной экспонентой; он не обязательно округляется к ближайшему представимому значению двойной точности. Однако, если ''значение'' принадлежит множеству одинарной точности с расширенной экспонентой, а результат необходимо представить как значение двойной точности (но не с расширенной экспонентой), то может потребоваться округление ''значения''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2i'''''
| style="text-align:right;"  | '''''f2i'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>float</font> к <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''f2i''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''f2i''= 139 (0x8b)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно быть типа <font face=Courier>float</font>. Оно считывается из стека операндов и подвергается набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]). Затем новое ''значение'' преобразуется к типу <font face=Courier>int</font>. Результат записывается в стек операндов.
* Если новое ''значение'' не-число NaN, ''результат'' преобразования <font face=Courier>int</font> 0.
* В противном случае, если новое ''значение'' не бесконечность, оно округляется к целочисленному <font face=Courier>''V''</font> согласно IEEE 754 (округление в направлении нуля). Если это целое число представимо в типе <font face=Courier>int</font>, то <font face=Courier>''V''</font> – ''результат'' преобразования.
* Если число <font face=Courier>''V''</font> не представимо в типе <font face=Courier>int</font> (оно слишком мало или является отрицательной бесконечностью) то ''результатом'' будет наименьшее число представимое в диапазоне <font face=Courier>int</font>. Либо <font face=Courier>''V''</font> не представимо в типе <font face=Courier>int</font>, поскольку оно слишком велико или является положительной бесконечностью, то ''результатом'' будет наибольшее число представимое в диапазоне <font face=Courier>int</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''f2i'' выполняет сужающее преобразование примитивных типов, поэтому преобразуемая величина может быть потеряна полностью либо потеряна точность представления.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''f2l'''''
| style="text-align:right;"  | '''''f2l'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>float</font> к <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''f2l''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''f2l''= 140 (0x8c)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно быть типа <font face=Courier>float</font>. Оно считывается из стека операндов и подвергается набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]). Затем новое ''значение'' преобразуется к типу <font face=Courier>long</font>. Результат записывается в стек операндов.
* Если новое ''значение'' не-число NaN, ''результат'' преобразования <font face=Courier>long</font> 0.
* В противном случае, если новое ''значение'' не бесконечность, оно округляется к целочисленному <font face=Courier>''V''</font> согласно IEEE 754 (округление в направлении нуля). Если это целое число представимо в типе <font face=Courier>long</font>, то <font face=Courier>''V''</font> – ''результат'' преобразования.
* Если число <font face=Courier>''V''</font> не представимо в типе <font face=Courier>long</font> (оно слишком мало или является отрицательной бесконечностью) то ''результатом'' будет наименьшее число представимое в диапазоне <font face=Courier>long</font>. Либо <font face=Courier>''V''</font> не представимо в типе <font face=Courier>long</font>, поскольку оно слишком велико или является положительной бесконечностью, то ''результатом'' будет наибольшее число представимое в диапазоне <font face=Courier>long</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''f2l'' выполняет сужающее преобразование примитивных типов, поэтому преобразуемая величина может быть потеряна полностью либо потеряна точность представления.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fadd'''''
| style="text-align:right;"  | '''''fadd'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Складывает два значения типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fadd''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fadd''= 98 (0x62)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>float</font>. Значения считываются из стека операндов, проходят преобразования (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) становясь ''значением1''` и ''значением2''`. Результат типа <font face=Courier>float</font> равен сумме ''значение1''` + ''значение2''`. Результат записывается в стек операндов.

Суммирование производится согласно правилам арифметики IEEE:
* Если либо ''значение1''` либо  ''значение2''` есть не-число NaN, то ''результат'' есть NaN.
* Сумма двух бесконечностей противоположных знаков есть NaN.
* Сумма двух бесконечностей одинаковых знаков есть бесконечность того же знака.
* Сумма бесконечности и конечного числа есть бесконечность.
* Сумма двух нулей противоположных знаков есть положительный ноль.
* Сумма двух нулей одинаковых знаков есть ноль того же знака.
* Сумма двух не нулевых конечных значений одинаковой величины есть положительный ноль.
* В оставшихся случаях, когда ни один из операндов не бесконечность, не ноль и не NaN и ''значения'' имеют один знак или имеют разную величину, сумма вычисляется и округляется к ближайшему представимому значению согласно правилам округления IEEE 754. Если ''результат'' слишком велик, чтобы быть представленным как <font face=Courier>float</font>, мы говорим, что произошло переполнение. В этом случае ''результат'' есть бесконечность соответствующего знака. Если ''результат'' слишком мал, чтобы быть представленным как <font face=Courier>float</font>, мы говорим, что произошла потеря точности. В этом случае ''результат'' есть ноль соответствующего знака.

Инструкция ''fadd'' не генерирует исключение, если происходит переполнение или потеря точности.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''faload'''''
| style="text-align:right;"  | '''''faload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек значение из массива типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''faload''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''faload''= 48 (0x30)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'' →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>float</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', так и ''индекс'' считываются из стека операндов. ''Значение'' типа <font face=Courier>float</font> считывается из элемента массива с соответствующим индексом и записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''faload'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fastore'''''
| style="text-align:right;"  | '''''fastore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает значение типа <font face=Courier>float</font>  в массив
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fastore''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fastore''= 81 (0x51)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'', ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>float</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>, ''значение'' должно принадлежать типу <font face=Courier>float</font>. ''Ссылка на массив'', ''индекс'' и ''значение'' считываются из стека операндов. Над значением проводится набор преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), в результате которых ''значение''` сохраняется в массиве с заданным индексом.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''fastore'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fcmp<op>'''''
| style="text-align:right;"  | '''''fcmp<op>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Сравнивает два значение типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fcmp<op>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fcmpg''= 150 (0x96)

''fcmpl''= 149 (0x95)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>float</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются на ''значение1''` и ''значение2''`.

Сравнение значений с плавающей точкой производится следующим образом:

* Если ''значение1''` больше чем ''значение2''`, то в стек операндов записывается единица с типом <font face=Courier>int</font>.
* В противном случае, если ''значение1''` равно значению2`, то в стек операндов записывается ноль с типом <font face=Courier>int</font>.
* В противном случае, если ''значение1''` меньше чем ''значение2''`, то в стек операндов записывается минус единица с типом <font face=Courier>int</font>.
* В противном случае, по крайней мере, одно ''значение'' (либо ''значение1''`, либо ''значение2''`) есть не-число NaN. В этом случае инструкция ''fcmpg'' записывает 1 с типом <font face=Courier>int</font> в стек операндов, а инструкция ''fcmpl'' записывает -1 с типом <font face=Courier>int</font> в стек операндов.

Сравнение чисел с плавающей точкой выполняется согласно требованиям стандарта <font face=Courier>IEEE754</font>. Все ''значения'', отличные от не-числа NaN упорядочены, причем отрицательная бесконечность меньше чем все числа, а положительная бесконечность больше чем все числа. Положительный и отрицательный ноль считаются равными.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкции ''fcmpg'' и ''fcmpl'' отличаются только своим поведением при сравнении не-чисел NaN. Поскольку NaN не упорядочено, любое сравнения не-числа NaN и значения типа <font face=Courier>float</font> не определено, в случае, когда один либо оба операнда не-числа NaN. С помощью инструкций ''fcmpg'' и ''fcmpl'' любое сравнения чисел типа <font face=Courier>float</font> может быть скомпилировано так, чтобы выдавать результат, совпадающий и при сравнение обычных чисел и при сравнении не-чисел NaN. Более подробную информацию см. в [[Спецификация виртуальной машины Java#Передача управления|§3.5]].
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fconst_<f>'''''
| style="text-align:right;"  | '''''fconst_<f>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек константу типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fconst_<f>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fconst_0''= 11 (0xb)

''fconst_1''= 12 (0xc)

''fconst_2''= 13 (0xd)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|... →

..., <f>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Записывает константу <<font face=Courier>''f''</font>> типа <font face=Courier>float</font>  (0.0, 1.0 или 2.0) в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fdiv'''''
| style="text-align:right;"  | '''''fdiv'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Делит два значение типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fdiv''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fdiv''= 110 (0x6e)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>float</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются на ''значение1''` и ''значение2''`.

''Результат'' – это число типа <font face=Courier>float</font> равное ''значение1''`/ ''значение2''`. Затем ''результат'' записывается в стек операндов.

''Результат'' инструкции ''fdiv'' вычисляется согласно правилам арифметики стандарта IEEE:
* Если либо ''значение1''` либо  ''значение2''` есть не-число NaN, то ''результат'' есть NaN.
* Если ни ''значение1''` ни  ''значение2''` не являются не-числами NaN, то знак результата деления положительный, если делимое и делитель имеют один знак и отрицательный в противном случае.
* Деление бесконечности на бесконечность даёт не-число NaN.
* Деление бесконечности на конечное ''значение'' даёт бесконечность, знак которой определён по правилу, описанному выше.
* Деление конечного ''значения'' на бесконечность даёт знаковый ноль, знак которого определён по правилу, описанному выше.
* Деление ноль на ноль даёт не-число NaN; деление ноля на конечное ''значение'' даёт знаковый ноль, знак которого определён по правилу, описанному выше.
* Деление не нулевого конечного ''значения'' на ноль дает бесконечность, знак которой определён по правилу, описанному выше.
* В оставшихся случаях, когда операнды не бесконечность, не ноль и не NaN частное вычисляется и округляется к ближайшему <font face=Courier>float</font>, используя режим округления к ближайшему стандарта IEEE 754. Если величина слишком велика, чтобы быть представленной в диапазоне типа <font face=Courier>float</font>, говорят, что произошло переполнение. В этом случае ''результатом'' является бесконечность соответствующего знака. Если величина слишком мала, чтобы быть представленной в диапазоне типа <font face=Courier>float</font>, говорят, что произошла потеря точности. В этом случае ''результатом'' является ноль соответствующего знака.

Несмотря на переполнение, потерю точности, деление на ноль инструкция ''fdiv'' никогда не генерирует исключение времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fload'''''
| style="text-align:right;"  | '''''fload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек значение типа <font face=Courier>float</font> из локальной переменной
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fload''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fload''= 23 (0x17)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом. ''Индекс'' должен принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с заданным индексом должна содержать величину типа <font face=Courier>float</font>. ''Значение'' локальной переменной, с заданным индексом, записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''fload'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый индекс локальной переменной.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fload_<n>'''''
| style="text-align:right;"  | '''''fload_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек значение типа <font face=Courier>float</font> из локальной переменной
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fload_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fload_0''= 34 (0x22)

''fload_1''= 35 (0x23)

''fload_2''= 36 (0x24)

''fload_3''= 37 (0x25)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|<n> должно принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная <n> должна содержать величину типа <font face=Courier>float</font>. ''Значение'' локальной переменной <n>, записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из инструкции ''fload_<n>'' выполняет то же, что и ''fload'' с явным индексом <n> за исключением того, что операнд <n> задан не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fmul'''''
| style="text-align:right;"  | '''''fmul'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Умножает два значения типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fmul''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fmul''= 106 (0x6a)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>float</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются на ''значение1''` и ''значение2''`.

''Результат'' – это число типа <font face=Courier>float</font> равное ''значение1''`* ''значение2''`. Затем ''результат'' записывается в стек операндов.

''Результат'' инструкции ''fmul'' вычисляется согласно правилам арифметики стандарта IEEE:
* Если либо ''значение1''` либо  ''значение2''` есть не-число NaN, то ''результат'' есть NaN.
* Если ни ''значение1''` ни  ''значение2''` не являются не-числами NaN, то знак результата умножения положительный, если операнды имеют один знак и отрицательный в противном случае.
* Умножение бесконечности на ноль даёт не-число NaN.
* Умножение бесконечности на конечное ''значение'' даёт бесконечность, знак которой определён по правилу, описанному выше.
* В оставшихся случаях, когда операнды не бесконечность, не ноль и не NaN произведение вычисляется и округляется к ближайшему <font face=Courier>float</font>, используя режим округления к ближайшему стандарта IEEE 754. Если величина слишком велика, чтобы быть представленной в диапазоне типа <font face=Courier>float</font>, говорят, что произошло переполнение. В этом случае ''результатом'' является бесконечность соответствующего знака. Если величина слишком мала, чтобы быть представленной в диапазоне типа <font face=Courier>float</font>, говорят, что произошла потеря точности. В этом случае ''результатом'' является ноль соответствующего знака.

Несмотря на переполнение, потерю точности ''fmul'' никогда не генерирует исключение времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fneg'''''
| style="text-align:right;"  | '''''fneg'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Инвертирует значение типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fneg''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fneg''= 118 (0x76)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' должно принадлежать типу <font face=Courier>float</font>. Оно считывается из стека операндов, и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), а затем заменяется значением`. ''Результат'' – это число типа <font face=Courier>float</font> равное арифметическому отрицанию ''значения''`. Затем ''результат'' записывается в стек операндов.

Для значений типа <font face=Courier>float</font> отрицание не есть то же самое, что и вычитание из нуля. Если <font face=Courier>''x''</font> это  +0.0, то  0.0 - <font face=Courier>''x''</font> равно  +0.0, но  -<font face=Courier>''x''</font> равно  -0.0. Унарный минус лишь инвертирует знак числа типа <font face=Courier>float</font>.

Особые случаи:
* Если  операнд есть не-число NaN, то ''результат'' также NaN (поскольку у NaN нет знака).
* Если операнд – бесконечность, то ''результат'' – бесконечность противоположного знака.
* Если операнд – ноль, то ''результат'' – ноль противоположного знака.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''frem'''''
| style="text-align:right;"  | '''''frem'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Остаток от деления двух значений типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''frem''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''frem''= 114 (0x72)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>float</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются  ''значением1''` и ''значением2''`.

''Результат'' вычисляется и записывается в стек операндов с типом <font face=Courier>float</font>.

''Результат'' инструкции ''frem'' не совпадает с операцией вычисления остатка для чисел с плавающей точкой, определённой в стандарте IEEE 754. Операция вычисления остатка, заданная в стандарте IEEE 754, вычисляет остаток от «округляющего» деления, а не «урезающего» деления, так что ее поведение не аналогично обычной операции целочисленного вычисления остатка. Вместо этого в виртуальной машине Java поведение инструкции ''frem'' определено наподобие инструкций целочисленного вычисления остатка (''irem'' и ''lrem''); инструкцию ''frem'' можно сравнить с библиотечной функцией <font face=Courier>fmod</font> языка <font face=Courier>''C''</font>.

''Результат'' инструкции ''frem'' вычисляется согласно следующим правилам:
* Если либо ''значение1''` либо  ''значение2''` есть не-число NaN, то ''результат'' есть NaN.
* Если ни ''значение1''` ни  ''значение2''` не являются не-числами NaN, то знак результата совпадает со знаком делимого.
* Если делимое есть бесконечность или делитель есть ноль, либо оба числа есть нули, то ''результат'' – не-число  NaN.
* Если делимое есть конечное ''значение'', а делитель – бесконечность, то ''результат'' (остаток от деления) равен делимому.
* Если делимое есть ноль, а делитель – конечное ''значение'', то ''результат'' (остаток от деления) равен делимому.
* В оставшихся случаях, когда операнды не бесконечность, не ноль и не NaN остаток от деления с плавающей точкой делимого ''значения1''` на делитель ''значение2''` определяется следующим отношением: ''результат'' = ''значение1''` - (''значение2''` * q), где q – целое число, имеющее знак минус в случае, если ''значение1''` / ''значение2''` отрицательно и знак плюс, если ''значение1''` / ''значение2''` положительно. Величина коэффициента q равно наибольшему целому не превосходящему частного от деления ''значения1''` на ''значение2''`.

Несмотря на деление на ноль инструкция ''frem'' никогда не генерирует исключение времени выполнения. Переполнение и потеря точности не могут произойти для этой инструкции.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Остаток от деления согласно спецификации IEEE 754 может быть вычислен с помощью метода <font face=Courier>Math</font>.<font face=Courier>IEEEremainder</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''freturn'''''
| style="text-align:right;"  | '''''freturn'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Возвращает значение <font face=Courier>float</font> из метода
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''freturn''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''freturn''= 174 (0xae)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

[пусто]
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Текущий метод должен возвращать величину типа <font face=Courier>float</font>. ''Значение'' также должно принадлежать <font face=Courier>float</font>. Если текущий метод объявлен с ключевым словом <font face=Courier>synchronized</font>, то при входе в метод монитор захватывается первоначально (либо повторно, если уже был захвачен до того), а при выходе освобождается, как при выполнении инструкции ''monitorexit'' для текущего потока. Если в ходе выполнения метода не было исключений, ''значение'' считывается из стека операндов текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]) и проходит ряд преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]). Затем преобразованное  ''значение''` записывается в стек операндов фрейма, принадлежащего вызывающему методу. Все остальные ''значения'' стека операндов текущего фрейма теряются.

Затем интерпретатор передаёт управление вызывающему методу, делая текущим соответствующий фрейм.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если реализация виртуальной машины Java не поддерживает правила структурных блокировок описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], тогда если текущий метод объявлен как  <font face=Courier>synchronized</font> и текущий поток не является владельцем монитора, захваченного при входе в метод, то при вызове ''freturn'' будет выброшено исключение <font face=Courier>IllegalMonitorStateException</font>. Это может произойти, если <font face=Courier>synchronized</font>-метод содержит инструкцию ''monitorexit'', а инструкция ''monitorenter'' по объекту синхронизации отсутствует.

С другой стороны, если реализация виртуальной машины Java  поддерживает правила структурных блокировок описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], и во время выполнения текущего метода нарушено первое из этих правил, то при вызове ''freturn'' будет выброшено исключение <font face=Courier>IllegalMonitorStateException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fstore'''''
| style="text-align:right;"  | '''''fstore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>float</font>  из стека в локальную переменную
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fstore''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fstore''= 56 (0x38)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом и должен принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение''  на вершине стека операндов должно принадлежать типу <font face=Courier>float</font>. Оно считывается из стека операндов, и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), а затем заменяется значением`. В локальную переменную с индексом ''индекс'' записывается ''значение''`.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''fstore'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый индекс локальной переменной.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fstore_<n>'''''
| style="text-align:right;"  | '''''fstore_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>float</font>  из стека в локальную переменную
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fstore_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fstore_0''= 67 (0x43)

''fstore_1''= 68 (0x44)

''fstore_2''= 69 (0x45)

''fstore_3''= 70 (0x46)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|<n> должно принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение''  на вершине стека операндов должно принадлежать типу <font face=Courier>float</font>. Оно считывается из стека операндов, и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), а затем заменяется значением`. В локальную переменную с индексом <n> записывается ''значение''`.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из инструкции ''fstore_<n>'' выполняет то же, что и ''fstore'' с явным индексом <n> за исключением того, что операнд <n> задан не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''fsub'''''
| style="text-align:right;"  | '''''fsub'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вычитает два значения типа <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''fsub''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''fsub''= 102 (0x66)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

...,''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>float</font>. Значения считываются из стека операндов и подвергаются набору преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]) и заменяются на ''значение1''` и ''значение2''`. ''Результат'' – это число типа <font face=Courier>float</font> равное ''значение1''`- ''значение2''`. Затем ''результат'' записывается в стек операндов.

Для операндов типа <font face=Courier>float</font> всегда справедливо, что выражение <font face=Courier>''a''</font>-<font face=Courier>''b''</font> дает такой же ''результат'', как и <font face=Courier>''a''</font>+(-<font face=Courier>''b''</font>). Тем не менее, для инструкции ''fsub'' вычитание ''значения'' из нуля не то же самое, что и отрицание, потому что если <font face=Courier>''x''</font> это +0.0, тогда 0.0-<font face=Courier>''x''</font> равно +0.0, но  -<font face=Courier>''x''</font> равно -0.0.

Несмотря на переполнение, потерю точности ''fsub'' никогда не генерирует исключение времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''getfield'''''
| style="text-align:right;"  | '''''getfield'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Извлекает поле из объекта
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''getfield''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''getfield''= 180 (0xb4)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'' →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на объект'', которая  должна принадлежать типу <font face=Courier>reference</font>, считывается из стека операндов. Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' элемента  в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение'' ''индекса'' рассчитывается по формуле (''байт_индекса1'' << 8) <nowiki>|</nowiki> ''байт_индекса2''. Элемент константного пула с рассчитанным индексом должен быть ссылкой на поле (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]). Эта ссылка на поле содержит имя поля и его дескриптор, а также ссылку на класс, где это поле может быть найдено. Затем по ссылке на объект и дескриптору поля ''значение'' считывается и записывается в стек операндов.

''Ссылка на объект'' не должна ссылаться на массив. Если поле класса объявлено как <font face=Courier>protected</font> (см. [[Спецификация виртуальной машины Java#Методы|§4.6]]) и оно принадлежит предку текущего класса и не объявлено в том же пакете что и текущий класс ([[Спецификация виртуальной машины Java#Создание и загрузка|§5.3]]), то в этом случае ''ссылка на объект'' должна указывать либо на текущий класс, либо на его предка.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения ссылки может быть выброшено любое исключение, указанное в [[Спецификация виртуальной машины Java#Разрешение поля|§5.4.3.2]].

При попытке получить значение поля <font face=Courier>static</font> с помощью инструкции ''getfield'', будет выброшено исключение <font face=Courier>IncompatibleClassChangeError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' равна <font face=Courier>null</font>, инструкция ''getfield'' генерирует <font face=Courier>NullPointerException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''getfield'' не может быть использована для доступа к полю массива <font face=Courier>length</font>. Для этой цели необходимо использовать инструкцию ''arraylength''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''getstatic'''''
| style="text-align:right;"  | '''''getstatic'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Извлекает статическое поле из класса
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''getstatic''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса1''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''getstatic''= 178 (0xb2)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...,  →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_индекса1'' и байт_индекса2 используются для построения ''индекса'' элемента  в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение'' ''индекса'' рассчитывается по формуле (''байт_индекса1'' << 8) <nowiki>|</nowiki> байт_индекса2. Элемент константного пула с рассчитанным индексом должен быть ссылкой на поле (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]). Эта ссылка на поле содержит имя поля и его дескриптор, а также ссылку на класс или интерфейс, где это поле может быть найдено. После ссылка разрешается (см. [[Спецификация виртуальной машины Java#Разрешение поля|§5.4.3.2]]).

Если разрешение ссылки было успешным, а класс или интерфейс, чьё поле нужно получить, ещё не инициализирован, то класс или интерфейс инициализируется.

Затем ''значение'' считывается из класса или интерфейса и записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения ссылки может быть выброшено любое исключение, указанное в [[Спецификация виртуальной машины Java#Разрешение поля|§5.4.3.2]].

При попытке получить значение поля, которое не объявлено статическим, с помощью инструкции ''getstatic'', будет выброшено исключение <font face=Courier>IncompatibleClassChangeError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если вызов инструкции ''getstatic'' приводит к инициализации класса или интерфейса, то ''getstatic'' может вызвать ошибку, более подробно описанную в разделе [[Спецификация виртуальной машины Java#Инициализация|§5.5]].
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''goto'''''
| style="text-align:right;"  | '''''goto'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Безусловный переход
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''goto''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''goto''= 167 (0xa7)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Без изменений
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_адреса1'' и ''байт_адреса2'' используются для построения 16-битового знакового смещения перехода (''байт_адреса1'' << 8) <nowiki>|</nowiki> ''байт_адреса2''. Смещение выполняется относительно индекса инструкции ''goto'', управление передаётся команде, находящейся по рассчитанному смещению. Смещение должно находиться в пределах метода, содержащего инструкцию ''goto''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''goto_w'''''
| style="text-align:right;"  | '''''goto_w'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Безусловный переход (широкий индекс)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''goto_w''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|-
| style="vertical-align:top;"|''байт_адреса3''
|-
| style="vertical-align:top;"|''байт_адреса4''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''goto_w''= 200 (0xc8)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Без изменений
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_адреса1'', ''байт_адреса2'', ''байт_адреса3'' и ''байт_адреса4'' используются для построения 32-битового знакового смещения перехода (''байт_адреса1'' << 24) <nowiki>|</nowiki> (''байт_адреса2'' << 16) (''байт_адреса3'' << 8) <nowiki>|</nowiki> ''байт_адреса4''. Смещение выполняется относительно индекса инструкции ''goto_w'', управление передаётся команде, находящейся по рассчитанному смещению. Смещение должно находиться в пределах метода, содержащего инструкцию ''goto_w''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Хотя инструкция ''goto_w'' принимает на вход 4-х байтовое смещение, ограничивающим фактором для перехода является также размер метода, равный 65535 байтам (см. [[Спецификация виртуальной машины Java#Ограничения виртуальной машины Java|§4.11]]). Это ограничение может быть снято в последующих версиях виртуальной Java машины.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2b'''''
| style="text-align:right;"  | '''''i2b'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>int</font> к <font face=Courier>byte</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''i2b''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''i2b''= 145 (0x91)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>int</font>. Оно считывается с вершины стека операндов, обрезается до размера <font face=Courier>byte</font>, а затем расширяется с учётом знака снова к типу <font face=Courier>int</font>. ''Результат'' расширения  записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''i2b'' выполняет сужающее преобразование примитивных типов (см. JLS §5.1.3). Это может привести к потере исходного ''значения''. Знак ''результата'' может также отличатся от знака исходного ''значения''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2c'''''
| style="text-align:right;"  | '''''i2c'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>int</font> к <font face=Courier>char</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''i2c''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''i2c''= 146 (0x92)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>int</font>. Оно считывается с вершины стека операндов, обрезается до размера <font face=Courier>char</font>, а затем расширяется без учёта знака снова к типу <font face=Courier>int</font>. ''Результат'' расширения  записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''i2c'' выполняет сужающее преобразование примитивных типов (см. JLS §5.1.3). Это может привести к потере исходного ''значения''. Знак ''результата'' может также отличатся от знака исходного ''значения''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2d'''''
| style="text-align:right;"  | '''''i2d'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>int</font> к <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''i2d''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''i2d''= 135 (0x87)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>int</font>. Оно считывается с вершины стека операндов и преобразуется к типу <font face=Courier>double</font>. ''Результат''  записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''i2d'' выполняет расширяющее преобразование примитивных типов. Поскольку все ''значения'' типа <font face=Courier>int</font> точно представимы в типе <font face=Courier>double</font>, то преобразование точное.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2f'''''
| style="text-align:right;"  | '''''i2f'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>int</font> к <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''i2f''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''i2f''= 134 (0x86)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>int</font>. Оно считывается с вершины стека операндов и преобразуется к типу <font face=Courier>double</font>, согласно правилам округления к ближайшему стандарта IEEE 754. ''Результат''  записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''i2d'' выполняет расширяющее преобразование примитивных типов (см. JLS §5.1.2), но может привести к потере точности, поскольку тип <font face=Courier>float</font> имеет только 24 бита для хранения мантиссы ''значения''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2l'''''
| style="text-align:right;"  | '''''i2l'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>int</font> к <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''i2l''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''i2l''= 133 (0x85)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>int</font>. Оно считывается с вершины стека операндов и преобразуется к типу <font face=Courier>long</font> (путем знакового расширения). ''Результат''  записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''i2l'' выполняет расширяющее преобразование примитивных типов (см. JLS §5.1.2). Поскольку все ''значения'' типа <font face=Courier>int</font> точно представимы в типе <font face=Courier>long</font>, то преобразование точное.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''i2s'''''
| style="text-align:right;"  | '''''i2s'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>int</font> к <font face=Courier>short</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''i2s''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''i2s''= 147 (0x93)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>int</font>. Оно считывается с вершины стека операндов, обрезается до размера <font face=Courier>short</font>, а затем расширяется с учётом знака снова к типу <font face=Courier>int</font>. ''Результат'' расширения  записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''i2s'' выполняет сужающее преобразование примитивных типов (см. JLS §5.1.3). Это может привести к потере исходного ''значения''. Знак ''результата'' может также отличатся от знака исходного ''значения''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iadd'''''
| style="text-align:right;"  | '''''iadd'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Складывает два значения типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iadd''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iadd''= 96 (0x60)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются с вершины стек операндов. ''Результат'' типа <font face=Courier>int</font>  есть  ''значение1'' + ''значение2''. ''Результат'' записывается в стек операндов.

''Результат'' сложения - это младшие 32 бита ''результата'' точного сложения, представленные в двоичном дополнительном коде. Если происходит переполнение, то знак ''результата'' может отличаться от знака  математической суммы двух значений.

Не смотря на то, что при выполнении инструкции ''iadd'' может произойти переполнение, инструкция ''iadd'' никогда не приводит к исключению времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iaload'''''
| style="text-align:right;"  | '''''iaload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек значение <font face=Courier>int</font> из массива
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iaload''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iaload''= 46 (0x2e)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'' →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>int</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', так и ''индекс'' считываются из стека операндов. ''Значение'' типа <font face=Courier>int</font> считывается из элемента массива с соответствующим индексом и записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''iaload'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iand'''''
| style="text-align:right;"  | '''''iand'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Логическое «И» над значениями с типом <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iand''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iand''= 126 (0x7e)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

...,''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются с вершины стек операндов. ''Результат'' типа <font face=Courier>int</font>  есть логическое "И" над ''значением1'' и ''значением2''. ''Результат'' записывается в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iastore'''''
| style="text-align:right;"  | '''''iastore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значения типа <font face=Courier>int</font> из стека в массив
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iastore''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iastore''= 79 (0x4f)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'', ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>int</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>, ''значение'' должно принадлежать типу <font face=Courier>int</font>. ''Ссылка на массив'', ''индекс'' и ''значение'' считываются из стека операндов. Затем ''значение'' сохраняется в массиве с заданным ''индексом''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''iastore'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iconst_<i>'''''
| style="text-align:right;"  | '''''iconst_<i>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек константу типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iconst_<i>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iconst_m1''= 2 (0x2)

''iconst_0''= 3 (0x3)

''iconst_1''= 4 (0x4)

''iconst_2''= 5 (0x5)

''iconst_3''= 6 (0x6)

''iconst_4''= 7 (0x7)

''iconst_5''= 8 (0x8)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., <i>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Записывает в стек целочисленную константу <i> (-1, 0, 1, 2, 3, 4 или 5)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из семейства инструкций эквивалента ''bipush'' <i>  с соответствующим аргументом, за исключением того, что  <i> задано не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''idiv'''''
| style="text-align:right;"  | '''''idiv'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Делит два целых значения
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''idiv''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''idiv''= 108 (0x6c)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Значения считываются с вершины стека операндов. ''Результат'' также принадлежит типу <font face=Courier>int</font> и равен ''значение1'' / ''значение2''. После вычисления ''результат'' записывается в стек операндов.

''Результат'' целочисленного деления округляется по направлению к нулю. Это значит, частное целочисленного деления n / d это число q, максимальное из всех, удовлетворяющих неравенству <nowiki>|</nowiki>d · q<nowiki>|</nowiki>  ≤ <nowiki>|</nowiki>n<nowiki>|</nowiki>. Кроме того q положительно, когда <nowiki>|</nowiki>n<nowiki>|</nowiki>  ≥ <nowiki>|</nowiki>d<nowiki>|</nowiki> и при этом n и  d имеют одинаковый знак и q отрицательно, когда <nowiki>|</nowiki>n<nowiki>|</nowiki>  ≥ <nowiki>|</nowiki>d<nowiki>|</nowiki> и при этом n и d имеют разные знаки.

Существует один специальный случай, который не подходит под описанные выше правила: если делимое – это отрицательное целое, максимальное по модулю для типа <font face=Courier>int</font>, а делитель равен -1, то происходит переполнение и ''результат'' равен делимому. Несмотря на переполнение, в этом случае исключение не выбрасывается.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если делитель целочисленного деления есть 0, то ''idiv'' генерирует исключение <font face=Courier>ArithmeticException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if_acmp<cond>'''''
| style="text-align:right;"  | '''''if_acmp<cond>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Переход, если значения типа <font face=Courier>reference</font> равны
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''if_acmp<cond>''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''if_acmpeq''= 165 (0xa5)

''if_acmpne''= 166 (0xa6)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>reference</font>. Они оба считываются из стека операндов и сравниваются. Результат сравнения следующий:

* ''if_acmpeq'' дает истину, если <font face=Courier>value1</font>= <font face=Courier>value2</font>
* ''if_acmpne'' дает истину, если <font face=Courier>value1</font> ≠ <font face=Courier>value2</font>

Если сравнение дало истину, беззнаковые ''байт_адреса1'' и ''байт_адреса2'' используются для построения знакового 16-ти битового смещения, которое вычисляется следующим образом: (''байт_адреса1'' << 8) <nowiki>|</nowiki> ''байт_адреса2''. Затем выполнение инструкций продолжается со смещения, вычисленного ранее относительно инструкции ''if_acmp<cond>''. Целевой адрес перехода должен быть в пределах метода, содержащего ''if_acmp<cond>''.

В противном случае (если сравнение дало ложь), выполнение инструкций продолжается непосредственно с инструкции, следующей за ''if_acmp<cond>''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if_icmp<cond>'''''
| style="text-align:right;"  | '''''if_icmp<cond>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Переход, если значения типа <font face=Courier>int</font> удовлетворяют условию
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''if_icmp<cond>''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''if_icmpeq''= 159 (0x9f)

''if_icmpne''= 160 (0xa0)

''if_icmplt''= 161 (0xa1)

''if_icmpge''= 162 (0xa2)

''if_icmpgt''= 163 (0xa3)

''if_icmple''= 164 (0xa4)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они оба считываются из стека операндов и сравниваются. Все сравнения – знаковые. Результаты сравнения вычисляются следующим образом:

* if_icmpeq истинно тогда и только тогда, когда value1= value2
* if_icmpne истинно тогда и только тогда, когда value1 ≠ value2
* if_icmplt истинно тогда и только тогда, когда value1< value2
* if_icmple истинно тогда и только тогда, когда value1 ≤ value2
* if_icmpgt истинно тогда и только тогда, когда value1> value2
* if_icmpge истинно тогда и только тогда, когда value1 ≥ value2

Если сравнение дало истину, беззнаковые ''байт_адреса1'' и ''байт_адреса2'' используются для построения знакового 16-ти битового смещения, которое вычисляется следующим образом: (''байт_адреса1'' << 8) <nowiki>|</nowiki> ''байт_адреса2''. Затем выполнение инструкций продолжается со смещения, вычисленного ранее относительно инструкции ''if_icmp<cond>''. Целевой адрес перехода должен быть в пределах метода, содержащего ''if_icmp<cond>''.

В противном случае (если сравнение дало ложь), выполнение инструкций продолжается непосредственно с инструкции, следующей за ''if_icmp<cond>''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''if<cond>'''''
| style="text-align:right;"  | '''''if<cond>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Переход, если сравнение значения типа <font face=Courier>int</font> с нулем – «истина»
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''if<cond>''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ifeq''= 153 (0x99)

''ifne''= 154 (0x9a)

''iflt''= 155 (0x9b)

''ifge''= 156 (0x9c)

''ifgt''= 157 (0x9d)

''ifle''= 158 (0x9e)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' должно принадлежать типу <font face=Courier>int</font>. Оно  считывается из стека операндов и сравнивается с нулём. Все сравнения – знаковые. Результаты сравнения вычисляются следующим образом:

* ''ifeq'' истинно тогда и только тогда, когда <font face=Courier>value</font> = 0
* ''ifne'' истинно тогда и только тогда, когда <font face=Courier>value</font> ≠ 0
* ''iflt'' истинно тогда и только тогда, когда <font face=Courier>value</font> < 0
* ''ifle'' истинно тогда и только тогда, когда <font face=Courier>value</font> ≤ 0
* ''ifgt'' истинно тогда и только тогда, когда <font face=Courier>value</font> > 0
* ''ifge'' истинно тогда и только тогда, когда <font face=Courier>value</font> ≥ 0

Если сравнение дало истину, беззнаковые ''байт_адреса1'' и ''байт_адреса2'' используются для построения знакового 16-ти битового смещения, которое вычисляется следующим образом: (''байт_адреса1'' << 8) <nowiki>|</nowiki> ''байт_адреса2''. Затем выполнение инструкций продолжается со смещения, вычисленного ранее относительно инструкции ''if<cond>''. Целевой адрес перехода должен быть в пределах метода, содержащего ''if<cond>''.

В противном случае (если сравнение дало ложь), выполнение инструкций продолжается непосредственно с инструкции, следующей за ''if<cond>''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ifnonnull'''''
| style="text-align:right;"  | '''''ifnonnull'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Переход, если значение типа <font face=Courier>reference</font> не <font face=Courier>null</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ifnonnull''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ifnonnull''= 199 (0xc7)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' должно принадлежать типу <font face=Courier>reference</font>. Оно считываются из стека операндов.  Если ''значение''  не <font face=Courier>null</font> то, беззнаковые ''байт_адреса1'' и ''байт_адреса2'' используются для построения знакового 16-ти битового смещения, которое вычисляется следующим образом: (''байт_адреса1'' << 8) <nowiki>|</nowiki> ''байт_адреса2''. Затем выполнение инструкций продолжается со смещения, вычисленного ранее относительно инструкции ''ifnonnull''. Целевой адрес перехода должен быть в пределах метода, содержащего ''ifnonnull''.

В противном случае (если сравнение дало ложь), выполнение инструкций продолжается непосредственно с инструкции, следующей за ''ifnonnull''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ifnull'''''
| style="text-align:right;"  | '''''ifnull'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Переход, если значение типа <font face=Courier>reference</font> равно <font face=Courier>null</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ifnull''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ifnull''= 198 (0xc6)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' должно принадлежать типу <font face=Courier>reference</font>. Оно считываются из стека операндов.  Если ''значение''   <font face=Courier>null</font> то, беззнаковые ''байт_адреса1'' и ''байт_адреса2'' используются для построения знакового 16-ти битового смещения, которое вычисляется следующим образом: (''байт_адреса1'' << 8) <nowiki>|</nowiki> ''байт_адреса2''. Затем выполнение инструкций продолжается со смещения, вычисленного ранее относительно инструкции ''ifnull''. Целевой адрес перехода должен быть в пределах метода, содержащего ''ifnull''.

В противном случае (если сравнение дало ложь), выполнение инструкций продолжается непосредственно с инструкции, следующей за ''ifnull''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iinc'''''
| style="text-align:right;"  | '''''iinc'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Увеличивает локальную переменную на заданную константу
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iinc''
|-
| style="vertical-align:top;"|''индекс''
|-
| style="vertical-align:top;"|''константа''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iinc''= 132 (0x84)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Без изменений
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' – это беззнаковый байт, который должен быть ''индексом'' локальной переменной текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Константа'' – знаковый байт, следующий непосредственно за кодом операции. Локальная переменная с заданным ''индексом'' должна содержать значение типа <font face=Courier>int</font>. Затем ''константа'' расширяется с учётом знака до типа <font face=Courier>int</font> и добавляется к локальной переменной с заданным ''индексом''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''iinc'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый ''индекс'' локальной переменной и при этом увеличить переменную на двухбайтовое знаковое значение.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iload'''''
| style="text-align:right;"  | '''''iload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>int</font> из локальной переменной в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iload''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iload''= 21 (0x15)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом. ''Индекс'' должен принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с заданным ''индексом'' должна содержать величину типа <font face=Courier>int</font>. ''Значение'' локальной переменной, с заданным ''индексом'', записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''iload'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый ''индекс'' локальной переменной.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iload_<n>'''''
| style="text-align:right;"  | '''''iload_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек значение локальной переменной типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iload_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iload_0''= 26 (0x1a)

''iload_1''= 27 (0x1b)

''iload_2''= 28 (0x1c)

''iload_3''= 29 (0x1d)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|... →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|<n> должно принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с заданным <n> должна содержать величину типа <font face=Courier>int</font>. ''Значение'' локальной переменной, с заданным <n>, записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из инструкции ''iload_<n>'' выполняет то же, что и ''iload'' с явным индексом <n> за исключением того, что операнд <n> задан не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''imul'''''
| style="text-align:right;"  | '''''imul'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Умножает два значения типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''imul''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''imul''= 104 (0x68)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Значения считываются с вершины стека операндов. ''Результат'' также принадлежит типу <font face=Courier>int</font> и равен ''значение1'' * ''значение2''. После вычисления ''результат'' записывается в стек операндов.

''Результат'' умножения – это младшие 32 бита истинного математического ''результата'', представленного в двоичном дополнительном формате в типе <font face=Courier>int</font>. Если происходит переполнение, то знак ''результата'' может не совпадать со знаком истинного математического ''результата''.

Несмотря на то, что переполнение возможно, исключение инструкцией ''imul'' не выбрасывается.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ineg'''''
| style="text-align:right;"  | '''''ineg'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Инвертирует значение типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ineg''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ineg''= 116 (0x74)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''→

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' должно принадлежать типу <font face=Courier>int</font>. Оно считывается со стека операндов. ''Результат'' принадлежит типу <font face=Courier>int</font> и является арифметическим отрицанием ''значения''. ''Результат'' записывается в стек операндов.

Для величин, принадлежащих типу <font face=Courier>int</font>, отрицание – это тоже, что и вычитание из нуля. Поскольку виртуальная машина Java использует для целых чисел представление в двоичном дополнительном коде, а это представление не симметрично, то отрицание максимального по модулю отрицательного числа типа <font face=Courier>int</font> есть это же число. В этом случае происходит переполнение, однако, несмотря на это исключение не генерируется.

Для всех целых чисел <font face=Courier>''x''</font> принадлежащих типу <font face=Courier>int</font>, -<font face=Courier>''x''</font> равно (~<font face=Courier>''x''</font>) + 1.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''instanceof'''''
| style="text-align:right;"  | '''''instanceof'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Определяет, принадлежит ли объект заданному типу
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''instanceof''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''instanceof''= 193 (0xc1)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font>. Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула, на который указывает построенный ''индекс'', должен быть ссылкой на класс, массив или интерфейс.

Если ''ссылка на объект'' равна <font face=Courier>null</font>, то в  стек операндов записывается ''результат'' 0 с типом <font face=Courier>int</font>.

В противном случае класс, массив или интерфейс разрешается (см. [[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]). Если ''ссылка на объект'' может быть преобразована к разрешённому ранее классу, массиву или интерфейсу, то в  стек операндов записывается ''результат'' 1 с типом <font face=Courier>int</font>. В противном случае инструкция ''instanceof'' в  стек операндов записывает ''результат'' 0 с типом <font face=Courier>int</font>.

Если ''ссылка на объект''  не равна <font face=Courier>null</font>, то используются следующие правила для разрешения типов: если <font face=Courier>''S''</font>  - класс, на который  ссылается ''ссылка на объект'', а <font face=Courier>''T''</font> – разрешаемый класс, массив или интерфейс, то ''instanceof'' проверяет следующее:
* Если <font face=Courier>''S''</font> - это класс, тогда:
** Если <font face=Courier>''T''</font> – это класс, то <font face=Courier>''S''</font> должно быть такого же класса, как и <font face=Courier>''T''</font> либо <font face=Courier>''S''</font> должно быть наследником <font face=Courier>''T''</font>;
** Если <font face=Courier>''T''</font> – это интерфейс, то <font face=Courier>''S''</font> должно реализовывать этот интерфейс;
* Если <font face=Courier>''S''</font> - это интерфейс, тогда:
** Если <font face=Courier>''T''</font> – это класс, тогда <font face=Courier>''T''</font> должно быть типа <font face=Courier>Object</font>.
** Если <font face=Courier>''T''</font> – это интерфейс, то <font face=Courier>''S''</font> должно быть тем же интерфейсом или интерфейсом-предком <font face=Courier>''S''</font>.
* Если <font face=Courier>''S''</font> – это массив (назовём его <font face=Courier><font face=Courier>''SC''</font></font>[], что значит массив с компонентами типа <font face=Courier><font face=Courier>''SC''</font></font>), тогда:
** Если <font face=Courier>''T''</font> – это класс, тогда <font face=Courier>''T''</font> должен быть <font face=Courier>Object</font>.
** Если <font face=Courier>''T''</font> – это интерфейс, тогда <font face=Courier>''T''</font> должно быть одним из интерфейсов, которые реализует массив (см. JLS §4.10.3).
** Если <font face=Courier>''T''</font> – массив <font face=Courier><font face=Courier>''TC''</font></font>[],  что значит массив с компонентами типа <font face=Courier><font face=Courier>''TC''</font></font>, тогда одно из следующих утверждений должно быть истинным:
*** <font face=Courier><font face=Courier>''TC''</font></font> и <font face=Courier><font face=Courier>''SC''</font></font> принадлежат одному примитивному типу.
*** <font face=Courier><font face=Courier>''TC''</font></font> и <font face=Courier><font face=Courier>''SC''</font></font> ссылочные типы и <font face=Courier><font face=Courier>''SC''</font></font> можно присвоить <font face=Courier><font face=Courier>''TC''</font></font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на класс, массив или интерфейс, может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]).
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''instanceof'' очень похожа на инструкцию ''checkcast''. Они отличаются друг от друга реакцией на <font face=Courier>null</font> (''checkcast'' генерирует исключение, ''instanceof'' записывает код ''результата'' в стек) и влиянием на стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokedynamic'''''
| style="text-align:right;"  | '''''invokedynamic'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Динамически вызывает метод
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''invokedynamic''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|-
| style="vertical-align:top;"|0
|-
| style="vertical-align:top;"|0
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''invokedynamic''= 186 (0xba)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., [''арг1'', [''арг2''...]] →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Каждое использование инструкции ''invokedynamic'' называется ''динамическим узлом вызова''.

Сначала беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула с найденным ''индексом'' должен быть символьной ссылкой на спецификатор узла вызова (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]). Значения третьего и четвёртого операнда должны всегда быть равны нулю.

Спецификатор узла вызова разрешается (см. [[Спецификация виртуальной машины Java#Разрешение спецификатора узла вызова|§5.4.3.6]]) для ''данного конкретного динамического узла вызова'', чтобы получить ссылку типа <font face=Courier>reference</font> на экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font>, ссылку типа <font face=Courier>reference</font> на экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> и набор ссылок типа <font face=Courier>reference</font> на статические аргументы.

Затем, как часть процесса разрешения спецификатора узла вызова, вызывается инициализирующий метод. Как будто была бы вызвана инструкция ''invokevirtual'' с указанием ей ''индекса'' элемента константного пула, являющегося символьной ссылкой на метод, (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]) со следующими свойствами:

* Имя метода есть <font face=Courier>invoke</font>;
* Возвращаемый тип в дескрипторе метода есть <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>CallSite</font>;
* Типы параметров в дескрипторе метода унаследованы от элементов в стеке операндов следующим образом:
* Первыми четырьмя типами параметров являются <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font>,
: <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandles</font>.<font face=Courier>Lookup</font>,
: <font face=Courier>String</font> и
: <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> именно в таком порядке.
* Если спецификатор узла вызова имеет статические аргументы, тогда для каждого аргумента добавляется в дескриптор метода соответствующий тип. Добавление происходит в том порядке, в котором аргументы были записаны в стек операндов. Типами параметров могут быть <font face=Courier>Class</font>,  <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font>, <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font>,  <font face=Courier>String</font>,  <font face=Courier>int</font>,  <font face=Courier>long</font>,  <font face=Courier>float</font> или <font face=Courier>double</font>.
* Символьная ссылка на класс, которому принадлежит вызываемый метод, равна <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font>.

При этом как будто следующие элементы были бы записаны в стек операндов в указанном порядке:

* ссылка (тип <font face=Courier>reference</font>) на объект <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font> инициализирующего метода;
* ссылка (тип <font face=Courier>reference</font>) на объект <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandles</font>.<font face=Courier>Lookup</font> класса, в котором происходит динамический вызов узла.
* ссылка (тип <font face=Courier>reference</font>) на строку (тип <font face=Courier>String</font>), содержащую имя метода в спецификаторе узла вызова;
* ссылка (тип <font face=Courier>reference</font>) на объект <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> полученный для дескриптора метода в спецификаторе узла вызова;
* ссылки (тип <font face=Courier>reference</font>) на классы, типы методов, обработчики методов и строковые литералы, обозначенные как статические аргументы в спецификаторе узла вызова, а также числовые значения (см. [[Спецификация виртуальной машины Java#Целочисленные типы и их значения|§2.3.1]],  [[Спецификация виртуальной машины Java#Типы данных с плавающей точкой, множества значений и значения|§2.3.2]]) также обозначенные как статические аргументы в спецификаторе узла вызова в том порядке, в котором они там заданы.  Примечание: для примитивных типов автоупаковка и распаковка не происходят.

До тех пор пока инициализирующий метод может быть корректно вызван метода <font face=Courier>invoke</font>, его дескриптор произволен. Например, первый параметр мог бы быть <font face=Courier>Object</font> вместо <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandles</font>.<font face=Courier>Lookup</font>, а возвращаемый тип также мог бы быть <font face=Courier>Object</font> вместо <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>CallSite</font>.

Если инициализирующий метод имеет переменное число параметров, тогда некоторые (или все) аргументы в стеке операндов могут быть собраны в массив параметров соответствующего типа.

Вызов инициализирующего метода происходит в потоке, который выполняет разрешение символьной ссылки спецификаторы узла вызова. Если таких потоков несколько, инициализирующий метод может быть вызван в нескольких потоках одновременно. Поэтому инициализирующие методы, обращающиеся к глобальным данным приложения, должны содержать защиту от такой ошибки многопоточной работы приложения как состояние гонок (конкуренция за ресурсы).

Результат, возвращаемый инициализирующим методом должен быть ссылкой (тип <font face=Courier>reference</font>) на объект класса <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>CallSite</font> или его наследника. Этот объект называется объектом узла вызова. Эта ссылка считывается из стека операндов также как и при работе инструкции ''invokevirtual''.

Если несколько потоков одновременно исполняют инициализирующий метод для одного и того же динамического узла вызова, то виртуальная машина Java должна определить один объект узла вызова и сделать его видимым всем потокам. Допустимо продолжать выполнение остальных инициализирующих методов, но результаты их выполнения не будут использованы, и выполнение потока динамического узла вызова продолжится с выбранным ранее объектом узла вызова.

Объект узла вызова также является дескриптором (экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font>), который должен быть семантически равным дескриптору метода в спецификаторе узла вызова.

Результатом успешного разрешения спецификатора узла вызова является  объект узла вызова, связанный перманентно с динамическим узлом вызова.

Затем вызывается обработчик метода, описанного в целевом объекте узла вызова. Вызов происходит эквивалентно вызову инструкции ''invokevirtual'' с указанием ей ''индекса'' элемента константного пула, являющегося символьной ссылкой на метод, (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]) со следующими свойствами:

* Имя метода <font face=Courier>invokeExact</font>;
* Дескриптором метода является дескриптор в спецификаторе узла вызова;
* Символьная ссылка на класс, которому принадлежит вызываемый метод, равна <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font>.

Содержимое стека операндов может быть интерпретировано следующим образом: считается, что в стеке есть ссылка (типа <font face=Courier>reference</font>) на целевой объект узла вызова, за которым следуют значения аргументов, число, тип и порядок которых должны соответствовать дескриптору метода в спецификаторе узла вызова.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Если при разрешении символьной ссылки на спецификатор узла вызова возникает исключение <font face=Courier>''E''</font>, инструкция ''invokedynamic'' генерирует <font face=Courier>BootstrapMethodError</font>, оборачивая в него исходное исключение.

Если же при вызове инициализирующего метода он завершается аварийно ([[Спецификация виртуальной машины Java#Аварийное завершение вызова метода|§2.6.5]]) из-за возникновения исключения <font face=Courier>''E''</font>, ''invokedynamic'' также выбрасывает <font face=Courier>BootstrapMethodError</font>, оборачивая в него исходное исключение. (Это может произойти, если инициализирующий метод имеет неверное количество параметров, несовпадающие типы параметров или тип возвращаемого значения. В этом случае <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font>.<font face=Courier>invoke</font> генерирует исключение <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>WrongMethodTypeException</font>.)

Если результат вызова инициализирующего метода не есть ссылка типа <font face=Courier>reference</font> на экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>CallSite</font>, то инструкция ''invokedynamic'' генерирует <font face=Courier>BootstrapMethodError</font>.

Если тип дескриптора объекта для целевого узла вызова не равен семантически дескриптору метода в спецификаторе узла вызова, то ''invokedynamic'' генерирует <font face=Courier>BootstrapMethodError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если разрешение спецификатора узла вызова успешно завершено  для данного динамического узла вызова, то это подразумевает, что имеется не нулевая ссылка на экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>CallSite</font> связанная с динамическим узлом вызова.

Поэтому элемент стека операндов, который соответствует ссылке на объект целевого узла вызова, не может иметь ''значение'' <font face=Courier>null</font>. Точно также подразумевается, что дескриптор метода в спецификаторе узла вызова семантически равен дескриптору обработчику вызываемого метода (также как при выполнении инструкции ''invokevirtual'').

Эти допущения означают, что инструкция ''invokedynamic'', связанная с объектом узла вызова, никогда не генерирует <font face=Courier>NullPointerException</font> или <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>WrongMethodTypeException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokeinterface'''''
| style="text-align:right;"  | '''''invokeinterface'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вызывает метод интерфейса
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''invokeinterface''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|-
| style="vertical-align:top;"|''счётчик''
|-
| style="vertical-align:top;"|0
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''invokeinterface''= 185 (0xb9)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...,''ссылка на объект'', [''арг1'', [''арг2''...]] →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула с найденным ''индексом'' должен быть символьной ссылкой на метод интерфейса (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]). Этот элемент содержит имя и дескриптор метода (см. [[Спецификация виртуальной машины Java#Дескрипторы методов|§4.3.3]]) а также символьную ссылку на интерфейс, в котором данный метод может быть найден. Указанный интерфейсный метод разрешается (см. [[Спецификация виртуальной машины Java#Разрешение метода интерфейса|§5.4.3.4]]). Разрешенный интерфейсный метод не должен быть методом инициализации экземпляра (конструктором, см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]), а также не должен быть методом инициализации класса или интерфейса (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]).

''Счётчик'' - это беззнаковый байт, не равный нулю. ''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font>, и должна предшествовать в стеке операндов значениям аргументов, причём их число, тип и порядок следования должны соответствовать числу, типу и порядку в дескрипторе разрешённого метода. Значение четвёртого байта операндов должно быть всегда равно нулю.

Пусть <font face=Courier>''C''</font> - это класс, на экземпляр которого ссылается ''ссылка на объект''. Фактический метод для вызова выбирается по следующей процедуре:

* Если <font face=Courier>''C''</font> содержит объявления метода с таким же именем и дескриптором, что и разрешенный ранее интерфейсный метод, то метод для вызова найден и процедура поиска прекращается.
* Если <font face=Courier>''C''</font> имеет предка то, такая же процедура выполняется рекурсивно для всех предков класса до тех пор пока имя метода и дескриптор не совпадут с именем и дескриптором разрешённого ранее интерфейсного метода. Затем процедура поиска прекращается.
* В противном случае генерируется исключение <font face=Courier>AbstractMethodError</font>.

Если метод объявлен с модификатором <font face=Courier>synchronized</font>, то выполняется захват (или повторный захват) монитора связанного со ссылкой объект (как при выполнении инструкции ''monitorenter'' для текущего потока).

Если метод объявлен без модификатора <font face=Courier>native</font>, то аргументы и ''ссылка на объект'' считываются из стека операндов. Для метода, который подлежит вызову, создаётся новый фрейм в стеке виртуальной машины Java. ''Ссылка на объект'' и значения аргументов записываются в локальные переменные нового фрейма, причём ''ссылка на объект'' записывается в локальную переменную 0, первый аргумент - в локальную переменную 1 (если первый аргумент принадлежит типу <font face=Courier>long</font> или <font face=Courier>double</font>, то он записывается в локальные переменные 1 и 2) и так далее. Все аргументы, принадлежащие типам данных с плавающей точкой, подвергаются серии преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]])  прежде чем будут сохранены в локальных переменных. Созданный фрейм становится текущим и регистр  <font face=Courier>pc</font> виртуальной машины Java устанавливается так, что бы указывать на ''индекс'' первой инструкции вызываемого метода. Выполнение инструкций продолжается с первой инструкции метода.

Если метод объявлен с модификатором <font face=Courier>native</font>, то и платформенно зависимый код, который реализует метод, ещё не был привязан к виртуальной машине Java ([[Спецификация виртуальной машины Java#Связывание платформенно зависимых методов|§5.6]]), то такая привязка происходит. Аргументы и ''ссылка на объект'' считываются из стека операндов и передаются как параметры в код, реализующий метод. Все аргументы, принадлежащие типам данных с плавающей точкой, подвергаются серии преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]])  прежде чем будут переданы в качестве параметров. Затем происходит передача параметров и вызов платформенно зависимого кода. Когда платформенно зависимый метод завершает выполнение:

* Если <font face=Courier>native</font> метод объявлен <font face=Courier>synchronized</font>, то монитор, связанный со ссылкой на объект освобождается как при выполнении инструкции ''monitorexit'' для текущего потока.
* Если <font face=Courier>native</font> метод возвращает значение, то это значение преобразуется из платформенно зависимого формата в тип, с которым объявлен <font face=Courier>native</font> метод. Затем это значение записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Может быть выброшено любое исключение, которое может возникнуть при разрешении символьной ссылки на интерфейсный метод ([[Спецификация виртуальной машины Java#Разрешение метода интерфейса|§5.4.3.4]]).
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' равна <font face=Courier>null</font>, то ''invokeinterface'' генерирует исключение <font face=Courier>NullPointerException</font>.

Если класс, на который ссылается ''ссылка на объект'' не имплементирует интерфейс, то ''invokeinterface''  генерирует <font face=Courier>IncompatibleClassChangeError</font>.

Если нет ни одного метода с заданным именем и дескриптором, то ''invokeinterface'' генерирует <font face=Courier>AbstractMethodError</font>.

Если выбранный метод не является <font face=Courier>public</font>, ''invokeinterface'' генерирует <font face=Courier>IllegalAccessError</font>.

Если выбранный метод объявлен с модификатором <font face=Courier>abstract</font>, ''invokeinterface'' генерирует <font face=Courier>AbstractMethodError</font>.

Если выбранный метод объявлен как <font face=Courier>native</font>  и код, который его имплементирует не может быть найден, то ''invokeinterface'' генерирует <font face=Courier>UnsatisfiedLinkError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Параметр ''счётчик'' инструкции ''invokeinterface'' содержит количество локальных переменных, которые нужно создать для хранения аргументов метода. Причём аргументы с типами <font face=Courier>long</font> и <font face=Courier>double</font> увеличивают ''счётчик'' на две единицы, аргументы всех остальных типов увеличивают ''счётчик'' на единицу. Эта информация также может быть получена из дескриптора выбранного метода. Такое дублирование сохранено по историческим причинам.

Четвёртый (имеющий значение 0) байт резервирует место для дополнительно операнда, который используется в некоторых имплементациях виртуальной машины компании Oracle. В таких имплементациях инструкция ''invokeinterface'' заменяется во время выполнения специальной псевдокомандой. Байт должен быть зарезервирован для обратной совместимости.

Значения n аргументов и ''ссылка на объект'' не взаимно однозначно соответствуют  первым n +1 локальным переменным. Аргументы с типами <font face=Courier>long</font>  и <font face=Courier>double</font> должны быть сохранены в двух локальных переменных с последовательными индексами, поэтому для хранения n аргументов может понадобится более чем n локальных переменных.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokespecial'''''
| style="text-align:right;"  | '''''invokespecial'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вызывает метод экземпляра; используется при вызове методов класса-предка, приватных методов и методов, инициализирующих экземпляр
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''invokespecial''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''invokespecial''= 183 (0xb7)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'', [''арг1'', [''арг2''...]] →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула с найденным ''индексом'' должен быть символьной ссылкой на метод (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]). Этот элемент содержит имя и дескриптор метода (см. [[Спецификация виртуальной машины Java#Дескрипторы методов|§4.3.3]]) а также символьную ссылку на класс, в котором данный метод может быть найден. Указанный метод разрешается (см. [[Спецификация виртуальной машины Java#Разрешение метода интерфейса|§5.4.3.4]]). Если разрешенный метод объявлен с модификатором <font face=Courier>protected</font> (см. [[Спецификация виртуальной машины Java#Методы|§4.6]]) и принадлежит предку текущего класса и при этом в текущем классе он не объявлен, то ''ссылка на объект'' должна ссылаться либо на объект текущий класса либо на объект его наследника.

Если все условия, перечисленные ниже, истинные, то управление передаётся разрешённому методу.

* Для текущего класса установлен флаг <font face=Courier>ACC_SUPER</font> (см. Таблицу 4.1).
* Класс разрешённого метода является предком текущего класса.
* Разрешенный метод не является методом, инициализирующим экземпляр (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]).

Затем происходит поиск метода, который будет в действительности вызван. Пусть <font face=Courier>''C''</font> - это класс-предок, текущего класса. Фактический метод для вызова выбирается по следующей процедуре:

* Если <font face=Courier>''C''</font> содержит объявления метода с таким же именем и дескриптором, что и разрешенный ранее метод, то метод для вызова найден и процедура поиска прекращается.
* Если <font face=Courier>''C''</font> имеет предка то, такая же процедура выполняется рекурсивно для всех предков класса до тех пор пока имя метода и дескриптор не совпадут с именем и дескриптором разрешённого ранее метода. Затем процедура поиска прекращается.
* В противном случае генерируется исключение <font face=Courier>AbstractMethodError</font>.

''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font>. За ней в стеке операндов следуют значения аргументов, причём их число, тип и порядок должны соответствовать числу, типу и порядку в дескрипторе выбранного метода.

Если метод объявлен без модификатора <font face=Courier>native</font>, то аргументы и ''ссылка на объект'' считываются из стека операндов. Для метода, который подлежит вызову, создаётся новый фрейм в стеке виртуальной машины Java. ''Ссылка на объект'' и значения аргументов записываются в локальные переменные нового фрейма, причём ''ссылка на объект'' записывается в локальную переменную 0, первый аргумент - в локальную переменную 1 (если первый аргумент принадлежит типу <font face=Courier>long</font> или <font face=Courier>double</font>, то он записывается в локальные переменные 1 и 2) и так далее. Все аргументы, принадлежащие типам данных с плавающей точкой, подвергаются серии преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]])  прежде чем будут сохранены в локальных переменных. Созданный фрейм становится текущим и регистр  <font face=Courier>pc</font> виртуальной машины Java устанавливается так, что бы указывать на ''индекс'' первой инструкции вызываемого метода. Выполнение инструкций продолжается с первой инструкции метода.

Если метод объявлен с модификатором <font face=Courier>native</font>, то и платформенно зависимый код, который реализует метод, ещё не был привязан к виртуальной машине Java ([[Спецификация виртуальной машины Java#Связывание платформенно зависимых методов|§5.6]]), то такая привязка происходит. Аргументы и ''ссылка на объект'' считываются из стека операндов и передаются как параметры в код, реализующий метод. Все аргументы, принадлежащие типам данных с плавающей точкой, подвергаются серии преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]])  прежде чем будут переданы в качестве параметров. Затем происходит передача параметров и вызов платформенно зависимого кода. Когда платформенно зависимый метод завершает выполнение:
* Если <font face=Courier>native</font> метод объявлен <font face=Courier>synchronized</font>, то монитор, связанный со ссылкой на объект освобождается как при выполнении инструкции ''monitorexit'' для текущего потока.
* Если <font face=Courier>native</font> метод возвращает значение, то это значение преобразуется из платформенно зависимого формата в тип, с которым объявлен <font face=Courier>native</font> метод. Затем это значение записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Может быть выброшено любое исключение, которое может возникнуть при разрешении символьной ссылки на метод ([[Спецификация виртуальной машины Java#Разрешение метода|§5.4.3.3]]).

Если разрешенный метод является инициализирующим методом экземпляра и класс, в котором он объявлен не является тем классом, на который (после разрешения метода) ссылается инструкция ''invokespecial'', то генерируется исключение <font face=Courier>NoSuchMethodError</font>.

Если разрешенный метод принадлежит классу (<font face=Courier>static</font>) , то ''invokespecial'' генерирует исключение <font face=Courier>IncompatibleClassChangeError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' равна <font face=Courier>null</font>, то ''invokespecial'' генерирует исключение <font face=Courier>NullPointerException</font>.

Если нет ни одного метода с заданным именем и дескриптором, то ''invokespecial'' генерирует <font face=Courier>AbstractMethodError</font>.

Если выбранный метод объявлен с модификатором <font face=Courier>abstract</font>, ''invokespecial'' генерирует <font face=Courier>AbstractMethodError</font>.

Если выбранный метод объявлен как <font face=Courier>native</font>  и код, который его имплементирует не может быть найден, то ''invokespecial'' генерирует <font face=Courier>UnsatisfiedLinkError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Разница между инструкциями ''invokespecial'' и ''invokevirtual'' в том, что ''invokevirtual'' вызывает метод, основываясь на классе объекта. Инструкция ''invokespecial'' используется для вызова методов инициализирующих экземпляр (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]) а также для методов с модификатором <font face=Courier>private</font> и методов класса предка.

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. В версиях JDK до 1.0.2 инструкция ''invokespecial'' называлась <font face=Courier>invokenonvirtual</font>.</span>
|}
<br>
Значения n аргументов и ''ссылка на объект'' не взаимно однозначно соответствуют  первым n +1 локальным переменным. Аргументы с типами <font face=Courier>long</font>  и <font face=Courier>double</font> должны быть сохранены в двух локальных переменных с последовательными индексами, поэтому для хранения n аргументов может понадобится более чем n локальных переменных.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokestatic'''''
| style="text-align:right;"  | '''''invokestatic'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вызывает метод класса (<font face=Courier>static</font>)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''invokestatic''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''invokestatic''= 184 (0xb8)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., [''арг1'', [''арг2''...]]→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула с найденным ''индексом'' должен быть символьной ссылкой на метод интерфейса (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]). Этот элемент содержит имя и дескриптор метода (см. [[Спецификация виртуальной машины Java#Дескрипторы методов|§4.3.3]]) а также символьную ссылку на класс, в котором данный метод может быть найден. Указанный метод разрешается (см. [[Спецификация виртуальной машины Java#Разрешение метода интерфейса|§5.4.3.4]]). Разрешенный метод не должен быть методом инициализации экземпляра (конструктором, см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]), а также не должен быть методом инициализации класса или интерфейса (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]). Он должен быть статическим и поэтому не может быть абстрактным.

При успешном разрешении метода класс, содержащий объявленный метод инициализируется (см. [[Спецификация виртуальной машины Java#Инициализация|§5.5]]), если до этого он не был инициализирован.

Стек операндов должен содержать значения аргументов, причём их число, тип и порядок должны соответствовать числу, типу и порядку указанному в дескрипторе разрешённого метода.

Если метод объявлен с модификатором <font face=Courier>synchronized</font>, то монитор объекта класса <font face=Courier>Class</font> захватывается впервые (или повторно) как при выполнении инструкции ''monitorenter'' для текущего потока.

Если метод объявлен без модификатора <font face=Courier>native</font>, то аргументы и ссылка на объект считываются из стека операндов. Для метода, который подлежит вызову, создаётся новый фрейм в стеке виртуальной машины Java. Ссылка на объект и значения аргументов записываются в локальные переменные нового фрейма, причём ссылка на объект записывается в локальную переменную 0, первый аргумент - в локальную переменную 1 (если первый аргумент принадлежит типу <font face=Courier>long</font> или <font face=Courier>double</font>, то он записывается в локальные переменные 1 и 2) и так далее. Все аргументы, принадлежащие типам данных с плавающей точкой, подвергаются серии преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]])  прежде чем будут сохранены в локальных переменных. Созданный фрейм становится текущим и регистр  <font face=Courier>pc</font> виртуальной машины Java устанавливается так, что бы указывать на ''индекс'' первой инструкции вызываемого метода. Выполнение инструкций продолжается с первой инструкции метода.

Если метод объявлен с модификатором <font face=Courier>native</font>, то и платформенно зависимый код, который реализует метод, ещё не был привязан к виртуальной машине Java ([[Спецификация виртуальной машины Java#Связывание платформенно зависимых методов|§5.6]]), то такая привязка происходит. Аргументы и ссылка на объект считываются из стека операндов и передаются как параметры в код, реализующий метод. Все аргументы, принадлежащие типам данных с плавающей точкой, подвергаются серии преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]])  прежде чем будут переданы в качестве параметров. Затем происходит передача параметров и вызов платформенно зависимого кода. Когда платформенно зависимый метод завершает выполнение:
* Если <font face=Courier>native</font> метод объявлен <font face=Courier>synchronized</font>, то монитор, связанный со ссылкой на объект освобождается как при выполнении инструкции ''monitorexit'' для текущего потока.
* Если <font face=Courier>native</font> метод возвращает значение, то это значение преобразуется из платформенно зависимого формата в тип, с которым объявлен <font face=Courier>native</font> метод. Затем это значение записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Может быть выброшено любое исключение, которое может возникнуть при разрешении символьной ссылки на метод ([[Спецификация виртуальной машины Java#Разрешение метода|§5.4.3.3]]).

Если разрешенный метод принадлежит объекту, то ''invokestatic'' генерирует исключение <font face=Courier>IncompatibleClassChangeError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если выполнение ''invokestatic'' приводит к инициализации класса, то может быть выброшена ошибка, более детально описанная в [[Спецификация виртуальной машины Java#Инициализация|§5.5]].

Если выбранный метод объявлен как <font face=Courier>native</font>  и код, который его имплементирует не может быть найден, то ''invokestatic'' генерирует <font face=Courier>UnsatisfiedLinkError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Значения n аргументов не взаимно однозначно соответствуют  первым n  локальным переменным. Аргументы с типами <font face=Courier>long</font>  и <font face=Courier>double</font> должны быть сохранены в двух локальных переменных с последовательными индексами, поэтому для хранения n аргументов может понадобится более чем n локальных переменных.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''invokevirtual'''''
| style="text-align:right;"  | '''''invokevirtual'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вызывает метод экземпляра; диспетчеризация основана на классах
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''invokevirtual''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''invokevirtual''= 182 (0xb6)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'', [''арг1'', [''арг2''...]] →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула с найденным ''индексом'' должен быть символьной ссылкой на метод интерфейса (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]). Этот элемент содержит имя и дескриптор метода (см. [[Спецификация виртуальной машины Java#Дескрипторы методов|§4.3.3]]) а также символьную ссылку на класс, в котором данный метод может быть найден. Указанный метод разрешается (см. [[Спецификация виртуальной машины Java#Разрешение метода интерфейса|§5.4.3.4]]). Разрешенный метод не должен быть методом инициализации экземпляра (конструктором, см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]), а также не должен быть методом инициализации класса или интерфейса (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]). Если разрешенный метод объявлен с модификатором <font face=Courier>protected</font> (см. [[Спецификация виртуальной машины Java#Методы|§4.6]]) и принадлежит предку текущего класса и при этом в текущем классе он не объявлен, то ''ссылка на объект'' должна ссылаться либо на объект текущий класса либо на объект его наследника.

''Если разрешенный метод не является сигнатурно полиморфным'' (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]) тогда выполнение инструкции ''invokevirtual'' продолжается следующим образом.

Пусть <font face=Courier>''C''</font> - это класс, на экземпляр которого ссылается ''ссылка на объект''. Фактический метод для вызова выбирается по следующей процедуре:

* Если <font face=Courier>''C''</font> содержит объявления метода <font face=Courier>''m''</font>, который замещает  разрешенный ранее метод ([[Спецификация виртуальной машины Java#Замещение методов|§5.4.5]]), то метод для вызова найден (это <font face=Courier>''m''</font>) и процедура поиска прекращается.
* Если <font face=Courier>''C''</font> имеет предка то, такая же процедура выполняется рекурсивно для всех предков класса до тех пор пока имя метода и дескриптор не совпадут с именем и дескриптором разрешённого ранее метода. Затем процедура поиска прекращается.
* В противном случае генерируется исключение <font face=Courier>AbstractMethodError</font>.

''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font>. За ней в стеке операндов следуют значения аргументов, причём их число, тип и порядок должны соответствовать числу, типу и порядку в дескрипторе выбранного метода.

Если метод объявлен без модификатора <font face=Courier>native</font>, то аргументы и ''ссылка на объект'' считываются из стека операндов. Для метода, который подлежит вызову, создаётся новый фрейм в стеке виртуальной машины Java. ''Ссылка на объект'' и значения аргументов записываются в локальные переменные нового фрейма, причём ''ссылка на объект'' записывается в локальную переменную 0, первый аргумент - в локальную переменную 1 (если первый аргумент принадлежит типу <font face=Courier>long</font> или <font face=Courier>double</font>, то он записывается в локальные переменные 1 и 2) и так далее. Все аргументы, принадлежащие типам данных с плавающей точкой, подвергаются серии преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]])  прежде чем будут сохранены в локальных переменных. Созданный фрейм становится текущим и регистр  <font face=Courier>pc</font> виртуальной машины Java устанавливается так, что бы указывать на ''индекс'' первой инструкции вызываемого метода. Выполнение инструкций продолжается с первой инструкции метода.

Если метод объявлен с модификатором <font face=Courier>native</font>, то и платформенно зависимый код, который реализует метод, ещё не был привязан к виртуальной машине Java ([[Спецификация виртуальной машины Java#Связывание платформенно зависимых методов|§5.6]]), то такая привязка происходит. Аргументы и ''ссылка на объект'' считываются из стека операндов и передаются как параметры в код, реализующий метод. Все аргументы, принадлежащие типам данных с плавающей точкой, подвергаются серии преобразований (см. [[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]])  прежде чем будут переданы в качестве параметров. Затем происходит передача параметров и вызов платформенно зависимого кода. Когда платформенно зависимый метод завершает выполнение:
* Если <font face=Courier>native</font> метод объявлен <font face=Courier>synchronized</font>, то монитор, связанный со ссылкой на объект освобождается как при выполнении инструкции ''monitorexit'' для текущего потока.
* Если <font face=Courier>native</font> метод возвращает значение, то это значение преобразуется из платформенно зависимого формата в тип, с которым объявлен <font face=Courier>native</font> метод. Затем это значение записывается в стек операндов.

''Если разрешенный метод  является сигнатурно полиморфным'' (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]) тогда выполнение инструкции ''invokevirtual'' продолжается следующим образом.

Сначала формируется ссылка  (тип <font face=Courier>reference</font>) на экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> как при разрешении символьной ссылки на тип метода (см. [[Спецификация виртуальной машины Java#Разрешение типов методов и обработчиков методов|§5.4.3.5]]) с такими же параметрами и возвращаемым типом как и в дескрипторе метода, полученного по ссылке инструкции ''invokevirtual''.

* Если названный выше метод это <font face=Courier>invokeExact</font>, то экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> должен быть семантически равным дескриптору обработчика метода объекта, на который ссылается ''ссылка на объект''. ''Будет вызван обработчик метода по ссылке на объект''.
* Если названный выше метод это <font face=Courier>invoke</font> и экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> семантически равен дескриптору обработчика метода объекта, на который ссылается ''ссылка на объект'', тогда ''будет вызван обработчик метода по ссылке на объект''.
* Если названный выше метод это <font face=Courier>invoke</font> и экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> семантически не равен дескриптору обработчика метода объекта, на который ссылается ''ссылка на объект'', тогда виртуальная машина Java пытается преобразовать дескриптор типов полученного обработчика метода, как при вызове <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font>.<font face=Courier>asType</font>, чтобы получить точный обработчик метода <font face=Courier>''m''</font>. ''Будет вызван обработчик метода'' <font face=Courier>''m''</font>.

В стеке операндов за ссылкой на объект  должны следовать значения аргументов прим их число, тип и порядок следования должны соответствовать числу, типу и порядку следования описанному в дескрипторе типа вызываемого метода. (Дескриптор типа должен соответствовать дескриптору метода (с учётом типа обработчика метода), как указано в [[Спецификация виртуальной машины Java#Разрешение типов методов и обработчиков методов|§5.4.3.5]].)

Далее, если обработчик метода, который необходимо вызвать, реализован в виде байт-кода, виртуальная машина Java выполняет обработчик метода с учётом типа обработчика метода. Если тип обработчика метода есть 5 (<font face=Courier>REF_invokeVirtual</font>), 6 (<font face=Courier>REF_invokeStatic</font>), 7 (<font face=Courier>REF_invokeSpecial</font>), 8 (<font face=Courier>REF_newInvokeSpecial</font>) или 9 (<font face=Courier>REF_invokeInterface</font>), то создаётся фрейм и назначается текущим для выполнения ''соответствующего байт кода''. Когда метод, выполняющий байт код завершается (нормально или аварийно), то ''фрейм вызвавшего его метода'' считается фреймом, содержащим инструкцию ''invokevirtual''.

<br>
{| width="90%" border="0" style="border-collapse:collapse; margin-left: 46px;" |
|
<span style="font-size:88%">Примечание. Фрейм, в котором выполняется непосредственно байт код, считается невидимым.</span>
|}
<br>
Если обработчик метода, который необходимо вызвать, не реализован в виде байт-кода, виртуальная машина Java выполняет действия по запуску платформенно зависимых методов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Может быть выброшено любое исключение, которое может возникнуть при разрешении символьной ссылки на метод ([[Спецификация виртуальной машины Java#Разрешение метода|§5.4.3.3]]).

Если разрешенный метод является статическим, то ''invokevirtual'' генерирует исключение <font face=Courier>IncompatibleClassChangeError</font>.

Если разрешенный метод является сигнатурно полиморфным, то во время разрешения типа метода, полученного из дескриптора по символьной ссылке на метод, могут быть сгенерированы любые исключения, связанные с разрешением типов (см. [[Спецификация виртуальной машины Java#Разрешение типов методов и обработчиков методов|§5.4.3.5]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' есть <font face=Courier>null</font>, то инструкция  ''invokevirtual'' генерирует <font face=Courier>NullPointerException</font>.

Если разрешенный метод не является сигнатурно полиморфным:

* Если не был найден метод, соответствующий выбранному имени и дескриптору, то ''invokevirtual'' генерирует <font face=Courier>AbstractMethodError</font>.
* Если выбранный метод - абстрактный, то ''invokevirtual'' генерирует <font face=Courier>AbstractMethodError</font>.
* Если выбранный метод объявлен как <font face=Courier>native</font>  и код, который его имплементирует не может быть найден, то ''invokevirtual'' генерирует <font face=Courier>UnsatisfiedLinkError</font>.

Если разрешенный метод  является сигнатурно полиморфным:
* Если имя метода есть <font face=Courier>invokeExact</font> и полученный экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> не является семантически равным дескриптору типа метода обработчика, то ''invokevirtual'' генерирует <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>WrongMethodTypeException</font>.
* Если имя метода есть <font face=Courier>invoke</font> и полученный экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> не является допустимым аргументом для <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font>.<font face=Courier>asType</font> то ''invokevirtual'' генерирует <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>WrongMethodTypeException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Значения n аргументов и ''ссылка на объект'' не взаимно однозначно соответствуют  первым n +1 локальным переменным. Аргументы с типами <font face=Courier>long</font>  и <font face=Courier>double</font> должны быть сохранены в двух локальных переменных с последовательными индексами, поэтому для хранения n аргументов может понадобится более чем n локальных переменных.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ior'''''
| style="text-align:right;"  | '''''ior'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Логическое «или» над значениями типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ior''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ior''= 128 (0x80)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>int</font> и представляет собой побитовое "ИЛИ" над ''значением1'' и ''значением2''. Затем ''результат'' записывается в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''irem'''''
| style="text-align:right;"  | '''''irem'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Остаток от деления значений типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''irem''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''irem''= 112 (0x70)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>int</font> и представляет собой ''значение1'' - (''значение1'' / ''значение2'') * ''значение2''. Затем ''результат'' записывается в стек операндов.

''Результат'' инструкции ''irem'' это величина такая, что (<font face=Courier>''a''</font>/<font face=Courier>''b''</font>)*<font face=Courier>''b''</font> + (<font face=Courier>''a''</font>%<font face=Courier>''b''</font>) равна <font face=Courier>''a''</font>.  Это равенство справедливо даже в специальных случаях, когда делимое есть отрицательное целое, максимальное по модулю, а делитель есть -1 (при этом остаток есть 0). Из равенства следует также что ''результат'' операции отрицателен, если делимое отрицательно и положителен, если делимое положительно. Более того, ''результат'' всегда меньше чем делитель.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если делитель равен нулю, то инструкция ''irem'' генерирует <font face=Courier>ArithmeticException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ireturn'''''
| style="text-align:right;"  | '''''ireturn'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Возвращает значение типа <font face=Courier>int</font>  из метода
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ireturn''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ireturn''= 172 (0xac)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

[пусто]
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Текущий метод должен возвращать величину типа <font face=Courier>boolean</font>, <font face=Courier>byte</font>, <font face=Courier>short</font>, <font face=Courier>char</font> или <font face=Courier>int</font>. ''Значение'' должно принадлежать <font face=Courier>int</font>. Если текущий метод объявлен с ключевым словом <font face=Courier>synchronized</font>, то при входе в метод монитор захватывается первоначально (либо повторно, если уже был захвачен до того), а при выходе освобождается, как при выполнении инструкции ''monitorexit'' для текущего потока. Если в ходе выполнения метода не было исключений, ''значение'' считывается из стека операндов текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]) Затем  ''значение'' записывается в стек операндов фрейма, принадлежащего вызывающему методу. Все остальные ''значения'' стека операндов текущего фрейма теряются.

Затем интерпретатор передаёт управление вызывающему методу, делая текущим соответствующий фрейм.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если реализация виртуальной машины Java не поддерживает правила структурных блокировок описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], тогда если текущий метод объявлен как  <font face=Courier>synchronized</font> и текущий поток не является владельцем монитора, захваченного при входе в метод, то при вызове ''ireturn'' будет выброшено исключение <font face=Courier>IllegalMonitorStateException</font>. Это может произойти, если <font face=Courier>synchronized</font>-метод содержит инструкцию ''monitorexit'', а инструкция ''monitorenter'' по объекту синхронизации отсутствует.

С другой стороны, если реализация виртуальной машины Java  поддерживает правила структурных блокировок описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], и во время выполнения текущего метода нарушено первое из этих правил, то при вызове ''ireturn'' будет выброшено исключение <font face=Courier>IllegalMonitorStateException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ishl'''''
| style="text-align:right;"  | '''''ishl'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Сдвиг влево значения типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ishl''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ishl''= 120 (0x78)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>int</font> и представляет собой ''значение1'' сдвинутое влево на s позиций, где s – это младшие 5 битов ''значения2''. Затем ''результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Операция сдвига влево эквивалентна (даже в случае переполнения) умножению исходного ''значения'' на 2 в степени s. Количество бит, на которое нужно сдвинуть ''значение'', всегда находится в пределах от 0 до 31 включительно, как если бы до сдвига над ''значением2'' было выполнено логическое «И» с маской 0x1f.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ishr'''''
| style="text-align:right;"  | '''''ishr'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Арифметический сдвиг вправо значения типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ishr''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ishr''= 122 (0x7a)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>int</font> и представляет собой ''значение1'' сдвинутое вправо на s позиций, где s – это младшие 5 битов ''значения2''. Затем ''результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Операция сдвига вправо возвращает ''значение'' равное  ⌊''значение1''/ 2s⌋, где s - это ''значение2'' & 0x1f. Если ''значение1'' не отрицательно, то сдвиг эквивалентен целочисленному делению ''значения1'' на 2 в степени s с отбрасыванием дробной части ''результата''. Количество бит, на которое нужно сдвинуть ''значение'', всегда находится в пределах от 0 до 31 включительно, как если бы до сдвига над ''значением2'' было выполнено логическое «И» с маской 0x1f.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''istore'''''
| style="text-align:right;"  | '''''istore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает из стека значение типа <font face=Courier>int</font> и записывает в локальную переменную
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''istore''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''istore''= 54 (0x36)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом. ''Индекс'' должен принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение''  на вершине стека операндов должно принадлежать типу <font face=Courier>int</font>. Оно считывается из стека операндов,  затем в локальную переменную с индексом ''индекс'' записывается ''значение''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''istore'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый ''индекс'' локальной переменной.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''istore_<n>'''''
| style="text-align:right;"  | '''''istore_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает из стека значение типа <font face=Courier>int</font> и записывает в локальную переменную
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''istore_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''istore_0''= 59 (0x3b)

''istore_1''= 60 (0x3c)

''istore_2''= 61 (0x3d)

''istore_3''= 62 (0x3e)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|<n>должно принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение''  на вершине стека операндов должно принадлежать типу <font face=Courier>int</font>. Оно считывается из стека операндов, затем в локальную переменную с индексом <n>записывается ''значение''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из инструкции ''istore_<n>'' выполняет то же, что и ''istore'' с явным индексом <n> за исключением того, что операнд <n> задан не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''isub'''''
| style="text-align:right;"  | '''''isub'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вычитает значения типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''isub''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''isub''= 100 (0x64)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются с вершины стек операндов. ''Результат'' типа <font face=Courier>int</font>  есть  ''значение1'' - ''значение2''. ''Результат'' записывается в стек операндов.

Для целочисленного вычитания выражение <font face=Courier>''a''</font>-<font face=Courier>''b''</font> дает такой же ''результат'', что и <font face=Courier>''a''</font>+(-<font face=Courier>''b''</font>). Для значений типа <font face=Courier>int</font> вычитание из нуля есть то же самое, что и отрицание числа.

''Результат'' вычитания - это младшие 32 бита ''результата'' точного вычитания, представленные в двоичном дополнительном коде. Если происходит переполнение, то знак ''результата'' может отличаться от знака  математической разности двух значений.

Не смотря на то, что при выполнении инструкции ''isub'' может произойти переполнение, инструкция ''isub'' никогда не приводит к исключению времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''iushr'''''
| style="text-align:right;"  | '''''iushr'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Логический сдвиг вправо значения типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''iushr''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''iushr''= 124 (0x7c)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>int</font> и представляет собой ''значение1'' сдвинутое вправо на s позиций с заполнением нулями освободившихся позиций, где s – это младшие 5 битов ''значения2''. Затем ''результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Если ''значение1'' положительно и s равно ''значение2'' & 0x1f, то ''результат'' сдвига равен ''значение1'' >> s; если ''значение1'' отрицательно, то ''результат'' равен выражению (''значение1'' >> s) + (2 <<~s). Добавление слагаемого (2 <<~s) эквивалентно тому, что знаковый бит при сдвиге будет заменён нулём. Количество бит, на которое нужно сдвинуть ''значение'', всегда находится в пределах от 0 до 31 включительно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ixor'''''
| style="text-align:right;"  | '''''ixor'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Исключающее «или» над значениями типа <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ixor''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ixor''= 130 (0x82)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>int</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>int</font> и представляет собой ''результат'' операции «исключающее ИЛИ» над ''значением1'' и ''значением2''. Затем ''результат'' записывается в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''jsr'''''
| style="text-align:right;"  | '''''jsr'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вызов подпрограммы
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''jsr''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''jsr''= 168 (0xa8)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''адрес''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Адрес'' перехода, который следует непосредственно за инструкцией ''jsr'', записывается в стек операндов как значение типа <font face=Courier>returnAddress</font>. Беззнаковые ''байт_адреса1'' и ''байт_адреса2'' используются для построения знакового 16-ти битового смещения, которое вычисляется следующим образом: (''байт_адреса1'' << 8) <nowiki>|</nowiki> ''байт_адреса2''. Затем выполнение инструкций продолжается со смещения, вычисленного ранее относительно инструкции ''jsr''. Целевой ''адрес'' перехода должен быть в пределах метода, содержащего инструкцию ''jsr''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Обратите внимание, что ''jsr'' записывает ''адрес'' в стек операндов, а инструкция ''ret'' берет его из локальной переменной. Эта асимметрия сделана сознательно.

В реализации компилятора виртуальной машины Java от компании Oracle до Java SE 6 инструкция ''jsr'' использовалась совместно с инструкцией ''ret'' в блоке <font face=Courier>finally</font> (см. [[Спецификация виртуальной машины Java#Компиляция инструкции finally|§3.13]], [[Спецификация виртуальной машины Java#Исключения и блок finally|§4.10.2.5]]).
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''jsr_w'''''
| style="text-align:right;"  | '''''jsr_w'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вызов подпрограммы (расширенный индекс)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''jsr_w''
|-
| style="vertical-align:top;"|''байт_адреса1''
|-
| style="vertical-align:top;"|''байт_адреса2''
|-
| style="vertical-align:top;"|''байт_адреса3''
|-
| style="vertical-align:top;"|''байт_адреса4''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''jsr_w''= 201 (0xc9)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''адрес''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Адрес'' перехода, который следует непосредственно за инструкцией ''jsr_w'', записывается в стек операндов как значение типа <font face=Courier>returnAddress</font>. Беззнаковые ''байт_адреса1'', ''байт_адреса2'', ''байт_адреса3'' и ''байт_адреса4'' используются для построения 32-битового знакового смещения перехода (''байт_адреса1'' << 24) <nowiki>|</nowiki> (''байт_адреса2'' << 16) (''байт_адреса3'' << 8) <nowiki>|</nowiki> ''байт_адреса4''. Затем выполнение инструкций продолжается со смещения, вычисленного ранее относительно инструкции ''jsr_w''. Целевой ''адрес'' перехода должен быть в пределах метода, содержащего инструкцию ''jsr_w''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Обратите внимание, что ''jsr_w'' записывает ''адрес'' в стек операндов, а инструкция ''ret'' берет его из локальной переменной. Эта асимметрия сделана сознательно.

В реализации компилятора виртуальной машины Java от компании Oracle до Java SE 6 инструкция ''jsr_w'' использовалась совместно с инструкцией ''ret'' в блоке <font face=Courier>finally</font> (см. [[Спецификация виртуальной машины Java#Компиляция инструкции finally|§3.13]], [[Спецификация виртуальной машины Java#Исключения и блок finally|§4.10.2.5]]).

Хотя инструкция ''jsr_w'' принимает на вход 4-х байтовое смещение, ограничивающим фактором для перехода является также размер метода, равный 65535 байтам (см. [[Спецификация виртуальной машины Java#Ограничения виртуальной машины Java|§4.11]]). Это ограничение может быть снято в последующих версиях виртуальной Java машины.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2d'''''
| style="text-align:right;"  | '''''l2d'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>long</font> к типу <font face=Courier>double</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''l2d''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''l2d''= 138 (0x8a)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>long</font>. Оно считывается с вершины стека операндов и преобразуется к результату типа  <font face=Courier>double</font>, согласно правилам округления к ближайшему стандарта IEEE 754. ''Результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''l2d'' выполняет расширяющее преобразование примитивных типов (см. JLS §5.1.2), что может привести к потере точности, поскольку мантисса числа типа <font face=Courier>double</font> имеет только 53 значащих бита.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2f'''''
| style="text-align:right;"  | '''''l2f'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>long</font> к типу <font face=Courier>float</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''l2f''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''l2f''= 137 (0x89)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>long</font>. Оно считывается с вершины стека операндов и преобразуется к результату типа  <font face=Courier>float</font>, согласно правилам округления к ближайшему стандарта IEEE 754. ''Результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''l2f'' выполняет расширяющее преобразование примитивных типов (см. JLS §5.1.2), что может привести к потере точности, поскольку мантисса числа типа <font face=Courier>float</font> имеет только 24 значащих бита.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''l2i'''''
| style="text-align:right;"  | '''''l2i'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Преобразует значение типа <font face=Courier>long</font> к типу <font face=Courier>int</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''l2i''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''l2i''= 136 (0x88)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' на вершине стека операндов должно принадлежать типу <font face=Courier>long</font>. Оно считывается с вершины стека операндов и преобразуется к результату типа  <font face=Courier>int</font>, следующим образом: в качестве ''результата'' берутся младшие 32 бита ''значения'' <font face=Courier>long</font>, старшие 32 бита игнорируются.  ''Результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''l2i'' выполняет сужающее преобразование примитивных типов (см. JLS §5.1.2), что может привести к полной потере исходного ''значения''. Знак ''результата'' также может отличаться от знака исходного ''значения''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ladd'''''
| style="text-align:right;"  | '''''ladd'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Складывает два значения типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ladd''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ladd''= 97 (0x61)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются с вершины стек операндов. ''Результат'' типа <font face=Courier>long</font> есть  ''значение1'' + ''значение2''. ''Результат'' записывается в стек операндов.

''Результат'' сложения - это младшие 64 бита ''результата'' точного сложения, представленные в двоичном дополнительном коде. Если происходит переполнение, то знак ''результата'' может отличаться от знака  математической суммы двух значений.

Не смотря на то, что при выполнении инструкции ''ladd'' может произойти переполнение, инструкция ''ladd'' никогда не приводит к исключению времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''laload'''''
| style="text-align:right;"  | '''''laload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек значение <font face=Courier>long</font> из массива
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''laload''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''laload''= 47 (0x2f)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'' →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>long</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', так и ''индекс'' считываются из стека операндов. ''Значение'' типа <font face=Courier>long</font> считывается из элемента массива с соответствующим ''индексом'' и записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''laload'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''land'''''
| style="text-align:right;"  | '''''land'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Булево «И» над значениями типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''land''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''land''= 127 (0x7f)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются с вершины стека операндов. ''Результат'' типа <font face=Courier>long</font> есть логическое "И" над ''значением1'' и значеним2. ''Результат'' записывается в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lastore'''''
| style="text-align:right;"  | '''''lastore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>long</font> из стека в массив
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lastore''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lastore''= 80 (0x50)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'', ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>long</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>, ''значение'' должно принадлежать типу <font face=Courier>long</font>. ''Ссылка на массив'', ''индекс'' и ''значение'' считываются из стека операндов. Затем ''значение'' сохраняется в массиве с заданным ''индексом''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''lastore'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lcmp'''''
| style="text-align:right;"  | '''''lcmp'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Сравнивает два значения типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lcmp''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lcmp''= 148 (0x94)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются с вершины стека операндов, затем выполняется знаковое сравнение этих чисел. Если ''значение1'' больше чем ''значение2'', то ''результат'' типа <font face=Courier>int</font> есть 1, записанная в стек операндов.  Если ''значение1'' равно значению2, то ''результат'' типа <font face=Courier>int</font> есть 0, записанный в стек операндов. Если ''значение1'' меньше чем ''значение2'', то ''результат'' типа <font face=Courier>int</font> есть -1, записанная в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lconst_<l>'''''
| style="text-align:right;"  | '''''lconst_<l>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек константу типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lconst_<l>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lconst_0''= 9 (0x9)

''lconst_1''= 10 (0xa)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., <l>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Записывает константу <l> (0 или 1) типа <font face=Courier>long</font> в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc'''''
| style="text-align:right;"  | '''''ldc'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает элемент из константного пула времени выполнения в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ldc''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ldc''= 18 (0x12)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом и представляет собой действительный ''индекс'' элемента константного пула текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Элемент константного пула с заданным ''индексом'' должен принадлежать типу <font face=Courier>int</font>,  <font face=Courier>float</font>, или  быть ссылкой (<font face=Courier>reference</font>) на строковый литерал; либо быть символьной ссылкой на класс, тип метода или обработчик метода (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]).

Если элемент константного пула есть величина с типом <font face=Courier>int</font> или <font face=Courier>float</font>, то ''значение'' этой величины записывается в стек операндов с типом <font face=Courier>int</font> или <font face=Courier>float</font> соответственно.

Если элемент константного пула есть ссылка (<font face=Courier>reference</font>) на экземпляр класса <font face=Courier>String</font>, (строковый литерал, см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]), то ''значение'' ссылки записывается в стек операндов.

Если элемент константного пула есть символьная ссылка на класс (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]), то названный класс разрешается (см. [[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]) и ссылка (тип <font face=Courier>reference</font>) на экземпляр класса <font face=Courier>Class</font> записывается в стек операндов.

Если элемент константного пула есть символьная ссылка на тип метода или обработчик метода (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]), то тип метода или обработчик метода разрешается (см. [[Спецификация виртуальной машины Java#Разрешение типов методов и обработчиков методов|§5.4.3.5]]) и ссылка (тип <font face=Courier>reference</font>) на экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> или <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font> записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на класс,  может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]).

Во время разрешения символьной ссылки на тип метода или обработчик метода,  может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение типов методов и обработчиков методов|§5.4.3.5]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''ldc'' может быть использована для записи в стек значений типа <font face=Courier>float</font> только принадлежащий множеству значений с плавающей точкой (см. [[Спецификация виртуальной машины Java#Типы данных с плавающей точкой, множества значений и значения|§2.3.2]]), поскольку величина <font face=Courier>float</font> в константном пуле (см. [[Спецификация виртуальной машины Java#Структуры CONSTANT_Integer_info и CONSTANT_Float_info|§4.4.4]]) также принадлежит этому множеству.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc_w'''''
| style="text-align:right;"  | '''''ldc_w'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает элемент из константного пула времени выполнения в стек (расширенный индекс)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ldc_w''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ldc_w''= 19 (0x13)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковый ''байт_индекса1'' и ''байт_индекса2'' преобразуются в 16-ти битный беззнаковый ''индекс'' элемента константного пула текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение'' ''индекса'' вычисляется следующим образом: (''байт_индекса1'' << 8)<nowiki>|</nowiki>''байт_индекса2''. Элемент константного пула с заданным ''индексом'' должен принадлежать типу <font face=Courier>int</font>,  <font face=Courier>float</font>, или  быть ссылкой (<font face=Courier>reference</font>) на строковый литерал; либо быть символьной ссылкой на класс, тип метода или обработчик метода (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]).

Если элемент константного пула есть величина с типом <font face=Courier>int</font> или <font face=Courier>float</font>, то ''значение'' этой величины записывается в стек операндов с типом <font face=Courier>int</font> или <font face=Courier>float</font> соответственно.

Если элемент константного пула есть ссылка (<font face=Courier>reference</font>) на экземпляр класса <font face=Courier>String</font>, (строковый литерал, см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]), то ''значение'' ссылки записывается в стек операндов.

Если элемент константного пула есть символьная ссылка на класс (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]), то названный класс разрешается (см. [[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]) и ссылка (тип <font face=Courier>reference</font>) на экземпляр класса <font face=Courier>Class</font> записывается в стек операндов.

Если элемент константного пула есть символьная ссылка на тип метода или обработчик метода (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]), то тип метода или обработчик метода разрешается (см. [[Спецификация виртуальной машины Java#Разрешение типов методов и обработчиков методов|§5.4.3.5]]) и ссылка (тип <font face=Courier>reference</font>) на экземпляр <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodType</font> или <font face=Courier>java</font>.<font face=Courier>lang</font>.<font face=Courier>invoke</font>.<font face=Courier>MethodHandle</font> записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на класс,  может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]).

Во время разрешения символьной ссылки на тип метода или обработчик метода,  может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение типов методов и обработчиков методов|§5.4.3.5]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''ldc_w'' полностью идентична инструкции ''ldc'' за исключением того, что использует ''индекс'' элемента константного пула с более широким диапазоном.

Инструкция ''ldc_w'' может быть использована для записи в стек значений типа <font face=Courier>float</font> только принадлежащий множеству значений с плавающей точкой (см. [[Спецификация виртуальной машины Java#Типы данных с плавающей точкой, множества значений и значения|§2.3.2]]), поскольку величина <font face=Courier>float</font> в константном пуле (см. [[Спецификация виртуальной машины Java#Структуры CONSTANT_Integer_info и CONSTANT_Float_info|§4.4.4]]) также принадлежит этому множеству.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldc2_w'''''
| style="text-align:right;"  | '''''ldc2_w'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает значение типа <font face=Courier>long</font> или <font face=Courier>double</font> из константного пула времени выполнения в стек (расширенный индекс)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ldc2_w''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ldc2_w''= 20 (0x14)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковый ''байт_индекса1'' и ''байт_индекса2'' преобразуются в 16-ти битный беззнаковый ''индекс'' элемента константного пула текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение'' ''индекса'' вычисляется следующим образом: (''байт_индекса1'' << 8)<nowiki>|</nowiki>''байт_индекса2''. Элемент константного пула с заданным ''индексом'' должен принадлежать типу <font face=Courier>long</font>  или  <font face=Courier>double</font> (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]). Элемент константного пула записывается в стек операндов как <font face=Courier>long</font>  или  <font face=Courier>double</font> соответственно.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Для инструкции ''ldc2_w'' существует только версия с использованием двухбайтового расширенного ''индекса''. Инструкции <font face=Courier>ldc2</font>, которая записывает в стек <font face=Courier>long</font>  или  <font face=Courier>double</font> и использует один байт ''индекса'', не существует.

Инструкция ''ldc2_w'' может быть использована для записи в стек значений типа <font face=Courier>double</font> только принадлежащий множеству значений с плавающей точкой (см. [[Спецификация виртуальной машины Java#Типы данных с плавающей точкой, множества значений и значения|§2.3.2]]), поскольку величина <font face=Courier>double</font> в константном пуле (см. [[Спецификация виртуальной машины Java#Структуры CONSTANT_Long_info и CONSTANT_Double_info|§4.4.5]]) также принадлежит этому множеству.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ldiv'''''
| style="text-align:right;"  | '''''ldiv'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Делит два значения типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ldiv''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ldiv''= 109 (0x6d)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Значения считываются с вершины стека операндов. ''Результат'' также принадлежит типу <font face=Courier>long</font> и равен ''значение1'' / ''значение2''. После вычисления ''результат'' записывается в стек операндов.

''Результат'' целочисленного деления округляется по направлению к нулю. Это значит, частное целочисленного деления n / d это число q, максимальное из всех, удовлетворяющих неравенству <nowiki>|</nowiki>d · q<nowiki>|</nowiki>  ≤ <nowiki>|</nowiki>n<nowiki>|</nowiki>. Кроме того q положительно, когда <nowiki>|</nowiki>n<nowiki>|</nowiki>  ≥ <nowiki>|</nowiki>d<nowiki>|</nowiki> и при этом n и  d имеют одинаковый знак и q отрицательно, когда <nowiki>|</nowiki>n<nowiki>|</nowiki>  ≥ <nowiki>|</nowiki>d<nowiki>|</nowiki> и при этом n и d имеют разные знаки.

Существует один специальный случай, который не подходит под описанные выше правила: если делимое – это отрицательное целое, максимальное по модулю для типа <font face=Courier>long</font>, а делитель равен -1, то происходит переполнение и ''результат'' равен делимому. Несмотря на переполнение, в этом случае исключение не выбрасывается.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если делитель целочисленного деления есть 0, то ''ldiv'' генерирует исключение <font face=Courier>ArithmeticException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lload'''''
| style="text-align:right;"  | '''''lload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>long</font> из локальной переменной в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lload''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lload''= 22 (0x16)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом. ''Индекс'' и величина ''индекс''+1 должны принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с заданным ''индексом'' должна содержать величину типа <font face=Courier>long</font>. ''Значение'' локальной переменной, с заданным ''индексом'', записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''lload'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый ''индекс'' локальной переменной.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lload_<n>'''''
| style="text-align:right;"  | '''''lload_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Загружает значение типа <font face=Courier>long</font> из локальной переменной в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lload_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lload_0''= 30 (0x1e)

''lload_1''= 31 (0x1f)

''lload_2''= 32 (0x20)

''lload_3''= 33 (0x21)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И <n> и величина <n>+1 должны принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Локальная переменная с индексом <n> должна содержать величину типа <font face=Courier>long</font>. ''Значение'' локальной переменной с индексом <n>, записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из инструкции ''lload_<n>'' выполняет то же, что и ''lload'' с явным индексом <n> за исключением того, что операнд <n> задан не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lmul'''''
| style="text-align:right;"  | '''''lmul'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Умножает два значения типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lmul''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lmul''= 105 (0x69)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Значения считываются с вершины стека операндов. ''Результат'' также принадлежит типу <font face=Courier>long</font> и равен ''значение1'' * ''значение2''. После вычисления ''результат'' записывается в стек операндов.

''Результат'' умножения – это младшие 64 бита истинного математического ''результата'', представленного в двоичном дополнительном формате в типе <font face=Courier>long</font>. Если происходит переполнение, то знак ''результата'' может не совпадать со знаком истинного математического ''результата''.

Несмотря на то, что переполнение возможно, исключение инструкцией ''lmul'' не выбрасывается.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lneg'''''
| style="text-align:right;"  | '''''lneg'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Инвертирует значение типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lneg''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lneg''= 117 (0x75)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Значение'' должно принадлежать типу <font face=Courier>long</font>. Оно считывается со стека операндов. ''Результат'' принадлежит типу <font face=Courier>long</font> и является арифметическим отрицанием ''значения''. ''Результат'' записывается в стек операндов.

Для величин, принадлежащих типу <font face=Courier>long</font>, отрицание – это тоже, что и вычитание из нуля. Поскольку виртуальная машина Java использует для целых чисел представление в двоичном дополнительном коде, а это представление не симметрично, то отрицание максимального по модулю отрицательного числа типа <font face=Courier>long</font> есть это же число. В этом случае происходит переполнение, однако, несмотря на это исключение не генерируется.

Для всех целых чисел <font face=Courier>''x''</font> принадлежащих типу <font face=Courier>long</font>, -<font face=Courier>''x''</font> равно (~<font face=Courier>''x''</font>) + 1.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lookupswitch'''''
| style="text-align:right;"  | '''''lookupswitch'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Выполняет переход, если ключ в стеке совпадает с ключом в таблице переходов
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lookupswitch''
|-
| style="vertical-align:top;"|<''байты 0-3 выравнивающего смещения''>
|-
| style="vertical-align:top;"|''байт_смещения_по_умолчанию1''
|-
| style="vertical-align:top;"|''байт_смещения_по_умолчанию2''
|-
| style="vertical-align:top;"|''байт_смещения_по_умолчанию3''
|-
| style="vertical-align:top;"|''байт_смещения_по_умолчанию4''
|-
| style="vertical-align:top;"|''пара_значение1-смещение1''
|-
| style="vertical-align:top;"|''пара_значение2-смещение2''
|-
| style="vertical-align:top;"|''пара_значение3-смещение3''
|-
| style="vertical-align:top;"|''пара_значение4-смещение4''
|-
| style="vertical-align:top;"|''другие ''пары_значение-смещение''''…
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lookupswitch''= 171 (0xab)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ключ'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Инструкция ''lookupswitch'' является инструкцией с переменной длинной. Непосредственно за байт-кодом инструкции ''lookupswitch'' следуют байты выравнивающего смещения. Их число может меняться от одного до трёх, таким образом, чтобы адрес ''байта_смещения_по_умолчанию1''  был кратен четырём, если считать с начала текущего метода (под началом текущего метода подразумевается адрес байт-кода первой инструкции метода). Сразу за байтами выравнивающего смещения следует набор пар знаковых 32-х битных значений: ''смещение_по_умолчанию'', ''пара_значение-смещение'' и затем другие 32-х битные пары ''значение''-смещение. Каждое из их этих знаковых 32-х битных значений формируется из четырёх беззнаковых байтов следующим образом: (байт1<<24) <nowiki>|</nowiki> (байт2<<16) <nowiki>|</nowiki> (байт3<<8) <nowiki>|</nowiki> байт4.

Значения таблицы пар ''значение''-смещение должны быть расположены в порядке возрастания значений.

''Ключ'' должен принадлежать типу <font face=Courier>int</font>. Он считывается из стека операндов. Затем ''ключ'' сравнивается со значением. Если ''ключ'' равен одному из значений, тогда целевой адрес вычисляется путём сложения соответствующего смещения и адреса байт-кода инструкции ''lookupswitch''. Если ''ключ'' не соответствует ни одному из значений, целевой адрес вычисляется путём сложения ''смещения_по_умолчанию'' и адреса байт-кода инструкции ''lookupswitch''. Выполнение инструкций продолжается с целевого адреса.

Целевой адрес, вычисленный путём сложения смещения из каждой ''пары_значение-смещение'' с адресом инструкции ''lookupswitch'',  должен находиться в пределах метода, в котором расположена инструкция ''lookupswitch''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|''Пары_значение-смещение'' расположены в порядке возрастания значений, для ускорения поиска. В этом случае скорость поиска будет выше, чем линейная.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lor'''''
| style="text-align:right;"  | '''''lor'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Булево «ИЛИ» над значениями типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lor''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lor''= 129 (0x81)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>long</font> и представляет собой побитовое "или" над ''значением1'' и ''значением2''. Затем ''результат'' записывается в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lrem'''''
| style="text-align:right;"  | '''''lrem'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Остаток от деления значений типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lrem''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lrem''= 113 (0x71)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>long</font> и представляет собой ''значение1'' - (''значение1'' / ''значение2'') * ''значение2''. Затем ''результат'' записывается в стек операндов.

''Результат'' инструкции ''lrem'' это величина такая, что (<font face=Courier>''a''</font>/<font face=Courier>''b''</font>)*<font face=Courier>''b''</font> + (<font face=Courier>''a''</font>%<font face=Courier>''b''</font>) равна <font face=Courier>''a''</font>.  Это равенство справедливо даже в специальных случаях, когда делимое есть отрицательное целое, максимальное по модулю, а делитель есть -1 (при этом остаток есть 0). Из равенства следует также, что ''результат'' операции отрицателен, если делимое отрицательно и положителен, если делимое положительно. Более того, ''результат'' всегда меньше чем делитель.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если делитель равен нулю, то инструкция ''lrem'' генерирует <font face=Courier>ArithmeticException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lreturn'''''
| style="text-align:right;"  | '''''lreturn'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Возвращает значение типа <font face=Courier>long</font> из метода
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lreturn''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lreturn''= 173 (0xad)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение'' →

[пусто]
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Текущий метод должен возвращать величину типа <font face=Courier>long</font>. ''Значение'' должно принадлежать <font face=Courier>long</font>. Если текущий метод объявлен с ключевым словом <font face=Courier>synchronized</font>, то при входе в метод монитор захватывается первоначально (либо повторно, если уже был захвачен до того), а при выходе освобождается, как при выполнении инструкции ''monitorexit'' для текущего потока. Если в ходе выполнения метода не было исключений, ''значение'' считывается из стека операндов текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]) Затем  ''значение'' записывается в стек операндов фрейма, принадлежащего вызывающему методу. Все остальные ''значения'' стека операндов текущего фрейма теряются.

Затем интерпретатор передаёт управление вызывающему методу, делая текущим соответствующий фрейм.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если реализация виртуальной машины Java не поддерживает правила структурных блокировок описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], тогда если текущий метод объявлен как  <font face=Courier>synchronized</font> и текущий поток не является владельцем монитора, захваченного при входе в метод, то при вызове ''lreturn'' будет выброшено исключение <font face=Courier>IllegalMonitorStateException</font>. Это может произойти, если <font face=Courier>synchronized</font>-метод содержит инструкцию ''monitorexit'', а инструкция ''monitorenter'' по объекту синхронизации отсутствует.

С другой стороны, если реализация виртуальной машины Java  поддерживает правила структурных блокировок описанные в [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]], и во время выполнения текущего метода нарушено первое из этих правил, то при вызове ''lreturn'' будет выброшено исключение <font face=Courier>IllegalMonitorStateException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lshl'''''
| style="text-align:right;"  | '''''lshl'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Сдвигает влево значение типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lshl''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lshl''= 121 (0x79)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>long</font> и представляет собой ''значение1'' сдвинутое влево на s позиций, где s – это младшие 6 битов ''значения2''. Затем ''результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Операция сдвига влево эквивалентна (даже в случае переполнения) умножению исходного ''значения'' на 2 в степени s. Количество бит, на которое нужно сдвинуть ''значение'', всегда находится в пределах от 0 до 63 включительно, как если бы до сдвига над ''значением2'' было выполнено логическое «И» с маской 0x3f.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lshr'''''
| style="text-align:right;"  | '''''lshr'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Арифметический сдвиг вправо значения типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lshr''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lshr''= 123 (0x7b)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>long</font> и представляет собой ''значение1'' сдвинутое вправо на s позиций, где s – это младшие 6 битов ''значения2''. Затем ''результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Операция сдвига вправо возвращает ''значение'' равное  ⌊''значение1''/ 2<sup>s</sup>⌋, где s - это ''значение2'' & 0x3f. Если ''значение1'' не отрицательно, то сдвиг эквивалентен целочисленному делению ''значения1'' на 2 в степени s с отбрасыванием дробной части ''результата''. Количество бит, на которое нужно сдвинуть ''значение'', всегда находится в пределах от 0 до 63 включительно, как если бы до сдвига над ''значением2'' было выполнено логическое «И» с маской 0x3f.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lstore'''''
| style="text-align:right;"  | '''''lstore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает из стека значение типа <font face=Courier>long</font> и записывает в локальную переменную
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lstore''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lstore''= 55 (0x37)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' является беззнаковым байтом. ''Индекс'' и величина ''индекс''+1 должны принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение''  на вершине стека операндов должно принадлежать типу <font face=Courier>long</font>. Оно считывается из стека операндов. В локальные переменные с индексами ''индекс'' и ''индекс''+1 записывается ''значение''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''lstore'' может быть использована совместно с инструкцией ''wide'', когда необходимо задать двухбайтовый беззнаковый ''индекс'' локальной переменной.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lstore_<n>'''''
| style="text-align:right;"  | '''''lstore_<n>'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает из стека значение типа <font face=Courier>long</font> и записывает в локальную переменную
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lstore_<n>''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lstore_0''= 63 (0x3f)

''lstore_1''= 64 (0x40)

''lstore_2''= 65 (0x41)

''lstore_3''= 66 (0x42)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И <n> и величина <n>+1 должны принадлежать массиву локальных переменных текущего фрейма (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение''  на вершине стека операндов должно принадлежать типу <font face=Courier>long</font>. Оно считывается из стека операндов. В локальные переменные с индексами <n> и <n> +1 записывается ''значение''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Каждая из инструкции ''lstore_<n>'' выполняет то же, что и ''lstore'' с явным индексом <n> за исключением того, что операнд <n> задан не явно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lsub'''''
| style="text-align:right;"  | '''''lsub'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Вычитает два значения типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lsub''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lsub''= 101 (0x65)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются с вершины стек операндов. ''Результат'' типа <font face=Courier>long</font> есть  ''значение1'' - ''значение2''. ''Результат'' записывается в стек операндов.

Для целочисленного вычитания выражение <font face=Courier>''a''</font>-<font face=Courier>''b''</font> дает такой же ''результат'', что и <font face=Courier>''a''</font>+(-<font face=Courier>''b''</font>). Для значений типа <font face=Courier>long</font> вычитание из нуля есть то же самое, что и отрицание числа.

''Результат'' вычитания - это младшие 64 бита ''результата'' точного вычитания, представленные в двоичном дополнительном коде. Если происходит переполнение, то знак ''результата'' может отличаться от знака  математической разности двух значений.

Не смотря на то, что при выполнении инструкции ''lsub'' может произойти переполнение, инструкция ''lsub'' никогда не приводит к исключению времени выполнения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lushr'''''
| style="text-align:right;"  | '''''lushr'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Логический (беззнаковый) сдвиг вправо значения типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lushr''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lushr''= 125 (0x7d)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>long</font> и представляет собой ''значение1'' сдвинутое вправо на s позиций с заполнением нулями освободившихся позиций, где s – это младшие 6 битов ''значения2''. Затем ''результат'' записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Если ''значение1'' положительно и s равно ''значение2'' & 0x3f, то ''результат'' сдвига равен ''значение1'' >> s; если ''значение1'' отрицательно, то ''результат'' равен выражению (''значение1'' >> s) + (2L <<~s). Добавление слагаемого (2L <<~s) эквивалентно тому, что знаковый бит при сдвиге будет заменён нулём. Количество бит, на которое нужно сдвинуть ''значение'', всегда находится в пределах от 0 до 63 включительно.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''lxor'''''
| style="text-align:right;"  | '''''lxor'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Булево исключающее «ИЛИ» над значениями типа <font face=Courier>long</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''lxor''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''lxor''= 131 (0x83)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение1'', ''значение2'' →

..., ''результат''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|И ''значение1'' и ''значение2'' должны принадлежать типу <font face=Courier>long</font>. Они считываются из стека операндов. ''Результат'' также принадлежит типу <font face=Courier>long</font> и представляет собой ''результат'' операции «исключающее ИЛИ» над ''значением1'' и ''значением2''. Затем ''результат'' записывается в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''monitorenter'''''
| style="text-align:right;"  | '''''monitorenter'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Захватывает монитор объекта
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''monitorenter''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''monitorenter''= 194 (0xc2)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font>.
Каждый объект поставлен в соответствие некоторому монитору. Монитор захвачен тогда и только тогда, когда у него есть владелец. Поток, который выполняет инструкцию ''monitorenter'', пытается захватить монитор, связанный со ссылкой на объект следующим образом:
* Если счетчик монитора, связанного со ссылкой на объект, равен нулю, то поток захватывает монитор и устанавливает счётчик равным единице. Теперь поток является владельцем монитора.
* Если поток уже является владельцем монитора, связанного со ссылкой на объект, то поток увеличивает счётчик монитора на единицу.
* Если монитором, связанным со ссылкой на объект владеет другой поток, то текущий поток блокируется до тех пор, пока счётчик монитора не станет равным нулю. Затем поток снова пытается завладеть монитором.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' равна <font face=Courier>null</font>,  ''monitorenter'' генерирует
<font face=Courier>NullPointerException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''monitorenter'' может быть использована совместно с одной или несколькими инструкциями ''monitorexit'' для реализации <font face=Courier>synchronized</font>-блока  языка программирования Java. Инструкции ''monitorenter'' и  ''monitorexit'' не используются при имплементации <font face=Courier>synchronized</font>-методов, хотя их можно использовать для эквивалентной реализации блокировок. При вызове <font face=Courier>synchronized</font>-метода виртуальная машина Java неявно выполняет захват монитора и неявно освобождает монитор при выполнении инструкции возврата из <font face=Courier>synchronized</font>-метода. Этот неявный захват и освобождение монитора эквивалентен выполнению инструкций ''monitorenter'' и ''monitorexit''.

Поддержка связи монитора и объекта может быть выполнена различными способами, описание которых выходит за рамки данной спецификации. Например, монитор может создаваться и уничтожаться одновременно с созданием и уничтожением объекта. С другой стороны, монитор может создаваться при первой попытке потока захватить его и уничтожаться после того, как поток освободил его, и нет других потоков, пытающихся захватить его.

Конструкции синхронизации языка программирования Java требуют поддержки и других операций с монитором, кроме захвата и освобождения. Эти операции включают в себя ожидание на мониторе (<font face=Courier>Object</font>.<font face=Courier>wait</font>) и уведомление других потоков, ждущих на мониторе, о том, что монитор свободен (<font face=Courier>Object</font>.<font face=Courier>notifyAll</font> и <font face=Courier>Object</font>.<font face=Courier>notify</font>). Эти операции поддерживаются в стандартном пакете <font face=Courier>java</font>.<font face=Courier>lang</font>, поставляемом с виртуальной машиной Java. Среди инструкций виртуальной машины Java отсутствует явная поддержка указанных выше операций.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''monitorexit'''''
| style="text-align:right;"  | '''''monitorexit'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Освобождает монитор объекта
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''monitorexit''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''monitorexit'' = 195 (0xc3)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font>.

Поток, который выполняет инструкцию ''monitorexit'' должен быть владельцем монитора, поставленного в соответствие объекту, на который ссылается ''ссылка на объект''.

Поток уменьшает счётчик монитора, связанного с объектом. Если значение счётчика станет равным нулю, то поток, освободивший монитор больше не является его владельцем. Другие потоки, для которых доступ к монитору был заблокирован, теперь могут попытаться захватить монитор.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' равна <font face=Courier>null</font>,  ''monitorexit'' генерирует
<font face=Courier>NullPointerException</font>.

Если поток, который выполняет инструкцию ''monitorexit'' не является владельцем монитора поставленного в соответствие объекту, на который ссылается ''ссылка на объект'', то ''monitorexit'' генерирует исключение <font face=Courier>IllegalMonitorStateException</font>.

Если реализация виртуальной машины Java поддерживает правила структурной блокировки (см. [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]]), и второе из этих правил нарушено, то ''monitorexit'' генерирует <font face=Courier>IllegalMonitorStateException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''monitorexit'' может быть использована совместно с одной или несколькими инструкциями ''monitorenter'' для реализации <font face=Courier>synchronized</font>-блока  языка программирования Java. Инструкции ''monitorenter'' и  ''monitorexit'' не используются при имплементации <font face=Courier>synchronized</font>-методов, хотя их можно использовать для эквивалентной реализации блокировок.

Виртуальная машина Java по-разному обрабатывает исключения, которые возникают в <font face=Courier>synchronized</font> -блоках и <font face=Courier>synchronized</font> -методах:

* Освобождение монитора при нормальном завершении <font face=Courier>synchronized</font>-метода выполняет виртуальная машина Java с помощью инструкции возврата из метода. Освобождение монитора при аварийном завершении <font face=Courier>synchronized</font>-метода также выполняет виртуальная машина Java с помощью инструкции ''athrow''.
* Если исключение генерируется в <font face=Courier>synchronized</font>-блоке, освобождение монитора, захваченного при входе в <font face=Courier>synchronized</font>-блок выполняется за счет механизма поддержки исключений виртуальной машины Java ([[Спецификация виртуальной машины Java#Компиляция инструкций синхронизации|§3.14]]).
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''multianewarray'''''
| style="text-align:right;"  | '''''multianewarray'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Создаёт новый многомерный массив
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''multianewarray''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|-
| style="vertical-align:top;"|''число_измерений''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''multianewarray''= 197 (0xc5)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''число_элементов_измерения1'', [''число_элементов_измерения2'',...] →

..., ''ссылка на массив''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Число измерений'' - беззнаковый байт, принимающий значение большее либо равное единице. Он представляет собой количество размерностей массива, который необходимо создать. Стек операндов должен содержать значение каждой размерности. Каждое такое значение есть ''число_элементов_измерения''. Оно должно принадлежать типу <font face=Courier>int</font> и быть не отрицательным.

Все значения количества элементов измерения считываются из стека операндов. Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула, на который указывает построенный ''индекс'', должен быть ссылкой на класс, массив или интерфейс. Обозначенный класс, массив или интерфейс разрешается (см. [[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]). Разрешенный элемент должен быть массивом с размерностью большей или равной числу_измерений.

В куче выделяется память для многомерного массива, элементы которого также являются массивами. Если ''число_элементов_измерения'' равно нулю, то память для подразмерностей не выделяется. Компоненты массива первой размерности инициализируются ссылками на подмассив второго измерения и так далее. Компоненты последнего измерения массива инициализируются значениями по умолчанию для соответствующих типов данных (см. [[Спецификация виртуальной машины Java#Примитивные типы и значения|§2.3]], [[Спецификация виртуальной машины Java#Ссылочные типы и их значения|§2.4]]). ''Ссылка на массив'' с типом <font face=Courier>reference</font> записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на класс, массив или интерфейс, может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]).

Если текущий класс не имеет доступа к типу, который объявлен в качестве типа элементов массива, то ''multianewarray'' генерирует <font face=Courier>IllegalAccessError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если любое ''число_элементов_измерения'' в стеке операндов меньше нуля, то ''multianewarray'' генерирует <font face=Courier>NegativeArraySizeException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Для создания одномерного массива более эффективным является использование инструкций ''newarray'' или ''anewarray''.

Массив, в константном пуле, на которые ссылается инструкция ''multianewarray'' с помощью ''байтов_индекса'' фактически может иметь большую размерность, чем операнд ''число_измерений''. В этом случае создаются только указанные в качестве операндов измерения.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''new'''''
| style="text-align:right;"  | '''''new'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Создаёт новый объект
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''new''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''new''= 187 (0xbb)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''ссылка на объект''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). Значение ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула, на который указывает построенный ''индекс'', должен быть символьной ссылкой на класс, или интерфейс. Массив или интерфейс разрешается (см. [[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]) и в результате разрешения должен быть получен класс. Память для нового экземпляра указанного класса берётся из кучи, а поля экземпляра инициализируются соответствующими значениями по умолчанию (см. 2.3, [[Спецификация виртуальной машины Java#Ссылочные типы и их значения|§2.4]]). Ссылка на экземпляр с типом <font face=Courier>reference</font> записывается в стек операндов.

При успешном разрешении класса, он инициализируется (см. [[Спецификация виртуальной машины Java#Инициализация|§5.5]]), если до этого он ещё не был инициализирован.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на класс, массив или интерфейс, может быть создано любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение классов и интерфейсов|§5.4.3.1]]).

Если в ходе разрешения символьной ссылки будет получен абстрактный класс или интерфейс, инструкция ''new'' генерирует исключение <font face=Courier>InstantiationError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если в ходе выполнения инструкции ''new'' происходит инициализация класса, ''new'' может генерировать любую из ошибок (наследник класса <font face=Courier>Error</font>), подробно описанных в JLS §15.9.4.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''new'' не до конца выполняет создание нового экземпляра класса. Создание экземпляра будет не завершено до тех пор пока не вызван инициализирующий метод (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]]) экземпляра.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''newarray'''''
| style="text-align:right;"  | '''''newarray'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Создаёт новый массив
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''newarray''
|-
| style="vertical-align:top;"|''код_типа_компонентов_массива''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''newarray''= 188 (0xbc)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''количество элементов'' →

..., ''ссылка на массив''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Количество элементов'' должно принадлежать типу  <font face=Courier>int</font>.  Оно считывается из стека операндов.

''Код_типа_компонентов_массива'' может принимать одно из следующих значений:

'''Таблица. Коды типов массива'''
{| border="1" style="border-collapse:collapse;"
! Тип массива
! Код_типа_компонентов_массива
|-
| <font face=Courier>T_BOOLEAN</font>
| 4
|-
| <font face=Courier>T_CHAR</font>
| 5
|-
| <font face=Courier>T_FLOAT</font>
| 6
|-
| <font face=Courier>T_DOUBLE</font>
| 7
|-
| <font face=Courier>T_BYTE</font>
| 8
|-
| <font face=Courier>T_SHORT</font>
| 9
|-
| <font face=Courier>T_INT</font>
| 10
|-
| <font face=Courier>T_LONG</font>
| 11
|}



В куче создаётся новый новый массив, чьи компоненты имеют тип, соответствующий указанному коду. ''Ссылка на массив'' типа <font face=Courier>reference</font> записывается в стек операндов. Каждый элемент массива инициализируется значением по умолчанию (см. [[Спецификация виртуальной машины Java#Примитивные типы и значения|§2.3]], [[Спецификация виртуальной машины Java#Ссылочные типы и их значения|§2.4]]) для своего собственного типа.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''количество элементов'' меньше нуля, то инструкция ''newarray'' генерирует исключение <font face=Courier>NegativeArraySizeException</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|В реализации виртуальной машины Java компании Oracle, массивы с типом <font face=Courier>boolean</font> (код_типа_элементов_массива есть <font face=Courier>T_BOOLEAN</font>) хранятся в виде последовательности байт (один байт хранит одно значение типа <font face=Courier>boolean</font>). Доступ к таким массивам осуществляется посредством инструкций ''baload'' и ''bastore'', которые также используются для работы массивами типа <font face=Courier>byte</font>. Другие реализации виртуальной машины могут использовать упакованные массивы типа <font face=Courier>boolean</font>, однако доступ к элементам таких массивов также должен выполняться с помощью инструкций ''baload'' и ''bastore''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''nop'''''
| style="text-align:right;"  | '''''nop'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Не делает ничего
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''nop''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''nop''= 0 (0x0)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Нет

Без изменений
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Не делает ничего
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''pop'''''
| style="text-align:right;"  | '''''pop'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает операнд с вершины стека
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''pop''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''pop''= 87 (0x57)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Считывает ''значения'' из стека операндов.
Инструкция ''pop'' только если тип ''значения'' принадлежит категории 1 (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''pop2'''''
| style="text-align:right;"  | '''''pop2'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Считывает один или два операнда с вершины стека
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''pop2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''pop2''= 88 (0x58)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Форма 1:


..., ''значение1'', ''значение2'' →

...

где ''значение1'', ''значение2'' – это ''значения'' из категории 1 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])


Форма 2:


..., ''значение'' →

...

где ''значение'' – это ''значение'' из категории 1 вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Считывает одно или два ''значения'' из стека операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''putfield'''''
| style="text-align:right;"  | '''''putfield'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает значение в поле объекта
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''putfield''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''putfield''= 181 (0xb5)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на объект'', ''значение'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение'' ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула, на который указывает построенный ''индекс'', должен быть символьной ссылкой на поле класса (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]), Элемент константного пула содержит имя поля, дескриптор поля и символьную ссылку на класс, которому принадлежит поле. ''Ссылка на объект'' не должна ссылаться на массив. Если поле класса объявлено как <font face=Courier>protected</font> (см. [[Спецификация виртуальной машины Java#Методы|§4.6]]) и оно принадлежит предку текущего класса и не объявлено в том же пакете что и текущий класс ([[Спецификация виртуальной машины Java#Создание и загрузка|§5.3]]), то в этом случае ''ссылка на объект'' должна указывать либо на текущий класс, либо на его предка.

Поле разрешается (см. [[Спецификация виртуальной машины Java#Разрешение поля|§5.4.3.2]]). Тип ''значения'', которое записывает инструкция ''putfield'', должен быть совместим с типом в дескрипторе поля (см. [[Спецификация виртуальной машины Java#Дескрипторы поля|§4.3.2]]). Если тип поля в дескрипторе равен <font face=Courier>boolean</font>,  <font face=Courier>byte</font>,  <font face=Courier>char</font>,  <font face=Courier>short</font> или <font face=Courier>int</font>, то ''значение'' должно принадлежать типу <font face=Courier>int</font>. Если тип поля в дескрипторе равен <font face=Courier>float</font>,  <font face=Courier>long</font> или <font face=Courier>double</font>, то ''значение'' должно быть <font face=Courier>float</font>,  <font face=Courier>long</font> или <font face=Courier>double</font> соответственно. Если тип поля в дескрипторе это ссылочный тип, то тип ''значения'' должен быть совместим с данным типом для операции присваивания (JLS §5.2). Если поле <font face=Courier>final</font>, то оно должно быть объявлено в текущем классе, а инструкция ''putfield'' должна находиться в инициализирующем методе (<font face=Courier><init></font>) текущего класса (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]])

''Значение'' и ''ссылка на объект'' считываются из стека операндов. ''Ссылка на объект'' должна принадлежать типу <font face=Courier>reference</font>. ''Значение'' проходит ряд преобразований ([[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), затем преобразованное ''значение''` записывается в поле экземпляра, на который указывает ''ссылка на объект''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на поле может быть выброшено любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение поля|§5.4.3.2]]).

Если разрешённое поле статическое (<font face=Courier>static</font>), то инструкция ''putfield'' генерирует <font face=Courier>IncompatibleClassChangeError</font>.

Если поле <font face=Courier>final</font>, то оно должно быть объявлено в текущем классе, а инструкция должна находиться в инициализирующем методе (<font face=Courier><init></font>) текущего класса. В противно случае будет выброшен исключение <font face=Courier>IllegalAccessError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на объект'' равна <font face=Courier>null</font>, то инструкция ''putfield'' генерирует <font face=Courier>NullPointerException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''putstatic'''''
| style="text-align:right;"  | '''''putstatic'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает значение в статическое поле объекта
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''putstatic''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''putstatic''= 179 (0xb3)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение''→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Беззнаковые ''байт_индекса1'' и ''байт_индекса2'' используются для построения ''индекса'' массива в константном пуле времени выполнения текущего класса (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]). ''Значение'' ''индекса'' определяется как (''байт_индекса1'' << 8)<nowiki>|</nowiki>(''байт_индекса2''). Элемент константного пула, на который указывает построенный ''индекс'', должен быть символьной ссылкой на поле класса (см. [[Спецификация виртуальной машины Java#Константный пул времени выполнения|§5.1]]), Элемент константного пула содержит имя поля, дескриптор поля и символьную ссылку на класс или интерфейс, которому принадлежит поле. Поле разрешается (см. [[Спецификация виртуальной машины Java#Разрешение поля|§5.4.3.2]]).

При успешном разрешении поля инициализируется класс или интерфейс (см. [[Спецификация виртуальной машины Java#Инициализация|§5.5]]), в котором объявлено поле, если до этого они не были еще инициализированы.

Тип ''значения'', которое записывает инструкция ''putstatic'', должен быть совместим с типом в дескрипторе поля (см. [[Спецификация виртуальной машины Java#Дескрипторы поля|§4.3.2]]). Если тип поля в дескрипторе равен <font face=Courier>boolean</font>,  <font face=Courier>byte</font>,  <font face=Courier>char</font>,  <font face=Courier>short</font> или <font face=Courier>int</font>, то ''значение'' должно принадлежать типу <font face=Courier>int</font>. Если тип поля в дескрипторе равен <font face=Courier>float</font>,  <font face=Courier>long</font> или <font face=Courier>double</font>, то ''значение'' должно быть <font face=Courier>float</font>,  <font face=Courier>long</font> или <font face=Courier>double</font> соответственно. Если тип поля в дескрипторе это ссылочный тип, то тип ''значения'' должен быть совместим с данным типом для операции присваивания (JLS §5.2). Если поле <font face=Courier>final</font>, то оно должно быть объявлено в текущем классе, а инструкция ''putstatic'' должна находиться в инициализирующем методе (<font face=Courier><init></font>) текущего класса (см. [[Спецификация виртуальной машины Java#Специальные методы|§2.9]])

''Значение'' считывается из стека операндов и проходит ряд преобразований ([[Спецификация виртуальной машины Java#Правила преобразования множества значений|§2.8.3]]), затем преобразованное ''значение''` записывается в поле класса.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения связывания'''
| style="vertical-align:top;"|Во время разрешения символьной ссылки на поле класса или интерфейса может быть выброшено любое исключение, описанное в ([[Спецификация виртуальной машины Java#Разрешение поля|§5.4.3.2]]).

Если разрешенное поле не статическое (<font face=Courier>static</font>), то инструкция ''putstatic'' генерирует <font face=Courier>IncompatibleClassChangeError</font>.

Если поле <font face=Courier>final</font>, то оно должно быть объявлено в текущем классе, а инструкция должна находиться в инициализирующем методе (<font face=Courier><init></font>) текущего класса. В противно случае будет выброшен исключение <font face=Courier>IllegalAccessError</font>.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если вызов инструкции ''putstatic'' приводит к инициализации класса или интерфейса, то ''putstatic'' может вызвать ошибку, более подробно описанную в разделе [[Спецификация виртуальной машины Java#Инициализация|§5.5]].
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Инструкция ''putstatic''  может быть использована для установки значений поля интерфейса только при инициализации поля. Поля интерфейса инициализируются только один раз, когда вычисляется выражение интерфейсного поля  при инициализации самого интерфейса (см. [[Спецификация виртуальной машины Java#Инициализация|§5.5]], JLS §9.3.1)
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''ret'''''
| style="text-align:right;"  | '''''ret'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Возвращает управление из подпрограммы
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''ret''
|-
| style="vertical-align:top;"|''индекс''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''ret''= 169 (0xa9)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Без изменений
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Индекс'' - это беззнаковый байт от 0 до 255 включительно. Локальная переменная в текущем фрейме (см. [[Спецификация виртуальной машины Java#Фреймы|§2.6]]) с заданным ''индексом'' должна содержать величину типа <font face=Courier>returnAddress</font>. Содержимое локальной переменной записывается в регистр <font face=Courier>pc</font> виртуальной машины Java, и выполнение инструкций продолжается с нового адреса.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Обратите внимание, что инструкция ''jsr'' записывает адрес возврата в стек операндов, инструкция ''ret'' считывает его из локальной переменной. Эта асимметрия выполнена намеренно.

В реализации компилятора языка программирования Java компании Oracle до версии Java SE 6 инструкция ''ret'' использовалась совместно с ''jsr'' и ''jsr_w'' для имплементации блока <font face=Courier>finally</font> (см. [[Спецификация виртуальной машины Java#Компиляция инструкции finally|§3.13]], [[Спецификация виртуальной машины Java#Исключения и блок finally|§4.10.2.5]]).

Не следует путать инструкцию ''ret'' и ''return''. Инструкция ''return'' возвращает управление из метода без передачи параметров вызвавшему методу.

Инструкция ''ret'' может быть использована совместно с ''wide'' для доступа к локальным переменным, имеющим двухбайтовый ''индекс''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''return'''''
| style="text-align:right;"  | '''''return'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Возврат из <font face=Courier>void</font> метода
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''return''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''return''= 177 (0xb1)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

[пусто]
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Текущий метод должен иметь тип возвращаемого значения <font face=Courier>void</font>. Если текущий метод объявлен как <font face=Courier>synchronized</font>, то при входе в метод происходит захват (или повторный захват) монитора и, возможно, освобождение монитора (если перед выполнением инструкции ''return'' счётчик захвата монитора был равен единице - ''прим. перев.''). Если в ходе выполнения метода исключений выброшено не было, то все значения стека операндов текущего фрейма теряются.

Затем интерпретатор возвращает управление вызывающему методу, делая активным соответствующий фрейм.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если реализация виртуальной машины Java не поддерживает правила структурной блокировки (см. [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]]), тогда происходит следующее: если текущий метод объявлен как <font face=Courier>synchronized</font> и текущий поток не владеет монитором, который захватывается при входе в метод, то ''return'' генерирует <font face=Courier>IllegalMonitorStateException</font>. Это происходит, например, когда метод, объявленный как <font face=Courier>synchronized</font>, содержит инструкцию ''monitorexit'', но не содержит ''monitorenter'' для объекта, которому принадлежит метод.

Если реализация виртуальной машины Java поддерживает правила структурной блокировки (см. [[Спецификация виртуальной машины Java#Синхронизация|§2.11.10]]), и первое из этих правил нарушено, то ''return'' генерирует <font face=Courier>IllegalMonitorStateException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''saload'''''
| style="text-align:right;"  | '''''saload'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает значение типа <font face=Courier>short</font> из массива в стек
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''saload''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''saload''= 53 (0x35)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'' →

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>short</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>. Как ''ссылка на массив'', так и ''индекс'' считываются из стека операндов. ''Значение'' типа <font face=Courier>short</font> считывается из элемента массива с соответствующим ''индексом'' и записывается в стек операндов.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''saload'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''sastore'''''
| style="text-align:right;"  | '''''sastore'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает значение типа <font face=Courier>short</font> из стека в массив
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''sastore''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''sastore''= 86 (0x56)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''ссылка на массив'', ''индекс'', ''значение''→

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|''Ссылка на массив'' должна быть типа <font face=Courier>reference</font> и ссылаться на массив, чьи компоненты ''значения'' типа <font face=Courier>short</font>. ''Индекс'' должен принадлежать типу <font face=Courier>int</font>, ''значение'' должно принадлежать типу <font face=Courier>short</font>. ''Ссылка на массив'', ''индекс'' и ''значение'' считываются из стека операндов. Затем ''значение'' сохраняется в массиве с заданным ''индексом''.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Исключения времени выполнения'''
| style="vertical-align:top;"|Если ''ссылка на массив'' равна <font face=Courier>null</font>, то ''sastore'' генерирует <font face=Courier>NullPointerException</font>. В противном случае, если ''индекс'' вне границ массива, генерируется исключение <font face=Courier>ArrayIndexOutOfBoundsException</font>.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''sipush'''''
| style="text-align:right;"  | '''''sipush'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Записывает в стек значение типа <font face=Courier>short</font>
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''sipush''
|-
| style="vertical-align:top;"|''байт1''
|-
| style="vertical-align:top;"|''байт2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''sipush''= 17 (0x11)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|...→

..., ''значение''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Промежуточные ''байт1'' и ''байт2'' преобразуются в ''значение'' типа <font face=Courier>short</font>: (''байт1'' << 8) <nowiki>|</nowiki> ''байт2''. Затем полученное ''значение'' расширяется с учётом знака до <font face=Courier>int</font>, которое и записывается в стек операндов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''swap'''''
| style="text-align:right;"  | '''''swap'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Меняет местами два операнда на вершине стека
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''swap''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''swap''= 95 (0x5f)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''значение2'', ''значение1'' →

..., ''значение1'', ''значение2''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Меняет местами два ''значение'' на вершине стека операндов.

Инструкция ''swap''  должна использоваться только, если тип ''значения1'' и ''значения2'' принадлежит первой категории вычислимых типов (см. [[Спецификация виртуальной машины Java#Типы данных и виртуальная машина Java|§2.11.1]])
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Виртуальная машина Java не имеет инструкции для перемены местами значений, чей тип принадлежит категории 2 вычислимых типов.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''tableswitch'''''
| style="text-align:right;"  | '''''tableswitch'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Выполняет переход в зависимости от индекса смещения в стеке
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''tableswitch''
|-
| style="vertical-align:top;"|<''байты 0-3 выравнивающего смещения''>
|-
| style="vertical-align:top;"|''байт_смещения_по_умолчанию1''
|-
| style="vertical-align:top;"|''байт_смещения_по_умолчанию2''
|-
| style="vertical-align:top;"|''байт_смещения_по_умолчанию3''
|-
| style="vertical-align:top;"|''байт_смещения_по_умолчанию4''
|-
| style="vertical-align:top;"|''байт_нижней_границы1''
|-
| style="vertical-align:top;"|''байт_нижней_границы2''
|-
| style="vertical-align:top;"|''байт_нижней_границы3''
|-
| style="vertical-align:top;"|''байт_нижней_границы4''
|-
| style="vertical-align:top;"|''байт_верхней_границы1''
|-
| style="vertical-align:top;"|''байт_верхней_границы2''
|-
| style="vertical-align:top;"|''байт_верхней_границы3''
|-
| style="vertical-align:top;"|''байт_верхней_границы4''
|-
| style="vertical-align:top;"|''смещения переходов''…
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''tableswitch''= 170 (0xaa)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|..., ''индекс'' →

...
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Инструкция ''tableswitch'' является инструкцией с переменной длинной. Непосредственно за байт-кодом инструкции ''tableswitch'' следуют байты выравнивающего смещения. Их число может меняться от одного до трёх, таким образом, чтобы адрес ''байта_смещения_по_умолчанию1''  был кратен четырём, если считать с начала текущего метода (под началом текущего метода подразумевается адрес байт-кода первой инструкции метода). Сразу за байтами выравнивающего смещения следует три 32-х битных значения: ''смещение_по_умолчанию'', ''нижняя_граница'', ''верхняя_граница''. Затем следует набор 32-х битных смещений переходов, количество которых равно ''верхняя_граница'' - ''нижняя_граница'' + 1. Значение ''нижней_границы'' должно быть меньше либо равно ''верхней_границы''. Набор 32-х битных смещений представляет собой таблицу переходов, где в качестве базы для смещения используется адрес инструкции ''tableswitch''. Каждое из их этих знаковых 32-х битных значений формируется из четырёх беззнаковых байтов следующим образом: (байт1<<24) <nowiki>|</nowiki> (байт2<<16) <nowiki>|</nowiki> (байт3<<8) <nowiki>|</nowiki> байт4.

''Индекс'' типа <font face=Courier>int</font> считывается с вершины стека операндов. Если ''индекс'' меньше ''нижней_границы'' или больше ''верхней_границы'', то целевой адрес перехода вычисляется путём сложения смещения по умолчанию и адреса инструкции ''tableswitch''. Если ''индекс'' лежит в пределах ''нижней_границы'' и ''верхней_границы'', то целевой адрес перехода вычисляется путём сложения найденного смещения и адреса инструкции ''tableswitch''. Выполнение инструкций продолжается с целевого адреса.

Целевой адрес, вычисленный путём сложения ''смещения переходов'' из таблицы переходов или ''смещения по умолчанию'' с адресом инструкции ''tableswitch'',  должен находиться в пределах метода, в котором расположена инструкция ''tableswitch''.
|}

<br><br><br><br>
{| width="100%"
| style="text-align:left;"  | '''''wide'''''
| style="text-align:right;"  | '''''wide'''''
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Операция'''
| style="vertical-align:top;"|Расширяет значение индекса локальной переменной за счёт дополнительных байтов
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат 1'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''wide''
|-
| style="vertical-align:top;"|<код операции>
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|}
|}

<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|
|
| где <код операции> принимает ''значение''  ''iload'',  ''fload'',  ''aload'',  ''lload'',  ''dload'',  ''istore'', ''fstore'', ''astore'', ''lstore'', ''dstore'', или ''ret''
|}
<br>

{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формат 2'''
|
{| border="1" style="border-collapse:collapse;" width="400px"
| style="vertical-align:top;"|''wide''
|-
| style="vertical-align:top;"|''iinc''
|-
| style="vertical-align:top;"|''байт_индекса1''
|-
| style="vertical-align:top;"|''байт_индекса2''
|-
| style="vertical-align:top;"|''байт_константы1''
|-
| style="vertical-align:top;"|''байт_константы2''
|}
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Формы'''
| style="vertical-align:top;"|''wide''= 196 (0xc4)
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Стек операндов'''
| style="vertical-align:top;"|Такой же, как и у модифицируемой команды
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Описание'''
| style="vertical-align:top;"|Инструкция ''wide'' изменяет поведение другой инструкции. Инструкция ''wide'' может быть использована в двух формах, в зависимости от расширяемой команды. Первая форма инструкции ''wide'' изменяет поведение следующих инструкций: ''iload'',  ''fload'',  ''aload'',  ''lload'',  ''dload'',  ''istore'',  ''fstore'',  ''astore'', ''lstore'',  ''dstore'' и  ''ret''. Вторая форма применима только к инструкции ''iinc''.

В любом случае за байт-кодом инструкцией ''wide'' следует байт-код модифицируемой инструкции. Вне зависимости от формы два беззнаковых байта ''байт_индекса1'' и ''байт_индекса2'', следующие за байт-кодом модифицируемой инструкции преобразуются в 16-ти битный беззнаковый ''индекс'' локальной переменной текущего фрейма ([[Спецификация виртуальной машины Java#Фреймы|§2.6]]), где ''значение'' ''индекса'' равно (''байт_индекса1'' << 8) <nowiki>|</nowiki> ''байт_индекса2''. Там, где инструкция ''wide'' модифицирует поведение инструкций ''lload'',  ''dload'',  ''lstore'' и  ''dstore'', ''индекс'' локальной переменной, следующий за вычисленным ранее (''индекс'' + 1), должен также указывать на локальную переменную. Два беззнаковых байта ''байт_константы1'' и ''байт_константы2'', следуют непосредственно за байтом_индекса1 и байтом_индекса2  во второй форме ''wide''. Эти байты также преобразуются в знаковую 16-ти битную константу по формуле (''байт_константы1'' << 8) <nowiki>|</nowiki> ''байт_константы2''.

«Расширенная» инструкция выполняет то же, что и стандартная, за исключением того, что использует более широкий ''индекс'', а в случае второй формы – ещё и слагаемое более широкого диапазона.
|}
<br>
{| style="border-collapse:collapse;"
|width="150px" style="vertical-align:top;"|'''Примечания'''
| style="vertical-align:top;"|Хотя мы и говорим «изменяет поведение другой инструкции» инструкция ''wide'' по сути использует байт код другой инструкции в качестве своего собственного операнда, в процессе выполнения изменяя нормальное поведение исходной команды. В случае расширения инструкции ''iinc'' изменяется и формат команды: один из операндов смещается относительно позиции байт-кода ''iinc'' (имеется в виду второй байт константы инкремента – ''прим. перев.''). Расширенная  инструкция никогда не должна выполняться без инструкции ''wide'': её адрес не может быть целевым адресом переход при передаче управления.
|}

